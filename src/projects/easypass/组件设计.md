## 幂等组件

```java
// ===================================================================================
// 文件: pom.xml
// 描述: Maven项目依赖配置.
// ===================================================================================
/*
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    <!-- SpEL表达式解析需要 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
*/


// ===================================================================================
// 文件: com/example/idempotent/annotation/Idempotent.java
// 描述: 自定义幂等注解.
// ===================================================================================
package com.example.idempotent.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.concurrent.TimeUnit;

/**
 * 幂等性注解
 * 用于标记需要进行幂等性校验的方法。
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {

    /**
     * 幂等键的SpEL表达式。
     * <p>
     * 用于动态生成每个请求的唯一标识。
     * 例如: "#user.id" 或 "#args[0].orderId"
     * </p>
     * @return SpEL表达式
     */
    String key();

    /**
     * 幂等键的过期时间。
     * 默认为1秒。
     * @return 过期时间
     */
    long expireTime() default 1;

    /**
     * 过期时间单位。
     * 默认为秒。
     * @return 时间单位
     */
    TimeUnit timeUnit() default TimeUnit.SECONDS;

    /**
     * 提示信息。
     * 当发生重复请求时，返回给用户的提示信息。
     * @return 提示信息
     */
    String message() default "重复请求，请稍后再试";
}


// ===================================================================================
// 文件: com/example/idempotent/aspect/IdempotentAspect.java
// 描述: 幂等性切面, 处理核心逻辑.
// ===================================================================================
package com.example.idempotent.aspect;

import com.example.idempotent.annotation.Idempotent;
import com.example.idempotent.exception.IdempotentException;
import lombok.RequiredArgsConstructor;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.core.StandardReflectionParameterNameDiscoverer;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.expression.Expression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Aspect
@Component
@RequiredArgsConstructor
public class IdempotentAspect {

    private final StringRedisTemplate stringRedisTemplate;
    private final SpelExpressionParser spelExpressionParser = new SpelExpressionParser();
    private final StandardReflectionParameterNameDiscoverer parameterNameDiscoverer = new StandardReflectionParameterNameDiscoverer();

    private static final String IDEMPOTENT_KEY_PREFIX = "idempotent:";

    /**
     * 环绕通知，拦截所有标记了 @Idempotent 注解的方法
     *
     * @param joinPoint 切点
     * @param idempotent 注解实例
     * @return 方法执行结果
     * @throws Throwable 异常
     */
    @Around("@annotation(idempotent)")
    public Object around(ProceedingJoinPoint joinPoint, Idempotent idempotent) throws Throwable {
        // 1. 解析SpEL表达式，生成幂等键
        String idempotentKey = parseSpelKey(joinPoint, idempotent.key());
        String fullKey = IDEMPOTENT_KEY_PREFIX + idempotentKey;

        // 2. 尝试向Redis设置这个key
        // 使用 setIfAbsent (等同于SETNX) 来保证原子性
        Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(fullKey, "1", idempotent.expireTime(), idempotent.timeUnit());

        // 3. 判断结果
        if (success == null || !success) {
            // 设置失败，说明key已存在，是重复请求
            throw new IdempotentException(idempotent.message());
        }

        try {
            // 4. 设置成功，说明是第一次请求，执行目标方法
            return joinPoint.proceed();
        } finally {
            // 5. 【可选】如果希望方法执行失败后可以重试，可以在这里删除key
            //    但是一般幂等场景下，无论成功失败都不应重试，所以这里注释掉
            // stringRedisTemplate.delete(fullKey);
        }
    }

    /**
     * 解析SpEL表达式
     *
     * @param joinPoint 切点
     * @param spel      SpEL表达式字符串
     * @return 解析后的字符串
     */
    private String parseSpelKey(ProceedingJoinPoint joinPoint, String spel) {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        Object[] args = joinPoint.getArgs();
        String[] paramNames = parameterNameDiscoverer.getParameterNames(method);

        // 创建SpEL上下文
        StandardEvaluationContext context = new StandardEvaluationContext();
        if (paramNames != null && paramNames.length > 0) {
            for (int i = 0; i < args.length; i++) {
                context.setVariable(paramNames[i], args[i]);
            }
        }
        // #args 变量可以访问所有参数的数组
        context.setVariable("args", args);

        try {
            Expression expression = spelExpressionParser.parseExpression(spel);
            return expression.getValue(context, String.class);
        } catch (Exception e) {
            // SpEL表达式解析失败，抛出异常
            throw new IdempotentException("无法解析幂等键，请检查SpEL表达式: " + spel);
        }
    }
}


// ===================================================================================
// 文件: com/example/idempotent/exception/IdempotentException.java
// 描述: 自定义幂等异常.
// ===================================================================================
package com.example.idempotent.exception;

public class IdempotentException extends RuntimeException {
    public IdempotentException(String message) {
        super(message);
    }
}


// ===================================================================================
// 文件: com/example/idempotent/exception/GlobalExceptionHandler.java
// 描述: 全局异常处理器, 用于捕获幂等异常并返回友好提示.
// ===================================================================================
package com.example.idempotent.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.Map;
import java.util.HashMap;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IdempotentException.class)
    public ResponseEntity<Map<String, Object>> handleIdempotentException(IdempotentException ex) {
        Map<String, Object> response = new HashMap<>();
        response.put("code", 429); // 429 Too Many Requests
        response.put("message", ex.getMessage());
        return new ResponseEntity<>(response, HttpStatus.TOO_MANY_REQUESTS);
    }
}


// ===================================================================================
// 文件: com/example/idempotent/controller/TestController.java
// 描述: 测试API接口.
// ===================================================================================
package com.example.idempotent.controller;

import com.example.idempotent.annotation.Idempotent;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.TimeUnit;

@RestController
@Slf4j
public class TestController {

    @Data
    public static class OrderRequest {
        private String orderId;
        private Long userId;
        private Double amount;
    }

    /**
     * 示例1: 使用请求体中的字段作为幂等键
     * SpEL: #request.orderId
     * 10秒内，对于同一个orderId的请求，只有第一次会成功。
     */
    @PostMapping("/create-order")
    @Idempotent(key = "#request.orderId", expireTime = 10, timeUnit = TimeUnit.SECONDS, message = "订单正在创建中，请勿重复提交")
    public String createOrder(@RequestBody OrderRequest request) throws InterruptedException {
        log.info("开始处理创建订单请求: {}", request.getOrderId());
        // 模拟业务处理耗时
        Thread.sleep(2000);
        log.info("订单创建成功: {}", request.getOrderId());
        return "订单创建成功: " + request.getOrderId();
    }

    /**
     * 示例2: 组合多个字段作为幂等键
     * SpEL: #request.userId + ':' + #request.orderId
     */
    @PostMapping("/update-order")
    @Idempotent(key = "#request.userId + ':' + #request.orderId", expireTime = 5)
    public String updateOrder(@RequestBody OrderRequest request) {
        log.info("处理更新订单请求: userId={}, orderId={}", request.getUserId(), request.getOrderId());
        return String.format("订单更新成功: userId=%d, orderId=%s", request.getUserId(), request.getOrderId());
    }

    /**
     * 示例3: 使用请求头中的字段作为幂等键
     * SpEL: #token
     * 注意: @RequestHeader("X-Request-ID") 中的值要和SpEL表达式中的 #token 对应。
     */
    @PostMapping("/pay")
    @Idempotent(key = "#requestId", message = "支付请求处理中，请勿重复操作")
    public String pay(@RequestHeader("X-Request-ID") String requestId, @RequestBody OrderRequest request) {
        log.info("处理支付请求: Request-ID={}", requestId);
        return "支付成功，请求ID: " + requestId;
    }
}


// ===================================================================================
// 文件: src/main/resources/application.properties
// 描述: Spring Boot 应用配置.
// ===================================================================================
/*
# Redis 配置
spring.redis.host=localhost
spring.redis.port=6379
# spring.redis.password=
# spring.redis.database=0
*/
```

## 分布式锁


```java
/**
 * =======================================================================================
 * 分布式锁基础组件 (Distributed Lock Component)
 *
 * 本组件提供了企业级的分布式锁解决方案，包含以下核心特性：
 * 1.  设计模式: 基于策略模式（Strategy）和工厂模式（Factory）构建，易于扩展。
 * 2.  锁类型: 支持可重入锁、公平锁、读锁、写锁。
 * 3.  使用方式:
 * - @DLock 注解: 通过 AOP 实现声明式加锁，对业务代码零侵入。
 * - LockTemplate: 提供编程式 API，满足灵活调用需求。
 * 4.  高级功能:
 * - 事务兼容: 通过 AOP @Order 精确控制执行顺序，确保锁在事务之外。
 * - 本地锁优先: 在获取分布式锁前，先获取 JVM 本地锁，大幅提升高并发下的性能。
 * - 动态 Key: 支持 SpEL 表达式，可根据方法参数动态生成锁的 Key。
 *
 * 底层依赖: Redisson Client (推荐)
 * =======================================================================================
 */

// =======================================================================================
// 1. Maven 依赖 (pom.xml)
// =======================================================================================
/*
<dependencies>
    <!-- Spring Boot Starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!-- AOP -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
    <!-- Redisson 分布式锁 -->
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson-spring-boot-starter</artifactId>
        <version>3.17.7</version>
    </dependency>
    <!-- Guava for LoadingCache (本地锁) -->
    <dependency>
        <groupId>com.google.guava</groupId>
        <artifactId>guava</artifactId>
        <version>31.1-jre</version>
    </dependency>
</dependencies>
*/


// =======================================================================================
// 2. 核心注解 @DLock
// com.yourcompany.lock.annotation.DLock
// =======================================================================================
package com.yourcompany.lock.annotation;

import com.yourcompany.lock.enums.LockType;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.concurrent.TimeUnit;

/**
 * 分布式锁注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DLock {

    /**
     * 锁的名称/前缀。
     * 将与 keys 拼接成最终的锁 key。
     */
    String name();

    /**
     * 锁的 key。支持 SpEL 表达式动态生成。
     * 例如: "#userId", "#order.id"
     */
    String[] keys();

    /**
     * 锁的类型，默认为可重入锁。
     */
    LockType lockType() default LockType.REENTRANT;

    /**
     * 尝试获取锁的等待时间。
     * 默认-1，表示阻塞式获取锁，一直等待。
     */
    long waitTime() default -1;

    /**
     * 锁的持有时间（租期）。
     * 默认-1，表示启用 Redisson 的看门狗机制，自动续期。
     */
    long leaseTime() default -1;
    
    /**
     * 时间单位，默认为毫秒。
     */
    TimeUnit unit() default TimeUnit.MILLISECONDS;

    /**
     * 获取锁失败时的提示信息。
     */
    String failMessage() default "操作频繁，请稍后重试";
}


// =======================================================================================
// 3. 锁类型枚举
// com.yourcompany.lock.enums.LockType
// =======================================================================================
package com.yourcompany.lock.enums;

public enum LockType {
    /** 可重入锁 (非公平) */
    REENTRANT,
    /** 公平锁 */
    FAIR,
    /** 读锁 */
    READ,
    /** 写锁 */
    WRITE;
}


// =======================================================================================
// 4. 策略模式 - 锁策略接口
// com.yourcompany.lock.strategy.DistributedLock
// =======================================================================================
package com.yourcompany.lock.strategy;

import com.yourcompany.lock.enums.LockType;
import java.util.concurrent.TimeUnit;

public interface DistributedLock {

    /**
     * 尝试获取锁
     * @param key 锁的唯一标识
     * @param waitTime 等待时间
     * @param leaseTime 租期
     * @param unit 时间单位
     * @return 是否成功获取锁
     */
    boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException;

    /**
     * 释放锁
     * @param key 锁的唯一标识
     */
    void unlock(String key);

    /**
     * 获取当前策略对应的锁类型
     * @return LockType
     */
    LockType getType();
}


// =======================================================================================
// 5. 策略模式 - 具体策略实现
// com.yourcompany.lock.strategy.impl.*
// =======================================================================================
package com.yourcompany.lock.strategy.impl;

import com.yourcompany.lock.enums.LockType;
import com.yourcompany.lock.strategy.DistributedLock;
import org.redisson.api.RLock;
import org.redisson.api.RReadWriteLock;
import org.redisson.api.RedissonClient;
import org.springframework.stereotype.Component;
import java.util.concurrent.TimeUnit;

@Component
class ReentrantLockStrategy implements DistributedLock {
    private final RedissonClient redissonClient;
    public ReentrantLockStrategy(RedissonClient redissonClient) { this.redissonClient = redissonClient; }
    @Override
    public boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
        RLock lock = redissonClient.getLock(key);
        return lock.tryLock(waitTime, leaseTime, unit);
    }
    @Override
    public void unlock(String key) {
        RLock lock = redissonClient.getLock(key);
        if (lock.isLocked() && lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
    }
    @Override
    public LockType getType() { return LockType.REENTRANT; }
}

@Component
class FairLockStrategy implements DistributedLock {
    private final RedissonClient redissonClient;
    public FairLockStrategy(RedissonClient redissonClient) { this.redissonClient = redissonClient; }
    @Override
    public boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
        RLock lock = redissonClient.getFairLock(key);
        return lock.tryLock(waitTime, leaseTime, unit);
    }
    @Override
    public void unlock(String key) {
        RLock lock = redissonClient.getFairLock(key);
        if (lock.isLocked() && lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
    }
    @Override
    public LockType getType() { return LockType.FAIR; }
}

@Component
class ReadLockStrategy implements DistributedLock {
    private final RedissonClient redissonClient;
    public ReadLockStrategy(RedissonClient redissonClient) { this.redissonClient = redissonClient; }
    @Override
    public boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
        RReadWriteLock rwLock = redissonClient.getReadWriteLock(key);
        return rwLock.readLock().tryLock(waitTime, leaseTime, unit);
    }
    @Override
    public void unlock(String key) {
        RReadWriteLock rwLock = redissonClient.getReadWriteLock(key);
        RLock readLock = rwLock.readLock();
        if (readLock.isLocked() && readLock.isHeldByCurrentThread()) {
            readLock.unlock();
        }
    }
    @Override
    public LockType getType() { return LockType.READ; }
}

@Component
class WriteLockStrategy implements DistributedLock {
    private final RedissonClient redissonClient;
    public WriteLockStrategy(RedissonClient redissonClient) { this.redissonClient = redissonClient; }
    @Override
    public boolean tryLock(String key, long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
        RReadWriteLock rwLock = redissonClient.getReadWriteLock(key);
        return rwLock.writeLock().tryLock(waitTime, leaseTime, unit);
    }
    @Override
    public void unlock(String key) {
        RReadWriteLock rwLock = redissonClient.getReadWriteLock(key);
        RLock writeLock = rwLock.writeLock();
        if (writeLock.isLocked() && writeLock.isHeldByCurrentThread()) {
            writeLock.unlock();
        }
    }
    @Override
    public LockType getType() { return LockType.WRITE; }
}


// =======================================================================================
// 6. 工厂模式 - 锁工厂
// com.yourcompany.lock.factory.LockFactory
// =======================================================================================
package com.yourcompany.lock.factory;

import com.yourcompany.lock.enums.LockType;
import com.yourcompany.lock.strategy.DistributedLock;
import org.springframework.stereotype.Component;
import javax.annotation.PostConstruct;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;

@Component
public class LockFactory {
    private final List<DistributedLock> lockStrategies;
    private final Map<LockType, DistributedLock> strategyMap = new EnumMap<>(LockType.class);

    public LockFactory(List<DistributedLock> lockStrategies) {
        this.lockStrategies = lockStrategies;
    }

    @PostConstruct
    public void init() {
        lockStrategies.forEach(strategy -> strategyMap.put(strategy.getType(), strategy));
    }

    public DistributedLock getLock(LockType lockType) {
        if (lockType == null) {
            lockType = LockType.REENTRANT; // 默认可重入锁
        }
        DistributedLock strategy = strategyMap.get(lockType);
        if (strategy == null) {
            throw new IllegalArgumentException("Unsupported lock type: " + lockType);
        }
        return strategy;
    }
}


// =======================================================================================
// 7. AOP 切面实现
// com.yourcompany.lock.aspect.DLockAspect
// =======================================================================================
package com.yourcompany.lock.aspect;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.yourcompany.lock.annotation.DLock;
import com.yourcompany.lock.exception.LockAcquisitionException;
import com.yourcompany.lock.factory.LockFactory;
import com.yourcompany.lock.strategy.DistributedLock;
import com.yourcompany.lock.support.SpELParser;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Aspect
@Component
@Order(1) // 关键：保证在 @Transactional 之前执行，数值越小优先级越高
public class DLockAspect {

    private static final Logger log = LoggerFactory.getLogger(DLockAspect.class);

    private final LockFactory lockFactory;
    private final SpELParser spELParser;

    public DLockAspect(LockFactory lockFactory, SpELParser spELParser) {
        this.lockFactory = lockFactory;
        this.spELParser = spELParser;
    }

    // 本地锁缓存: 优先使用本地锁，提升性能，并防止锁重入问题
    private final LoadingCache<String, ReentrantLock> localLockCache = CacheBuilder.newBuilder()
            .maximumSize(1000)
            .expireAfterAccess(10, TimeUnit.MINUTES)
            .build(new CacheLoader<>() {
                @Override
                public ReentrantLock load(String key) {
                    return new ReentrantLock();
                }
            });

    @Around("@annotation(dLock)")
    public Object around(ProceedingJoinPoint pjp, DLock dLock) throws Throwable {
        // 1. 解析动态 Key
        String lockKey = generateLockKey(pjp, dLock);
        
        // 2. 获取本地锁（性能优化）
        ReentrantLock localLock = localLockCache.getUnchecked(lockKey);
        localLock.lock();
        log.debug("Acquired local lock for key: {}", lockKey);

        DistributedLock distributedLock = null;
        boolean isLockAcquired = false;
        try {
            // 3. 获取分布式锁策略
            distributedLock = lockFactory.getLock(dLock.lockType());
            
            // 4. 尝试获取分布式锁
            isLockAcquired = distributedLock.tryLock(lockKey, dLock.waitTime(), dLock.leaseTime(), dLock.unit());

            if (isLockAcquired) {
                log.debug("Acquired distributed lock for key: {}", lockKey);
                // 5. 执行业务方法
                return pjp.proceed();
            } else {
                // 6. 获取锁失败
                log.warn("Failed to acquire distributed lock for key: {}", lockKey);
                throw new LockAcquisitionException(dLock.failMessage());
            }
        } finally {
            // 7. 释放锁 (先分布式，后本地)
            if (isLockAcquired && distributedLock != null) {
                try {
                    distributedLock.unlock(lockKey);
                    log.debug("Released distributed lock for key: {}", lockKey);
                } catch (Exception e) {
                    log.error("Error releasing distributed lock for key: " + lockKey, e);
                }
            }
            localLock.unlock();
            log.debug("Released local lock for key: {}", lockKey);
        }
    }

    private String generateLockKey(ProceedingJoinPoint pjp, DLock dLock) {
        Method method = ((MethodSignature) pjp.getSignature()).getMethod();
        String[] keys = dLock.keys();
        String dynamicPart = Stream.of(keys)
                .map(key -> spELParser.parse(key, method, pjp.getArgs()))
                .collect(Collectors.joining(":"));
        return dLock.name() + ":" + dynamicPart;
    }
}


// =======================================================================================
// 8. 编程式 API - LockTemplate
// com.yourcompany.lock.template.LockTemplate
// =======================================================================================
package com.yourcompany.lock.template;

import com.yourcompany.lock.enums.LockType;
import com.yourcompany.lock.exception.LockAcquisitionException;
import com.yourcompany.lock.factory.LockFactory;
import com.yourcompany.lock.strategy.DistributedLock;
import org.springframework.stereotype.Component;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;

@Component
public class LockTemplate {

    private final LockFactory lockFactory;

    public LockTemplate(LockFactory lockFactory) {
        this.lockFactory = lockFactory;
    }

    public <T> T execute(String key, LockType lockType, long waitTime, long leaseTime, TimeUnit unit, Callable<T> callback) {
        DistributedLock lock = lockFactory.getLock(lockType);
        boolean isLockAcquired = false;
        try {
            isLockAcquired = lock.tryLock(key, waitTime, leaseTime, unit);
            if (isLockAcquired) {
                return callback.call();
            }
            throw new LockAcquisitionException("获取锁失败: " + key);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new LockAcquisitionException("获取锁被中断: " + key, e);
        } catch (Exception e) {
            if (e instanceof LockAcquisitionException) {
                throw (LockAcquisitionException) e;
            }
            throw new RuntimeException("执行锁内代码时发生异常", e);
        } finally {
            if (isLockAcquired) {
                lock.unlock(key);
            }
        }
    }

    /**
     * 阻塞式获取锁，使用默认租期（看门狗）
     */
    public <T> T execute(String key, LockType lockType, Callable<T> callback) {
        return execute(key, lockType, -1, -1, TimeUnit.MILLISECONDS, callback);
    }
}


// =======================================================================================
// 9. 辅助工具与异常
// com.yourcompany.lock.support.SpELParser
// com.yourcompany.lock.exception.LockAcquisitionException
// =======================================================================================
package com.yourcompany.lock.support;

import org.springframework.core.DefaultParameterNameDiscoverer;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.stereotype.Component;
import java.lang.reflect.Method;

@Component
public class SpELParser {
    private final SpelExpressionParser parser = new SpelExpressionParser();
    private final DefaultParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();

    public String parse(String spEL, Method method, Object[] args) {
        // # 开头才解析
        if (!spEL.startsWith("#")) {
            return spEL;
        }
        String[] paramNames = parameterNameDiscoverer.getParameterNames(method);
        EvaluationContext context = new StandardEvaluationContext();
        if (paramNames != null) {
            for (int i = 0; i < paramNames.length; i++) {
                context.setVariable(paramNames[i], args[i]);
            }
        }
        Expression expression = parser.parseExpression(spEL);
        return String.valueOf(expression.getValue(context));
    }
}

package com.yourcompany.lock.exception;

public class LockAcquisitionException extends RuntimeException {
    public LockAcquisitionException(String message) {
        super(message);
    }
    public LockAcquisitionException(String message, Throwable cause) {
        super(message, cause);
    }
}


// =======================================================================================
// 10. 使用示例
// com.yourcompany.service.OrderService
// =======================================================================================
package com.yourcompany.service;

import com.yourcompany.lock.annotation.DLock;
import com.yourcompany.lock.template.LockTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class OrderService {

    private static final Logger log = LoggerFactory.getLogger(OrderService.class);
    private final LockTemplate lockTemplate;

    public OrderService(LockTemplate lockTemplate) {
        this.lockTemplate = lockTemplate;
    }

    // --- 方式一: 注解式 (推荐) ---
    @DLock(name = "order", keys = {"#orderId"}, waitTime = 5000)
    @Transactional // @DLock 的 @Order(1) 保证它在 @Transactional 之前执行
    public void cancelOrder(String orderId, Long userId) {
        log.info("开始处理取消订单业务, orderId: {}, userId: {}", orderId, userId);
        // 模拟数据库操作
        try {
            Thread.sleep(200); // 模拟业务耗时
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        log.info("取消订单业务处理完成, orderId: {}", orderId);
    }

    // --- 方式二: 编程式 ---
    public String checkStock(String productId) {
        String lockKey = "stock:" + productId;
        return lockTemplate.execute(lockKey, com.yourcompany.lock.enums.LockType.READ, () -> {
            log.info("获取读锁成功，开始查询库存...");
            // 模拟查询库存
            Thread.sleep(100);
            log.info("库存查询完毕。");
            return "库存充足";
        });
    }
}

```

