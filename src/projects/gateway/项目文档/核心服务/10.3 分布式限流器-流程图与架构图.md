# 分布式限流器 - 流程图与架构图

## 一、流程图

### 5.1 限流判断总流程

```mermaid
flowchart TD
    Start([请求到达]) --> CheckEnabled{配置是否启用?}
    CheckEnabled -->|否| Allow([允许通过])
    CheckEnabled -->|是| LocalLimit[本地限流检查]

    LocalLimit --> LocalPass{本地限流通过?}
    LocalPass -->|否| Reject1([拒绝请求<br/>本地限流])
    LocalPass -->|是| RedisLimit[Redis分布式限流]

    RedisLimit --> RedisError{Redis异常?}
    RedisError -->|是| Degrade[降级策略<br/>放行请求]
    RedisError -->|否| RedisPass{Redis限流通过?}

    RedisPass -->|否| Reject2([拒绝请求<br/>Redis限流])
    RedisPass -->|是| Allow

    Degrade --> Allow

    style Start fill:#e1f5ff
    style Allow fill:#c8e6c9
    style Reject1 fill:#ffcdd2
    style Reject2 fill:#ffcdd2
    style Degrade fill:#fff9c4
```

### 5.2 请求处理链中的限流流程

```mermaid
flowchart TD
    Request([HTTP请求]) --> Parse[解析请求]
    Parse --> Auth[鉴权处理器<br/>Order=5]

    Auth --> AuthPass{鉴权通过?}
    AuthPass -->|否| AuthReject([返回401])
    AuthPass -->|是| RateLimit[限流处理器<br/>Order=10]

    RateLimit --> GlobalLimit[1. 全局限流检查]
    GlobalLimit --> GlobalPass{通过?}
    GlobalPass -->|否| RateLimitReject([返回429<br/>全局限流])

    GlobalPass -->|是| ServiceLimit[2. 服务级限流检查]
    ServiceLimit --> ServicePass{通过?}
    ServicePass -->|否| ServiceReject([返回429<br/>服务限流])

    ServicePass -->|是| InterfaceLimit[3. 接口级限流检查]
    InterfaceLimit --> InterfacePass{通过?}
    InterfacePass -->|否| InterfaceReject([返回429<br/>接口限流])

    InterfacePass -->|是| IpLimit[4. IP级限流检查]
    IpLimit --> IpPass{通过?}
    IpPass -->|否| IpReject([返回429<br/>IP限流])

    IpPass -->|是| Business[业务处理器<br/>Order=20]
    Business --> Response([返回响应])

    style Request fill:#e1f5ff
    style RateLimit fill:#fff9c4
    style Response fill:#c8e6c9
    style RateLimitReject fill:#ffcdd2
    style ServiceReject fill:#ffcdd2
    style InterfaceReject fill:#ffcdd2
    style IpReject fill:#ffcdd2
    style AuthReject fill:#ffcdd2
```

### 5.3 令牌桶算法执行流程

```mermaid
flowchart TD
    Start([请求到达]) --> GetKey[构建Redis Key<br/>rate_limit:xxx]
    GetKey --> GetCurrent[获取当前计数<br/>GET key]

    GetCurrent --> Compare{current < limit?}
    Compare -->|否| Reject([返回0<br/>拒绝请求])

    Compare -->|是| Incr[计数器+1<br/>INCR key]
    Incr --> CheckFirst{首次计数?}

    CheckFirst -->|是| SetExpire[设置过期时间<br/>EXPIRE key 1]
    CheckFirst -->|否| Allow([返回1<br/>允许通过])

    SetExpire --> Allow

    style Start fill:#e1f5ff
    style Allow fill:#c8e6c9
    style Reject fill:#ffcdd2
    style GetKey fill:#fff9c4
    style Incr fill:#fff9c4
```

### 5.4 滑动窗口算法执行流程

```mermaid
flowchart TD
    Start([请求到达]) --> GetKey[构建Redis Key<br/>rate_limit:xxx]
    GetKey --> CalcExpire[计算窗口起始时间<br/>current - window*1000]

    CalcExpire --> RemoveExpired[删除过期数据<br/>ZREMRANGEBYSCORE]
    RemoveExpired --> CountCurrent[统计窗口内请求数<br/>ZCARD key]

    CountCurrent --> Compare{count < limit?}
    Compare -->|否| Reject([返回0<br/>拒绝请求])

    Compare -->|是| AddRequest[添加当前请求<br/>ZADD key current current]
    AddRequest --> SetExpire[设置过期时间<br/>EXPIRE key window+1]

    SetExpire --> Allow([返回1<br/>允许通过])

    style Start fill:#e1f5ff
    style Allow fill:#c8e6c9
    style Reject fill:#ffcdd2
    style RemoveExpired fill:#fff9c4
    style AddRequest fill:#fff9c4
```

### 5.5 配置更新流程

```mermaid
flowchart TD
    Start([网关中心<br/>配置变更]) --> SaveDB[保存到数据库]
    SaveDB --> SyncRedis[同步到Redis<br/>rate_limit_config:*]

    SyncRedis --> Publish[发布消息<br/>rate-limit-config-update]

    Publish --> Gateway1[网关节点1<br/>接收消息]
    Publish --> Gateway2[网关节点2<br/>接收消息]
    Publish --> Gateway3[网关节点3<br/>接收消息]

    Gateway1 --> Update1[更新本地配置]
    Gateway2 --> Update2[更新本地配置]
    Gateway3 --> Update3[更新本地配置]

    Update1 --> Clear1[清除本地限流器缓存]
    Update2 --> Clear2[清除本地限流器缓存]
    Update3 --> Clear3[清除本地限流器缓存]

    Clear1 --> Effect1([配置生效])
    Clear2 --> Effect2([配置生效])
    Clear3 --> Effect3([配置生效])

    style Start fill:#e1f5ff
    style Publish fill:#fff9c4
    style Effect1 fill:#c8e6c9
    style Effect2 fill:#c8e6c9
    style Effect3 fill:#c8e6c9
```

## 二、架构图

### 6.1 系统整体架构

```mermaid
graph TB
    subgraph "网关中心"
        Center[限流配置管理]
        CenterDB[(MySQL数据库)]
        Center --> CenterDB
    end

    subgraph "Redis集群"
        RedisConfig[配置存储<br/>rate_limit_config:*]
        RedisCounter[限流计数器<br/>rate_limit:*]
        RedisPubSub[消息队列<br/>rate-limit-config-update]
    end

    subgraph "网关核心集群"
        subgraph "Gateway-1"
            G1Listener[配置监听器]
            G1Handler[限流处理器]
            G1Local[本地限流器]
        end

        subgraph "Gateway-2"
            G2Listener[配置监听器]
            G2Handler[限流处理器]
            G2Local[本地限流器]
        end

        subgraph "Gateway-3"
            G3Listener[配置监听器]
            G3Handler[限流处理器]
            G3Local[本地限流器]
        end
    end

    Center -->|1.保存配置| RedisConfig
    Center -->|2.发布消息| RedisPubSub

    RedisPubSub -->|3.订阅消息| G1Listener
    RedisPubSub -->|3.订阅消息| G2Listener
    RedisPubSub -->|3.订阅消息| G3Listener

    G1Listener -->|4.更新配置| G1Handler
    G2Listener -->|4.更新配置| G2Handler
    G3Listener -->|4.更新配置| G3Handler

    G1Handler -->|5.本地限流| G1Local
    G1Handler -->|6.Redis限流| RedisCounter

    G2Handler -->|5.本地限流| G2Local
    G2Handler -->|6.Redis限流| RedisCounter

    G3Handler -->|5.本地限流| G3Local
    G3Handler -->|6.Redis限流| RedisCounter

    style Center fill:#e1f5ff
    style RedisConfig fill:#fff9c4
    style RedisCounter fill:#fff9c4
    style RedisPubSub fill:#fff9c4
```

### 6.2 限流器内部架构

```mermaid
graph TB
    subgraph "DistributedRateLimiter 分布式限流器"
        direction TB

        subgraph "配置管理"
            ConfigCache[配置缓存<br/>ConcurrentHashMap]
            UpdateConfig[更新配置]
            RemoveConfig[删除配置]
        end

        subgraph "本地限流"
            LocalCache[本地限流器缓存<br/>ConcurrentHashMap]
            GuavaLimiter[Guava RateLimiter<br/>容量=配置值*1.2]
        end

        subgraph "Redis限流"
            TokenBucket[令牌桶算法<br/>Lua脚本]
            SlidingWindow[滑动窗口算法<br/>Lua脚本]
        end

        subgraph "降级策略"
            ErrorHandle[异常处理]
            Fallback[降级为本地限流]
        end
    end

    Request([请求]) --> ConfigCache
    ConfigCache --> LocalCache
    LocalCache --> GuavaLimiter

    GuavaLimiter -->|通过| TokenBucket
    GuavaLimiter -->|通过| SlidingWindow

    TokenBucket --> ErrorHandle
    SlidingWindow --> ErrorHandle

    ErrorHandle -->|异常| Fallback
    ErrorHandle -->|正常| Response([响应])
    Fallback --> Response

    UpdateConfig -.->|更新| ConfigCache
    UpdateConfig -.->|清除| LocalCache
    RemoveConfig -.->|删除| ConfigCache
    RemoveConfig -.->|删除| LocalCache

    style Request fill:#e1f5ff
    style Response fill:#c8e6c9
    style Fallback fill:#ffcdd2
```

### 6.3 多级限流架构

```mermaid
flowchart TB
    Request([客户端请求])

    subgraph Layer1["第一层：全局限流"]
        Global[GLOBAL限流<br/>10000 QPS]
    end

    subgraph Layer2["第二层：服务级限流"]
        Service1[user-service<br/>2000 QPS]
        Service2[order-service<br/>3000 QPS]
        Service3[product-service<br/>5000 QPS]
    end

    subgraph Layer3["第三层：接口级限流"]
        Interface1["api/login<br/>500 QPS"]
        Interface2["api/register<br/>300 QPS"]
        Interface3["api/order<br/>1000 QPS"]
    end

    subgraph Layer4["第四层：IP级限流"]
        IP1[192.168.1.100<br/>10 QPS]
        IP2[192.168.1.101<br/>10 QPS]
        IP3[192.168.1.102<br/>10 QPS]
    end

    Backend1([后端服务])
    Backend2([后端服务])
    Backend3([后端服务])

    Request --> Global

    Global --> Service1
    Global --> Service2
    Global --> Service3

    Service1 --> Interface1
    Service1 --> Interface2
    Service2 --> Interface3

    Interface1 --> IP1
    Interface2 --> IP2
    Interface3 --> IP3

    IP1 --> Backend1
    IP2 --> Backend2
    IP3 --> Backend3

    style Request fill:#e1f5ff
    style Global fill:#ffcdd2
    style Service1 fill:#fff9c4
    style Service2 fill:#fff9c4
    style Service3 fill:#fff9c4
    style Interface1 fill:#c8e6c9
    style Interface2 fill:#c8e6c9
    style Interface3 fill:#c8e6c9
    style Backend1 fill:#e8f5e9
    style Backend2 fill:#e8f5e9
    style Backend3 fill:#e8f5e9
```

### 6.4 本地限流与Redis协同架构

```mermaid
graph TB
    subgraph "请求流量分布"
        Traffic[实际流量<br/>1500 QPS]
    end

    subgraph "本地限流层"
        LocalLimiter[本地限流器<br/>1200 QPS<br/>配置值*1.2]
        LocalPass[通过: 1200 QPS]
        LocalReject[拒绝: 300 QPS]
    end

    subgraph "Redis限流层"
        RedisLimiter[Redis限流器<br/>1000 QPS<br/>精确配置值]
        RedisPass[通过: 1000 QPS]
        RedisReject[拒绝: 200 QPS]
    end

    subgraph "结果"
        FinalPass[最终通过<br/>1000 QPS]
        FinalReject[最终拒绝<br/>500 QPS]
    end

    Traffic --> LocalLimiter
    LocalLimiter --> LocalPass
    LocalLimiter --> LocalReject

    LocalPass --> RedisLimiter
    RedisLimiter --> RedisPass
    RedisLimiter --> RedisReject

    RedisPass --> FinalPass
    LocalReject --> FinalReject
    RedisReject --> FinalReject

    style Traffic fill:#e1f5ff
    style LocalLimiter fill:#fff9c4
    style RedisLimiter fill:#fff9c4
    style FinalPass fill:#c8e6c9
    style FinalReject fill:#ffcdd2

    Note1[本地限流保护Redis<br/>减少20%的Redis请求]
    Note2[Redis精确控制<br/>保证全局一致性]

    LocalLimiter -.-> Note1
    RedisLimiter -.-> Note2
```

### 6.5 配置同步架构

```mermaid
sequenceDiagram
    participant Admin as 管理员
    participant Center as 网关中心
    participant DB as MySQL
    participant Redis as Redis
    participant G1 as Gateway-1
    participant G2 as Gateway-2
    participant G3 as Gateway-3

    Admin->>Center: 1. 创建/更新限流配置
    Center->>DB: 2. 保存到数据库
    DB-->>Center: 3. 保存成功

    Center->>Redis: 4. 同步配置到Redis<br/>rate_limit_config:*
    Redis-->>Center: 5. 同步成功

    Center->>Redis: 6. 发布配置更新消息<br/>rate-limit-config-update

    Redis->>G1: 7. 推送消息
    Redis->>G2: 7. 推送消息
    Redis->>G3: 7. 推送消息

    G1->>G1: 8. 更新本地配置<br/>清除限流器缓存
    G2->>G2: 8. 更新本地配置<br/>清除限流器缓存
    G3->>G3: 8. 更新本地配置<br/>清除限流器缓存

    G1-->>Admin: 9. 配置生效
    G2-->>Admin: 9. 配置生效
    G3-->>Admin: 9. 配置生效
```

## 三、性能分析

### 7.1 性能对比

| 限流方式 | 响应时间 | 吞吐量 | 准确性 | 适用场景 |
|---------|---------|--------|--------|---------|
| **仅本地限流** | 纳秒级 | 极高 | 低（单机） | 单机应用 |
| **仅Redis限流** | 毫秒级 | 中等 | 高（分布式） | 低并发分布式 |
| **本地+Redis** | 纳秒-毫秒 | 高 | 高（分布式） | 高并发分布式 |

### 7.2 本地限流的性能优势

```
假设：
- 配置限流：1000 QPS
- 实际流量：1500 QPS
- 本地限流：1200 QPS（1.2倍）

仅Redis限流：
  Redis请求数：1500次/秒
  Redis压力：高

本地+Redis限流：
  本地拒绝：300次/秒
  Redis请求数：1200次/秒
  Redis压力：降低20%
```

### 7.3 降级策略的可用性保障

```
正常情况：
  本地限流 → Redis限流 → 业务处理

Redis异常：
  本地限流 → 降级放行 → 业务处理

保障：
  - 服务不中断
  - 本地限流仍生效
  - 避免限流器成为单点故障

