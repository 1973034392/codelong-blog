# 分布式限流器 - 流程图与架构图

## 一、流程图

### 5.1 限流判断总流程

#### DISTRIBUTED 模式（默认）

```mermaid
flowchart TD
    Start([请求到达]) --> CheckEnabled{配置是否启用?}
    CheckEnabled -->|否| Allow([允许通过])
    CheckEnabled -->|是| RedisLimit[Redis分布式限流<br/>滑动窗口/令牌桶]

    RedisLimit --> RedisError{Redis异常?}
    RedisError -->|是| Degrade[降级策略<br/>放行请求]
    RedisError -->|否| RedisPass{限流通过?}

    RedisPass -->|否| Reject([拒绝请求])
    RedisPass -->|是| Allow

    Degrade --> Allow

    style Start fill:#e1f5ff
    style Allow fill:#c8e6c9
    style Reject fill:#ffcdd2
    style Degrade fill:#fff9c4
```

#### LOCAL_DISTRIBUTED 模式（高性能）

```mermaid
flowchart TD
    Start([请求到达]) --> CheckEnabled{配置是否启用?}
    CheckEnabled -->|否| Allow([允许通过])
    CheckEnabled -->|是| LocalCheck[检查本地令牌计数器]

    LocalCheck --> LocalHas{本地有令牌?}
    LocalHas -->|是| Consume[消费令牌]
    Consume --> Allow

    LocalHas -->|否| BatchGet[从Redis批量获取令牌]
    BatchGet --> BatchError{获取成功?}
    BatchError -->|否| Reject([拒绝请求])
    BatchError -->|是| SetLocal[设置本地计数器]
    SetLocal --> Consume

    style Start fill:#e1f5ff
    style Allow fill:#c8e6c9
    style Reject fill:#ffcdd2
    style LocalCheck fill:#fff9c4
    style BatchGet fill:#fff9c4
```

### 5.2 请求处理链中的限流流程

```mermaid
flowchart TD
    Request([HTTP请求]) --> Parse[解析请求]
    Parse --> Auth[鉴权处理器<br/>AuthorizationHandler]

    Auth --> AuthPass{鉴权通过?}
    AuthPass -->|否| AuthReject([返回401])
    AuthPass -->|是| RateLimit[限流处理器<br/>RateLimitHandler]

    RateLimit --> GlobalLimit[1. 全局限流检查]
    GlobalLimit --> GlobalPass{通过?}
    GlobalPass -->|否| RateLimitReject([返回429<br/>全局限流])

    GlobalPass -->|是| ServiceLimit[2. 服务级限流检查]
    ServiceLimit --> ServicePass{通过?}
    ServicePass -->|否| ServiceReject([返回429<br/>服务限流])

    ServicePass -->|是| InterfaceLimit[3. 接口级限流检查]
    InterfaceLimit --> InterfacePass{通过?}
    InterfacePass -->|否| InterfaceReject([返回429<br/>接口限流])

    InterfacePass -->|是| IpLimit[4. IP级限流检查]
    IpLimit --> IpPass{通过?}
    IpPass -->|否| IpReject([返回429<br/>IP限流])

    IpPass -->|是| PreExecutor[前置处理器<br/>PreExecutorHandler]
    PreExecutor --> Executor[执行器<br/>ExecutorHandler]
    Executor --> PostExecutor[后置处理器<br/>PostExecutorHandler]
    PostExecutor --> Response([返回响应])

    style Request fill:#e1f5ff
    style RateLimit fill:#fff9c4
    style Response fill:#c8e6c9
    style RateLimitReject fill:#ffcdd2
    style ServiceReject fill:#ffcdd2
    style InterfaceReject fill:#ffcdd2
    style IpReject fill:#ffcdd2
    style AuthReject fill:#ffcdd2
```

### 5.3 令牌桶算法执行流程（DISTRIBUTED 模式）

```mermaid
flowchart TD
    Start([请求到达]) --> GetKey[构建Redis Key<br/>rate_limit:xxx]
    GetKey --> GetCurrent[获取当前计数<br/>GET key]

    GetCurrent --> Compare{current < limit?}
    Compare -->|否| Reject([返回0<br/>拒绝请求])

    Compare -->|是| Incr[计数器+1<br/>INCR key]
    Incr --> CheckFirst{首次计数?}

    CheckFirst -->|是| SetExpire[设置过期时间<br/>EXPIRE key 1]
    CheckFirst -->|否| Allow([返回1<br/>允许通过])

    SetExpire --> Allow

    style Start fill:#e1f5ff
    style Allow fill:#c8e6c9
    style Reject fill:#ffcdd2
    style GetKey fill:#fff9c4
    style Incr fill:#fff9c4
```

### 5.4 滑动窗口算法执行流程（DISTRIBUTED 模式）

```mermaid
flowchart TD
    Start([请求到达]) --> GetKey[构建Redis Key<br/>rate_limit:xxx]
    GetKey --> CalcExpire[计算窗口起始时间<br/>current - window*1000]

    CalcExpire --> RemoveExpired[删除过期数据<br/>ZREMRANGEBYSCORE]
    RemoveExpired --> CountCurrent[统计窗口内请求数<br/>ZCARD key]

    CountCurrent --> Compare{count < limit?}
    Compare -->|否| Reject([返回0<br/>拒绝请求])

    Compare -->|是| AddRequest[添加当前请求<br/>ZADD key current current]
    AddRequest --> SetExpire[设置过期时间<br/>EXPIRE key window+1]

    SetExpire --> Allow([返回1<br/>允许通过])

    style Start fill:#e1f5ff
    style Allow fill:#c8e6c9
    style Reject fill:#ffcdd2
    style RemoveExpired fill:#fff9c4
    style AddRequest fill:#fff9c4
```

### 5.5 批量获取令牌流程（LOCAL_DISTRIBUTED 模式）

```mermaid
flowchart TD
    Start([请求到达]) --> GetKey[构建Redis Key<br/>rate_limit:xxx]
    GetKey --> GetCurrent[获取当前计数<br/>GET key]

    GetCurrent --> CalcAvailable["计算可用令牌数<br/>min(batch_size, limit-current)"]
    CalcAvailable --> Compare{available &gt; 0?}

    Compare -->|否| Reject([返回0<br/>无可用令牌])

    Compare -->|是| IncrBy[增加计数<br/>INCRBY key available]
    IncrBy --> CheckFirst{首次计数?}

    CheckFirst -->|是| SetExpire[设置过期时间<br/>EXPIRE key 1]
    CheckFirst -->|否| Allow([返回available<br/>返回获取的令牌数])

    SetExpire --> Allow

    style Start fill:#e1f5ff
    style Allow fill:#c8e6c9
    style Reject fill:#ffcdd2
    style GetKey fill:#fff9c4
    style IncrBy fill:#fff9c4
```

### 5.6 配置更新流程

```mermaid
flowchart TD
    Start([网关中心<br/>配置变更]) --> SaveDB[保存到数据库]
    SaveDB --> SyncRedis[同步到Redis<br/>rate_limit_config:*]

    SyncRedis --> Publish[发布消息<br/>rate-limit-config-update]

    Publish --> Gateway1[网关节点1<br/>接收消息]
    Publish --> Gateway2[网关节点2<br/>接收消息]
    Publish --> Gateway3[网关节点3<br/>接收消息]

    Gateway1 --> Update1[更新本地配置]
    Gateway2 --> Update2[更新本地配置]
    Gateway3 --> Update3[更新本地配置]

    Update1 --> Clear1[清除本地限流器缓存]
    Update2 --> Clear2[清除本地限流器缓存]
    Update3 --> Clear3[清除本地限流器缓存]

    Clear1 --> Effect1([配置生效])
    Clear2 --> Effect2([配置生效])
    Clear3 --> Effect3([配置生效])

    style Start fill:#e1f5ff
    style Publish fill:#fff9c4
    style Effect1 fill:#c8e6c9
    style Effect2 fill:#c8e6c9
    style Effect3 fill:#c8e6c9
```

## 二、架构图

### 6.1 系统整体架构

```mermaid
graph TB
    subgraph "网关中心"
        Center[限流配置管理]
        CenterDB[(MySQL数据库)]
        Center --> CenterDB
    end

    subgraph "Redis集群"
        RedisConfig[配置存储<br/>rate_limit_config:*]
        RedisCounter[限流计数器<br/>rate_limit:*]
        RedisPubSub[消息队列<br/>rate-limit-config-update]
    end

    subgraph "网关核心集群"
        subgraph "Gateway-1"
            G1Listener[配置监听器]
            G1Handler[限流处理器]
            G1Local[本地限流器]
        end

        subgraph "Gateway-2"
            G2Listener[配置监听器]
            G2Handler[限流处理器]
            G2Local[本地限流器]
        end

        subgraph "Gateway-3"
            G3Listener[配置监听器]
            G3Handler[限流处理器]
            G3Local[本地限流器]
        end
    end

    Center -->|1.保存配置| RedisConfig
    Center -->|2.发布消息| RedisPubSub

    RedisPubSub -->|3.订阅消息| G1Listener
    RedisPubSub -->|3.订阅消息| G2Listener
    RedisPubSub -->|3.订阅消息| G3Listener

    G1Listener -->|4.更新配置| G1Handler
    G2Listener -->|4.更新配置| G2Handler
    G3Listener -->|4.更新配置| G3Handler

    G1Handler -->|5.本地限流| G1Local
    G1Handler -->|6.Redis限流| RedisCounter

    G2Handler -->|5.本地限流| G2Local
    G2Handler -->|6.Redis限流| RedisCounter

    G3Handler -->|5.本地限流| G3Local
    G3Handler -->|6.Redis限流| RedisCounter

    style Center fill:#e1f5ff
    style RedisConfig fill:#fff9c4
    style RedisCounter fill:#fff9c4
    style RedisPubSub fill:#fff9c4
```

### 6.2 限流器内部架构

#### DISTRIBUTED 模式

```mermaid
graph TB
    subgraph "DistributedRateLimiter 分布式限流器"
        direction TB

        subgraph "配置管理"
            ConfigCache[配置缓存<br/>ConcurrentHashMap]
            UpdateConfig[更新配置]
        end

        subgraph "Redis限流"
            TokenBucket[令牌桶算法<br/>Lua脚本]
            SlidingWindow[滑动窗口算法<br/>Lua脚本]
        end

        subgraph "降级策略"
            ErrorHandle[异常处理]
            Fallback[降级为放行]
        end
    end

    Request([请求]) --> ConfigCache
    ConfigCache --> TokenBucket
    ConfigCache --> SlidingWindow

    TokenBucket --> ErrorHandle
    SlidingWindow --> ErrorHandle

    ErrorHandle -->|异常| Fallback
    ErrorHandle -->|正常| Response([响应])
    Fallback --> Response

    UpdateConfig -.->|更新| ConfigCache

    style Request fill:#e1f5ff
    style Response fill:#c8e6c9
    style Fallback fill:#fff9c4
```

#### LOCAL_DISTRIBUTED 模式

```mermaid
graph TB
    subgraph "DistributedRateLimiter 分布式限流器"
        direction TB

        subgraph "配置管理"
            ConfigCache[配置缓存<br/>ConcurrentHashMap]
            UpdateConfig[更新配置]
        end

        subgraph "本地限流"
            LocalCounter[本地令牌计数器<br/>AtomicInteger]
            Consume[消费令牌<br/>CAS操作]
        end

        subgraph "Redis限流"
            BatchGet[批量获取令牌<br/>Lua脚本]
        end

        subgraph "降级策略"
            ErrorHandle[异常处理]
            Fallback[降级为放行]
        end
    end

    Request([请求]) --> ConfigCache
    ConfigCache --> LocalCounter
    LocalCounter --> Consume

    Consume -->|令牌充足| Response([响应])
    Consume -->|令牌不足| BatchGet
    BatchGet --> ErrorHandle

    ErrorHandle -->|异常| Fallback
    ErrorHandle -->|成功| LocalCounter
    Fallback --> Response

    UpdateConfig -.->|更新| ConfigCache
    UpdateConfig -.->|清除| LocalCounter

    style Request fill:#e1f5ff
    style Response fill:#c8e6c9
    style Fallback fill:#fff9c4
    style Consume fill:#fff3e0
    style BatchGet fill:#fff3e0
```

### 6.3 多级限流架构

```mermaid
flowchart TB
    Request([客户端请求])

    subgraph Layer1["第一层：全局限流"]
        Global[GLOBAL限流<br/>10000 QPS]
    end

    subgraph Layer2["第二层：服务级限流"]
        Service1[user-service<br/>2000 QPS]
        Service2[order-service<br/>3000 QPS]
        Service3[product-service<br/>5000 QPS]
    end

    subgraph Layer3["第三层：接口级限流"]
        Interface1["api/login<br/>500 QPS"]
        Interface2["api/register<br/>300 QPS"]
        Interface3["api/order<br/>1000 QPS"]
    end

    subgraph Layer4["第四层：IP级限流"]
        IP1[192.168.1.100<br/>10 QPS]
        IP2[192.168.1.101<br/>10 QPS]
        IP3[192.168.1.102<br/>10 QPS]
    end

    Backend1([后端服务])
    Backend2([后端服务])
    Backend3([后端服务])

    Request --> Global

    Global --> Service1
    Global --> Service2
    Global --> Service3

    Service1 --> Interface1
    Service1 --> Interface2
    Service2 --> Interface3

    Interface1 --> IP1
    Interface2 --> IP2
    Interface3 --> IP3

    IP1 --> Backend1
    IP2 --> Backend2
    IP3 --> Backend3

    style Request fill:#e1f5ff
    style Global fill:#ffcdd2
    style Service1 fill:#fff9c4
    style Service2 fill:#fff9c4
    style Service3 fill:#fff9c4
    style Interface1 fill:#c8e6c9
    style Interface2 fill:#c8e6c9
    style Interface3 fill:#c8e6c9
    style Backend1 fill:#e8f5e9
    style Backend2 fill:#e8f5e9
    style Backend3 fill:#e8f5e9
```

### 6.4 LOCAL_DISTRIBUTED 模式的高性能架构

```mermaid
graph TB
    subgraph "请求流量分布"
        Traffic[实际流量<br/>1000 QPS]
    end

    subgraph "本地限流层"
        LocalCounter[本地令牌计数器<br/>AtomicInteger]
        LocalPass[本地消费: 900 QPS<br/>纳秒级响应]
        LocalEmpty[令牌不足: 100 QPS]
    end

    subgraph "Redis批量获取"
        BatchGet[批量获取令牌<br/>每10次请求1次Redis]
        BatchPass[获取成功: 100 QPS]
        BatchReject[获取失败: 0 QPS]
    end

    subgraph "结果"
        FinalPass[最终通过<br/>1000 QPS]
        FinalReject[最终拒绝<br/>0 QPS]
    end

    Traffic --> LocalCounter
    LocalCounter --> LocalPass
    LocalCounter --> LocalEmpty

    LocalPass --> FinalPass
    LocalEmpty --> BatchGet
    BatchGet --> BatchPass
    BatchGet --> BatchReject

    BatchPass --> LocalCounter
    BatchReject --> FinalReject

    style Traffic fill:#e1f5ff
    style LocalCounter fill:#fff3e0
    style LocalPass fill:#c8e6c9
    style BatchGet fill:#fff9c4
    style FinalPass fill:#c8e6c9
    style FinalReject fill:#ffcdd2

    Note1["本地消费性能极高<br/>99%请求纳秒级响应"]
    Note2["Redis访问频率低<br/>减少99%的Redis请求"]

    LocalPass -.-> Note1
    BatchGet -.-> Note2
```

### 6.5 配置同步架构

```mermaid
sequenceDiagram
    participant Admin as 管理员
    participant Center as 网关中心
    participant DB as MySQL
    participant Redis as Redis
    participant G1 as Gateway-1
    participant G2 as Gateway-2
    participant G3 as Gateway-3

    Admin->>Center: 1. 创建/更新限流配置
    Center->>DB: 2. 保存到数据库
    DB-->>Center: 3. 保存成功

    Center->>Redis: 4. 同步配置到Redis<br/>rate_limit_config:*
    Redis-->>Center: 5. 同步成功

    Center->>Redis: 6. 发布配置更新消息<br/>rate-limit-config-update

    Redis->>G1: 7. 推送消息
    Redis->>G2: 7. 推送消息
    Redis->>G3: 7. 推送消息

    G1->>G1: 8. 更新本地配置<br/>清除限流器缓存
    G2->>G2: 8. 更新本地配置<br/>清除限流器缓存
    G3->>G3: 8. 更新本地配置<br/>清除限流器缓存

    G1-->>Admin: 9. 配置生效
    G2-->>Admin: 9. 配置生效
    G3-->>Admin: 9. 配置生效
```

## 三、性能分析

### 7.1 限流模式性能对比

| 限流模式 | 响应时间 | 吞吐量 | Redis 访问 | 准确性 | 适用场景 |
|---------|---------|--------|-----------|--------|---------|
| **DISTRIBUTED** | 毫秒级 | 中等 | 每次请求 | 高（分布式） | 中等并发、精度要求高 |
| **LOCAL_DISTRIBUTED** | 纳秒级 | 极高 | 批量访问 | 高（分布式） | 高并发、性能要求极高 |

### 7.2 LOCAL_DISTRIBUTED 模式的性能优势

```
假设：
- 配置限流：1000 QPS
- 实际流量：1000 QPS
- 批量大小：100

DISTRIBUTED 模式（仅 Redis）：
  Redis 请求数：1000 次/秒
  平均延迟：毫秒级
  Redis 压力：高

LOCAL_DISTRIBUTED 模式：
  本地消费：900 次/秒（纳秒级）
  Redis 请求数：10 次/秒（批量获取）
  平均延迟：纳秒级（99% 请求）
  Redis 压力：降低 99%
  性能提升：100 倍以上
```

### 7.3 降级策略的可用性保障

```
DISTRIBUTED 模式：
  正常情况：Redis 限流 → 业务处理
  Redis 异常：降级放行 → 业务处理
  保障：服务不中断

LOCAL_DISTRIBUTED 模式：
  正常情况：本地消费 → 业务处理
  本地令牌不足：批量获取 → 本地消费 → 业务处理
  Redis 异常：降级放行 → 业务处理
  保障：
    - 99% 请求不受 Redis 影响
    - 本地限流仍生效
    - 避免限流器成为单点故障
```

### 7.4 选择建议

**使用 DISTRIBUTED 模式（默认）：**
- 对限流精度要求高
- 并发量中等（< 10000 QPS）
- 对延迟不敏感

**使用 LOCAL_DISTRIBUTED 模式：**
- 对性能要求极高
- 并发量大（> 10000 QPS）
- 可以接受极小的精度偏差（批量大小范围内）

