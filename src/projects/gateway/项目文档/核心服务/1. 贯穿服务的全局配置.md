# 贯穿服务的全局配置

## 概述

`GlobalConfiguration` 类是网关服务的核心配置中心，负责加载应用配置、管理关键资源、执行服务初始化以及启动网络服务。该类作为整个网关服务的配置中枢，确保服务在启动时能够正确初始化并完成必要的准备工作。

## 读取配置

> 网关服务通过Spring Boot的配置文件（如application.yml）进行配置。

在配置文件配置属性:

```yaml
spring:
  application:
    name: api-gateway-core    # 网关服务名
  data:
    redis: # 获取接口信息
      database: 0
      host: localhost
      port: 6379
api-gateway:
  netty-port: 8888
  gateway-center: 127.0.0.1:18080
  group-key: test-key         # 用于启动时获得配置使用
  weight: 1                   # 网关权重(1-100)
  max-cache: 1000             # 连接对象本地缓存最大值
  boss-threads: 1
  worker-threads: 4
```

配置类通过`@ConfigurationProperties`注解实现配置绑定,在配置类中配置：

```java
@Data
@Component
@Slf4j
@ConfigurationProperties(prefix = "api-gateway")
public class GlobalConfiguration {
    /**
     * 配置文件中获取
     */
    private Integer nettyPort;
    private String gatewayCenter;
    private String groupKey;
    private Integer weight;
    private Integer maxCache;
    private Integer bossThreads;
    private Integer workerThreads;
}
```

## 管理连接源缓存

网关在处理高并发请求时，连接资源的创建和销毁会成为性能瓶颈。`GlobalConfiguration`通过`ConnectionResourcePool`实现了高效的连接管理,具体可查看连接池文档

## 执行服务初始化代码

> 由于项目需要在启动时对服务进行上报和获得当前服务名,所以在全局配置类这里需要执行初始化代码

```java
/**
 * 向网关中心注册服务
 *
 * @return 服务名称
 */
private String register() {
    String addr = this.gatewayCenter;
    String fullUrl = addr + "/gateway-group-detail/register";

    HttpRequest request = HttpUtil.createRequest(cn.hutool.http.Method.POST, fullUrl);
    request.header("Content-Type", "application/json");

    GroupRegisterReqVO registerVO = new GroupRegisterReqVO();
    registerVO.setGroupKey(this.groupKey);
    registerVO.setDetailName(environment.getProperty("spring.application.name", "api-gateway-core"));

    String localIp = "localhost";
    try {
        localIp = InetAddress.getLocalHost().getHostAddress();
    } catch (Exception ignored) {
    }
    registerVO.setDetailAddress(localIp + ":" + nettyPort);
    registerVO.setDetailWeight(this.weight);

    request.body(JSON.toJSONString(registerVO));
    try {
        HttpResponse response = request.execute();
        String body = response.body();
        String result = JSON.parseObject(body).getString("data");
        GroupDetailRegisterRespVO respVO = JSON.parseObject(result, GroupDetailRegisterRespVO.class);
        if (StrUtil.isNotBlank(result)) {
            log.info("服务注册成功: {}", respVO.getServerName());
        }
        this.safeKey = respVO.getSafeKey();
        this.safeSecret = respVO.getSafeSecret();
        return respVO.getServerName();
    } catch (Exception e) {
        throw new Error("服务注册失败");
    }
}
```

## 启动Netty服务

在项目启动时使用配置类的部分属性: 

```java
@PostConstruct
public void init() {
    Channel channel = this.start(config.getNettyPort(), config.getBossThreads(),config.getWorkerThreads());
    if (channel == null) {
        throw new RuntimeException("服务启动失败");
    }
}

public Channel start(Integer nettyPort, Integer bossThreads, Integer workThreads) {
    initEventLoopGroup(bossThreads, workThreads);
    try {
        ServerBootstrap b = new ServerBootstrap();
        b.group(boss, work)
                .channel(NioServerSocketChannel.class)
                .option(ChannelOption.SO_BACKLOG, 128)
                .childHandler(serverHandlerInitializer);

        return b
                .bind(nettyPort).sync()
                .channel();
    } catch (Exception e) {
        log.error("网关服务启动失败", e);
    }
    return null;
}
```

> 这是启动类

```java
@Slf4j
@Component
public class SocketServerBootStrap {
    @Resource
    private ServerHandlerInitializer serverHandlerInitializer;
    @Resource
    private GlobalConfiguration config;

    private EventLoopGroup boss;
    private EventLoopGroup work;

    private void initEventLoopGroup(Integer bossThreads, Integer workThreads) {
        this.boss = new NioEventLoopGroup(bossThreads);
        this.work = new NioEventLoopGroup(workThreads);
    }

    @PostConstruct
    public void init() {
        Channel channel = this.start(config.getNettyPort(), config.getBossThreads(), config.getWorkerThreads());
        if (channel == null) {
            throw new RuntimeException("服务启动失败");
        }
    }

    public Channel start(Integer nettyPort, Integer bossThreads, Integer workThreads) {
        initEventLoopGroup(bossThreads, workThreads);
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(boss, work)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childHandler(serverHandlerInitializer);

            return b
                    .bind(nettyPort).sync()
                    .channel();
        } catch (Exception e) {
            log.error("网关服务启动失败", e);
        }
        return null;
    }
}
```

> 这是启动加载器

```java
@Component
public class ServerHandlerInitializer extends ChannelInitializer<SocketChannel> {
    @Resource
    private AuthorizationHandler authorizationHandler;
    @Resource
    private PreExecutorHandler preExecutorHandler;
    @Resource
    private ExecutorHandler executorHandler;
    @Resource
    private PostExecutorHandler postExecutorHandler;
    @Resource
    private ResultHandler resultHandler;
    
    @Override
    protected void initChannel(SocketChannel channel) {
        ChannelPipeline line = channel.pipeline();
        line.addLast(new HttpRequestDecoder());
        line.addLast(new HttpResponseEncoder());
        line.addLast(new HttpObjectAggregator(1024 * 1024));
        line.addLast(authorizationHandler);
        line.addLast(preExecutorHandler);
        line.addLast(executorHandler);
        line.addLast(postExecutorHandler);
        line.addLast(resultHandler);
    }
}
```

**处理器链说明**：

1. `AuthorizationHandler`：验证请求安全凭证
2. `PreExecutorHandler`：执行请求前的自定义逻辑（限流、黑白名单等）
3. `ExecutorHandler`：核心业务处理（路由转发,泛化调用等）
4. `PostExecutorHandler`：响应后处理（日志记录、结果分析等）
5. `ResultHandler`：最终响应结果组装
