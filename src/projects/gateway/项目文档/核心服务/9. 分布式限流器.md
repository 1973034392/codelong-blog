# 分布式限流器 - 核心服务

## 概述

分布式限流器是网关核心服务的关键组件，采用**本地限流 + Redis分布式限流**的多级限流策略，能够处理超过Redis能力的高并发场景。限流器以Handler的形式集成到请求处理链中，支持网关中心实时配置，不影响其他服务。

## 核心特性

### 1. 多级限流架构

```
请求 → 本地限流(Guava RateLimiter) → Redis分布式限流 → 业务处理
         ↓ 快速失败                    ↓ 精确控制
         保护Redis                     跨节点协调
```

**设计理念：**
- **第一层（本地限流）**：使用Guava RateLimiter，设置为配置值的1.2倍，快速拦截大部分超限请求，保护Redis不被打垮
- **第二层（Redis限流）**：使用Lua脚本保证原子性，实现跨网关节点的精确限流控制

### 2. 四级限流粒度

| 限流级别 | 说明 | 应用场景 | 示例 |
|---------|------|---------|------|
| **GLOBAL** | 全局限流 | 保护整个网关集群 | 限制网关总QPS为10000 |
| **SERVICE** | 服务级限流 | 保护后端服务 | 限制user-service的QPS为1000 |
| **INTERFACE** | 接口级限流 | 保护特定接口 | 限制/api/login的QPS为100 |
| **IP** | IP级限流 | 防止恶意攻击 | 限制单个IP的QPS为50 |

### 3. 两种限流算法

#### 令牌桶算法（TOKEN_BUCKET）
- **原理**：以固定速率生成令牌，请求消耗令牌，令牌不足则拒绝
- **优点**：允许一定程度的突发流量
- **适用场景**：全局限流、服务级限流

#### 滑动窗口算法（SLIDING_WINDOW）
- **原理**：统计时间窗口内的请求数，超过阈值则拒绝
- **优点**：更精确的流量控制
- **适用场景**：接口级限流、IP限流

## 核心组件

### 1. RateLimitConfig - 限流配置

```java
@Data
@Builder
public class RateLimitConfig {
    private Long id;              // 配置ID
    private String ruleName;      // 规则名称
    private String limitType;     // 限流类型：GLOBAL/SERVICE/INTERFACE/IP
    private String limitTarget;   // 限流目标
    private Integer limitCount;   // 限流阈值（每秒请求数）
    private Integer timeWindow;   // 时间窗口（秒）
    private Boolean enabled;      // 是否启用
    private String strategy;      // 限流策略：TOKEN_BUCKET/SLIDING_WINDOW
}
```

### 2. DistributedRateLimiter - 分布式限流器

**核心方法：**

```java
public boolean tryAcquire(String key, RateLimitConfig config)
```

**执行流程：**

```
1. 检查配置是否启用
   ↓
2. 本地限流检查（Guava RateLimiter）
   ↓ 通过
3. Redis分布式限流检查（Lua脚本）
   ↓ 通过
4. 返回true，允许请求通过
```

**关键特性：**
- **降级策略**：Redis异常时自动降级为本地限流
- **配置热更新**：支持实时更新限流配置
- **高性能**：本地限流器使用ConcurrentHashMap缓存，避免重复创建

### 3. RateLimitPreHandler - 限流前置处理器

作为`CustomPreHandler`的实现，集成到请求处理链中。

```java
@Component
@Order(10)  // 执行顺序：10
public class RateLimitPreHandler implements CustomPreHandler {
    @Override
    public Result<Void> handle(HttpStatement httpStatement, FullHttpRequest request) {
        // 1. 全局限流检查
        // 2. 服务级限流检查
        // 3. 接口级限流检查
        // 4. IP级限流检查
    }
}
```

**处理器特性：**
- `getOrder()`: 返回10，在鉴权之后执行
- `canRunParallel()`: 返回false，串行执行确保准确性
- `isFailFast()`: 返回true，限流失败时快速返回

### 4. RateLimitConfigListener - 配置监听器

监听Redis的`rate-limit-config-update`频道，实时更新限流配置。

```java
@Component
public class RateLimitConfigListener implements MessageListener {
    @PostConstruct
    public void init() {
        // 启动时加载所有限流配置
        loadAllRateLimitConfigs();
    }

    @Override
    public void onMessage(Message message, byte[] pattern) {
        // 处理配置更新消息
        // 支持单个配置更新和全量重载
    }
}
```

**监听机制：**
- **启动加载**：服务启动时从Redis加载所有限流配置
- **实时更新**：监听配置变更消息，动态更新本地限流器
- **全量重载**：支持`RELOAD_ALL`命令，重新加载所有配置

## Redis数据结构

### 1. 限流配置存储

```
Key: rate_limit_config:{limitType}:{limitTarget}
Type: Hash
Fields:
  - id: 配置ID
  - ruleName: 规则名称
  - limitType: 限流类型
  - limitTarget: 限流目标
  - limitCount: 限流阈值
  - timeWindow: 时间窗口
  - enabled: 是否启用
  - strategy: 限流策略
```

**示例：**
```
rate_limit_config:GLOBAL:GLOBAL
rate_limit_config:SERVICE:user-service
rate_limit_config:INTERFACE:user-service:/api/login
rate_limit_config:IP:192.168.1.100
```

### 2. 限流计数器

#### 令牌桶算法
```
Key: rate_limit:{key}
Type: String
Value: 当前计数
TTL: 1秒
```

#### 滑动窗口算法
```
Key: rate_limit:{key}
Type: Sorted Set
Score: 时间戳（毫秒）
Member: 请求唯一标识
TTL: timeWindow + 1秒
```

## Lua脚本实现

### 令牌桶算法脚本

```lua
local key = KEYS[1]
local limit = tonumber(ARGV[1])
local current = tonumber(redis.call('get', key) or '0')

if current < limit then
    redis.call('incr', key)
    if current == 0 then
        redis.call('expire', key, 1)
    end
    return 1
else
    return 0
end
```

**执行逻辑：**
1. 获取当前计数
2. 如果小于限流阈值，计数+1并返回1（允许通过）
3. 如果达到限流阈值，返回0（拒绝请求）
4. 首次计数时设置1秒过期时间

### 滑动窗口算法脚本

```lua
local key = KEYS[1]
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local current = tonumber(ARGV[3])
local expire_time = current - window * 1000

-- 删除过期数据
redis.call('zremrangebyscore', key, 0, expire_time)

-- 统计当前窗口内的请求数
local count = redis.call('zcard', key)

if count < limit then
    redis.call('zadd', key, current, current)
    redis.call('expire', key, window + 1)
    return 1
else
    return 0
end
```

**执行逻辑：**
1. 删除时间窗口外的过期数据
2. 统计当前窗口内的请求数
3. 如果小于限流阈值，添加当前请求并返回1
4. 如果达到限流阈值，返回0

## 配置示例

### 全局限流配置

```json
{
  "ruleName": "全局限流",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 10000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

### 服务级限流配置

```json
{
  "ruleName": "用户服务限流",
  "limitType": "SERVICE",
  "limitTarget": "user-service",
  "limitCount": 1000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

### 接口级限流配置

```json
{
  "ruleName": "登录接口限流",
  "limitType": "INTERFACE",
  "limitTarget": "user-service:/api/login",
  "limitCount": 100,
  "timeWindow": 1,
  "status": 1,
  "strategy": "SLIDING_WINDOW"
}
```

### IP级限流配置

```json
{
  "ruleName": "IP限流",
  "limitType": "IP",
  "limitTarget": "192.168.1.100",
  "limitCount": 50,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

## 性能优化

### 1. 本地限流器缓存

```java
private final Map<String, RateLimiter> localLimiters = new ConcurrentHashMap<>();
```

- 使用ConcurrentHashMap缓存本地限流器
- 避免重复创建RateLimiter对象
- 配置更新时自动清除缓存

### 2. 配置缓存

```java
private final Map<String, RateLimitConfig> configCache = new ConcurrentHashMap<>();
```

- 缓存限流配置，避免频繁查询Redis
- 支持配置热更新

### 3. 本地限流器容量设置

```java
double permitsPerSecond = config.getLimitCount() * 1.2 / config.getTimeWindow();
```

- 本地限流器设置为配置值的1.2倍
- 留有余量，避免过度拦截
- 保护Redis不被打垮

### 4. 异常降级

```java
try {
    // Redis分布式限流
} catch (Exception e) {
    log.error("分布式限流异常，降级为本地限流", e);
    return tryAcquireLocal(key, config);
}
```

- Redis异常时自动降级为本地限流
- 保证服务可用性

## 监控指标

### 建议监控的指标

1. **限流拦截率**
   - 本地限流拦截数
   - Redis限流拦截数
   - 总拦截率

2. **限流器性能**
   - 限流检查耗时
   - Redis脚本执行耗时
   - 本地限流器命中率

3. **配置更新**
   - 配置更新次数
   - 配置加载失败次数

4. **异常情况**
   - Redis连接异常次数
   - 降级次数

## 最佳实践

### 1. 限流阈值设置

- **全局限流**：设置为集群总容量的80%
- **服务级限流**：根据后端服务能力设置
- **接口级限流**：根据接口复杂度和重要性设置
- **IP级限流**：防止恶意攻击，设置较低阈值

### 2. 限流策略选择

- **令牌桶**：适用于允许突发流量的场景
- **滑动窗口**：适用于需要精确控制的场景

### 3. 配置更新

- 使用网关中心的管理接口进行配置
- 配置更新后自动推送到所有网关节点
- 支持灰度发布，先在部分节点测试

### 4. 异常处理

- 限流器异常时降级为本地限流
- 记录详细的错误日志
- 设置告警，及时发现问题

## 故障排查

### 1. 限流不生效

**可能原因：**
- 配置未启用（status=0）
- 配置未同步到Redis
- 限流器未正确初始化

**排查步骤：**
1. 检查数据库配置状态
2. 检查Redis中的配置数据
3. 查看网关日志，确认配置是否加载

### 2. 误拦截正常请求

**可能原因：**
- 限流阈值设置过低
- 多个限流规则叠加
- 本地限流器设置不合理

**排查步骤：**
1. 检查限流配置的阈值
2. 查看限流日志，确认拦截原因
3. 调整限流阈值或策略

### 3. Redis压力过大

**可能原因：**
- 本地限流器未生效
- 限流请求过多
- Lua脚本执行效率低

**解决方案：**
1. 检查本地限流器配置
2. 增加本地限流器的拦截比例
3. 优化Lua脚本

## 扩展性

### 1. 自定义限流策略

可以扩展新的限流算法，只需：
1. 在`DistributedRateLimiter`中添加新的Lua脚本
2. 在`tryAcquireDistributed`方法中添加新的策略分支
3. 更新配置枚举

### 2. 自定义限流维度

可以添加新的限流维度，只需：
1. 在`RateLimitPreHandler`中添加新的检查方法
2. 更新限流类型枚举
3. 在网关中心添加对应的配置管理

### 3. 集成监控系统

可以集成Prometheus、Grafana等监控系统：
1. 添加Metrics收集
2. 暴露监控端点
3. 配置告警规则

## 总结

分布式限流器通过多级限流架构，实现了高性能、高可用的限流功能：

- ✅ **高性能**：本地限流器承担大部分流量，保护Redis
- ✅ **高可用**：异常降级，保证服务可用性
- ✅ **灵活配置**：支持四级限流粒度和两种限流算法
- ✅ **实时更新**：配置变更实时推送到所有网关节点
- ✅ **易于扩展**：支持自定义限流策略和维度

该限流器能够处理超过Redis能力的高并发场景，是网关系统的重要保护机制。

