# 分布式限流配置管理 - 网关中心

## 概述

网关中心提供了完整的分布式限流配置管理功能，支持限流规则的创建、更新、删除、查询和实时推送。通过统一的管理界面，可以对所有网关节点的限流策略进行集中管理和动态调整。

## 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                        网关中心                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Controller   │→ │   Service    │→ │   Mapper     │      │
│  │ 接口层       │  │   业务层     │  │   数据层     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         ↓                  ↓                  ↓              │
│  ┌──────────────────────────────────────────────────┐      │
│  │              Redis 配置同步                       │      │
│  │  - 配置存储: rate_limit_config:*                 │      │
│  │  - 消息推送: rate-limit-config-update            │      │
│  └──────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↓ 配置推送
┌─────────────────────────────────────────────────────────────┐
│                    网关核心节点集群                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ Gateway1 │  │ Gateway2 │  │ Gateway3 │  │ Gateway4 │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
│       ↓              ↓              ↓              ↓        │
│  实时接收配置更新，动态调整限流策略                         │
└─────────────────────────────────────────────────────────────┘
```

## 数据模型

### 1. 数据库表结构

```sql
CREATE TABLE `gateway_rate_limit` (
    `id` BIGINT NOT NULL COMMENT '唯一id',
    `rule_name` VARCHAR(100) NOT NULL COMMENT '限流规则名称',
    `limit_type` VARCHAR(20) NOT NULL COMMENT '限流类型',
    `limit_target` VARCHAR(200) NOT NULL COMMENT '限流目标',
    `limit_count` INT NOT NULL COMMENT '限流阈值（每秒请求数）',
    `time_window` INT NOT NULL DEFAULT 1 COMMENT '时间窗口（秒）',
    `status` TINYINT NOT NULL DEFAULT 1 COMMENT '是否启用：0-禁用，1-启用',
    `strategy` VARCHAR(20) NOT NULL DEFAULT 'TOKEN_BUCKET' COMMENT '限流策略',
    `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`),
    KEY `idx_limit_type` (`limit_type`),
    KEY `idx_limit_target` (`limit_target`),
    KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='网关限流配置表';
```

### 2. 实体类

```java
@TableName(value = "gateway_rate_limit")
@Data
public class GatewayRateLimitDO {
    @TableId
    private Long id;                    // 唯一ID
    private String ruleName;            // 规则名称
    private String limitType;           // 限流类型
    private String limitTarget;         // 限流目标
    private Integer limitCount;         // 限流阈值
    private Integer timeWindow;         // 时间窗口
    private Integer status;             // 状态：0-禁用，1-启用
    private String strategy;            // 限流策略
    private LocalDateTime createTime;   // 创建时间
    private LocalDateTime updateTime;   // 更新时间
}
```

### 3. 请求VO

```java
@Data
public class RateLimitConfigReqVO {
    private Long id;                // 配置ID（更新时需要）
    private String ruleName;        // 规则名称
    private String limitType;       // 限流类型
    private String limitTarget;     // 限流目标
    private Integer limitCount;     // 限流阈值
    private Integer timeWindow;     // 时间窗口
    private Integer status;         // 状态
    private String strategy;        // 限流策略
}
```

## 核心组件

### 1. GatewayRateLimitMapper

数据访问层，使用MyBatis-Plus实现。

```java
@Mapper
public interface GatewayRateLimitMapper extends BaseMapper<GatewayRateLimitDO> {
}
```

**功能：**
- 继承MyBatis-Plus的BaseMapper
- 自动提供CRUD操作
- 支持复杂查询

### 2. GatewayRateLimitService

业务逻辑层，提供限流配置管理的核心功能。

```java
public interface GatewayRateLimitService {
    Long createRateLimitConfig(RateLimitConfigReqVO reqVO);
    Boolean updateRateLimitConfig(RateLimitConfigReqVO reqVO);
    Boolean deleteRateLimitConfig(Long id);
    Boolean updateStatus(Long id, Integer status);
    GatewayRateLimitDO getRateLimitConfig(Long id);
    PageResult<GatewayRateLimitDO> listRateLimitConfigs(Integer pageNum, Integer pageSize, String limitType);
    void refreshAllGatewayConfigs();
}
```

### 3. GatewayRateLimitServiceImpl

业务逻辑实现类，核心功能包括：

#### 创建限流配置

```java
@Transactional(rollbackFor = Exception.class)
public Long createRateLimitConfig(RateLimitConfigReqVO reqVO) {
    // 1. 构建实体对象
    GatewayRateLimitDO rateLimitDO = buildEntity(reqVO);

    // 2. 保存到数据库
    rateLimitMapper.insert(rateLimitDO);

    // 3. 同步到Redis
    syncConfigToRedis(rateLimitDO);

    // 4. 通知所有网关节点更新配置
    publishConfigUpdate(rateLimitDO);

    return rateLimitDO.getId();
}
```

#### 更新限流配置

```java
@Transactional(rollbackFor = Exception.class)
public Boolean updateRateLimitConfig(RateLimitConfigReqVO reqVO) {
    // 1. 查询原配置
    GatewayRateLimitDO rateLimitDO = rateLimitMapper.selectById(reqVO.getId());

    // 2. 更新字段
    updateFields(rateLimitDO, reqVO);

    // 3. 更新数据库
    rateLimitMapper.updateById(rateLimitDO);

    // 4. 同步到Redis
    syncConfigToRedis(rateLimitDO);

    // 5. 通知所有网关节点更新配置
    publishConfigUpdate(rateLimitDO);

    return true;
}
```

#### 删除限流配置

```java
@Transactional(rollbackFor = Exception.class)
public Boolean deleteRateLimitConfig(Long id) {
    // 1. 查询配置
    GatewayRateLimitDO rateLimitDO = rateLimitMapper.selectById(id);

    // 2. 从数据库删除
    rateLimitMapper.deleteById(id);

    // 3. 从Redis删除
    String redisKey = buildRedisKey(rateLimitDO);
    redisTemplate.delete(redisKey);

    // 4. 通知所有网关节点删除配置
    publishConfigUpdate(rateLimitDO);

    return true;
}
```

#### 同步配置到Redis

```java
private void syncConfigToRedis(GatewayRateLimitDO config) {
    String redisKey = buildRedisKey(config);

    Map<String, Object> configMap = new HashMap<>();
    configMap.put("id", config.getId());
    configMap.put("ruleName", config.getRuleName());
    configMap.put("limitType", config.getLimitType());
    configMap.put("limitTarget", config.getLimitTarget());
    configMap.put("limitCount", config.getLimitCount());
    configMap.put("timeWindow", config.getTimeWindow());
    configMap.put("enabled", config.getStatus() == 1);
    configMap.put("strategy", config.getStrategy());

    redisTemplate.opsForHash().putAll(redisKey, configMap);
}
```

**Redis Key格式：**
```
rate_limit_config:{limitType}:{limitTarget}
```

#### 发布配置更新消息

```java
private void publishConfigUpdate(GatewayRateLimitDO config) {
    Map<String, Object> message = new HashMap<>();
    message.put("id", config.getId());
    message.put("ruleName", config.getRuleName());
    message.put("limitType", config.getLimitType());
    message.put("limitTarget", config.getLimitTarget());
    message.put("limitCount", config.getLimitCount());
    message.put("timeWindow", config.getTimeWindow());
    message.put("enabled", config.getStatus() == 1);
    message.put("strategy", config.getStrategy());

    redisTemplate.convertAndSend("rate-limit-config-update",
        JSON.toJSONString(message));
}
```

**消息格式：**
- **频道**：`rate-limit-config-update`
- **内容**：JSON格式的配置信息
- **特殊消息**：`RELOAD_ALL` - 触发全量重载

### 4. GatewayRateLimitController

接口控制层，提供RESTful API。

```java
@RestController
@RequestMapping("/gateway-rate-limit")
public class GatewayRateLimitController {
    @Resource
    private GatewayRateLimitService rateLimitService;

    // API接口实现...
}
```

## API接口文档

### 1. 创建限流配置

**接口地址：** `POST /gateway-rate-limit/create`

**请求参数：**
```json
{
  "ruleName": "全局限流",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 10000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": 1234567890
}
```

### 2. 更新限流配置

**接口地址：** `PUT /gateway-rate-limit/update`

**请求参数：**
```json
{
  "id": 1234567890,
  "ruleName": "全局限流（已更新）",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 15000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": true
}
```

### 3. 删除限流配置

**接口地址：** `DELETE /gateway-rate-limit/delete/{id}`

**路径参数：**
- `id`: 配置ID

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": true
}
```

### 4. 启用/禁用限流配置

**接口地址：** `PUT /gateway-rate-limit/status/{id}/{status}`

**路径参数：**
- `id`: 配置ID
- `status`: 状态（0-禁用，1-启用）

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": true
}
```

### 5. 查询限流配置详情

**接口地址：** `GET /gateway-rate-limit/detail/{id}`

**路径参数：**
- `id`: 配置ID

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": {
    "id": 1234567890,
    "ruleName": "全局限流",
    "limitType": "GLOBAL",
    "limitTarget": "GLOBAL",
    "limitCount": 10000,
    "timeWindow": 1,
    "status": 1,
    "strategy": "TOKEN_BUCKET",
    "createTime": "2025-11-12 10:00:00",
    "updateTime": "2025-11-12 10:00:00"
  }
}
```

### 6. 分页查询限流配置列表

**接口地址：** `GET /gateway-rate-limit/list`

**请求参数：**
- `pageNum`: 页码（默认1）
- `pageSize`: 每页大小（默认10）
- `limitType`: 限流类型（可选）

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": {
    "list": [
      {
        "id": 1,
        "ruleName": "全局限流",
        "limitType": "GLOBAL",
        "limitTarget": "GLOBAL",
        "limitCount": 10000,
        "timeWindow": 1,
        "status": 1,
        "strategy": "TOKEN_BUCKET",
        "createTime": "2025-11-12 10:00:00",
        "updateTime": "2025-11-12 10:00:00"
      }
    ],
    "total": 10,
    "pageNum": 1,
    "pageSize": 10
  }
}
```

### 7. 刷新所有网关节点配置

**接口地址：** `POST /gateway-rate-limit/refresh`

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": null
}
```

## 配置推送机制

### 1. 推送流程

```
配置变更 → 保存数据库 → 同步Redis → 发布消息 → 网关节点接收 → 更新本地配置
```

### 2. 消息格式

#### 单个配置更新
```json
{
  "id": 1234567890,
  "ruleName": "全局限流",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 10000,
  "timeWindow": 1,
  "enabled": true,
  "strategy": "TOKEN_BUCKET"
}
```

#### 全量重载
```
RELOAD_ALL
```

### 3. 网关节点处理

网关节点通过`RateLimitConfigListener`监听配置更新：

```java
@Override
public void onMessage(Message message, byte[] pattern) {
    String body = new String(message.getBody());

    if ("RELOAD_ALL".equals(body)) {
        // 重新加载所有配置
        loadAllRateLimitConfigs();
    } else {
        // 更新单个配置
        RateLimitConfig config = JSON.parseObject(body, RateLimitConfig.class);
        rateLimiter.updateConfig(buildConfigKey(config), config);
    }
}
```

## 使用场景

### 场景1：全局限流保护

**需求：** 保护网关集群，限制总QPS为10000

**配置：**
```json
{
  "ruleName": "全局限流",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 10000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

**效果：** 所有请求都会经过全局限流检查，超过10000 QPS的请求会被拒绝

### 场景2：服务级限流

**需求：** 保护用户服务，限制QPS为1000

**配置：**
```json
{
  "ruleName": "用户服务限流",
  "limitType": "SERVICE",
  "limitTarget": "user-service",
  "limitCount": 1000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

**效果：** 所有访问user-service的请求都会经过服务级限流检查

### 场景3：接口级限流

**需求：** 保护登录接口，限制QPS为100

**配置：**
```json
{
  "ruleName": "登录接口限流",
  "limitType": "INTERFACE",
  "limitTarget": "user-service:/api/login",
  "limitCount": 100,
  "timeWindow": 1,
  "status": 1,
  "strategy": "SLIDING_WINDOW"
}
```

**效果：** 登录接口的请求会经过接口级限流检查，使用滑动窗口算法精确控制

### 场景4：IP级限流防攻击

**需求：** 防止恶意IP攻击，限制单个IP的QPS为50

**配置：**
```json
{
  "ruleName": "IP限流",
  "limitType": "IP",
  "limitTarget": "192.168.1.100",
  "limitCount": 50,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

**效果：** 来自192.168.1.100的请求会经过IP级限流检查

### 场景5：动态调整限流阈值

**需求：** 根据系统负载动态调整限流阈值

**操作步骤：**
1. 监控系统负载
2. 调用更新接口调整limitCount
3. 配置自动推送到所有网关节点
4. 实时生效，无需重启

## 最佳实践

### 1. 限流规则设计

#### 分层限流策略
```
全局限流（10000 QPS）
  ↓
服务级限流（1000 QPS）
  ↓
接口级限流（100 QPS）
  ↓
IP级限流（50 QPS）
```

**原则：**
- 从粗到细，层层防护
- 上层限流保护整体，下层限流保护细节
- 避免限流规则冲突

#### 限流阈值计算

```
限流阈值 = 系统容量 × 安全系数

其中：
- 系统容量：通过压测得出
- 安全系数：通常为0.7-0.8
```

**示例：**
- 系统容量：15000 QPS
- 安全系数：0.8
- 限流阈值：15000 × 0.8 = 12000 QPS

### 2. 限流策略选择

| 场景 | 推荐策略 | 原因 |
|-----|---------|------|
| 全局限流 | TOKEN_BUCKET | 允许突发流量，提高资源利用率 |
| 服务级限流 | TOKEN_BUCKET | 保护后端服务，允许短时突发 |
| 接口级限流 | SLIDING_WINDOW | 精确控制，防止接口被打垮 |
| IP级限流 | TOKEN_BUCKET | 防止恶意攻击，允许正常突发 |

### 3. 配置管理流程

#### 新增限流规则
```
1. 评估需求 → 2. 设计规则 → 3. 测试验证 → 4. 灰度发布 → 5. 全量上线
```

#### 更新限流规则
```
1. 监控告警 → 2. 分析原因 → 3. 调整阈值 → 4. 观察效果 → 5. 持续优化
```

#### 删除限流规则
```
1. 确认影响 → 2. 备份配置 → 3. 禁用规则 → 4. 观察一段时间 → 5. 删除规则
```
