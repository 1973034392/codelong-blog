# 分布式限流配置管理 - 网关中心

## 概述

网关中心提供了完整的分布式限流配置管理功能，支持限流规则的创建、更新、删除、查询和实时推送。通过统一的管理界面，可以对所有网关节点的限流策略进行集中管理和动态调整。

## 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                        网关中心                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ Controller   │→ │   Service    │→ │   Mapper     │      │
│  │ 接口层       │  │   业务层     │  │   数据层     │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
│         ↓                  ↓                  ↓              │
│  ┌──────────────────────────────────────────────────┐      │
│  │              Redis 配置同步                       │      │
│  │  - 配置存储: rate_limit_config:*                 │      │
│  │  - 消息推送: rate-limit-config-update            │      │
│  └──────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↓ 配置推送
┌─────────────────────────────────────────────────────────────┐
│                    网关核心节点集群                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ Gateway1 │  │ Gateway2 │  │ Gateway3 │  │ Gateway4 │   │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘   │
│       ↓              ↓              ↓              ↓        │
│  实时接收配置更新，动态调整限流策略                         │
└─────────────────────────────────────────────────────────────┘
```

## 数据模型

### 1. 数据库表结构

```sql
CREATE TABLE `gateway_rate_limit` (
    `id` BIGINT NOT NULL COMMENT '唯一id',
    `rule_name` VARCHAR(100) NOT NULL COMMENT '限流规则名称',
    `limit_type` VARCHAR(20) NOT NULL COMMENT '限流类型',
    `limit_target` VARCHAR(200) NOT NULL COMMENT '限流目标',
    `limit_count` INT NOT NULL COMMENT '限流阈值（每秒请求数）',
    `time_window` INT NOT NULL DEFAULT 1 COMMENT '时间窗口（秒）',
    `status` TINYINT NOT NULL DEFAULT 1 COMMENT '是否启用：0-禁用，1-启用',
    `strategy` VARCHAR(20) NOT NULL DEFAULT 'TOKEN_BUCKET' COMMENT '限流策略',
    `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`),
    KEY `idx_limit_type` (`limit_type`),
    KEY `idx_limit_target` (`limit_target`),
    KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='网关限流配置表';
```

### 2. 实体类

```java
@TableName(value = "gateway_rate_limit")
@Data
public class GatewayRateLimitDO {
    @TableId
    private Long id;                    // 唯一ID
    private String ruleName;            // 规则名称
    private String limitType;           // 限流类型
    private String limitTarget;         // 限流目标
    private Integer limitCount;         // 限流阈值
    private Integer timeWindow;         // 时间窗口
    private Integer status;             // 状态：0-禁用，1-启用
    private String strategy;            // 限流策略
    private LocalDateTime createTime;   // 创建时间
    private LocalDateTime updateTime;   // 更新时间
}
```

### 3. 请求VO

```java
@Data
public class RateLimitConfigReqVO {
    private Long id;                // 配置ID（更新时需要）
    private String ruleName;        // 规则名称
    private String limitType;       // 限流类型
    private String limitTarget;     // 限流目标
    private Integer limitCount;     // 限流阈值
    private Integer timeWindow;     // 时间窗口
    private Integer status;         // 状态
    private String strategy;        // 限流策略
}
```

## 核心组件

### 1. GatewayRateLimitMapper

数据访问层，使用MyBatis-Plus实现。

```java
@Mapper
public interface GatewayRateLimitMapper extends BaseMapper<GatewayRateLimitDO> {
}
```

**功能：**
- 继承MyBatis-Plus的BaseMapper
- 自动提供CRUD操作
- 支持复杂查询

### 2. GatewayRateLimitService

业务逻辑层，提供限流配置管理的核心功能。

```java
public interface GatewayRateLimitService {
    Long createRateLimitConfig(RateLimitConfigReqVO reqVO);
    Boolean updateRateLimitConfig(RateLimitConfigReqVO reqVO);
    Boolean deleteRateLimitConfig(Long id);
    Boolean updateStatus(Long id, Integer status);
    GatewayRateLimitDO getRateLimitConfig(Long id);
    PageResult<GatewayRateLimitDO> listRateLimitConfigs(Integer pageNum, Integer pageSize, String limitType);
    void refreshAllGatewayConfigs();
}
```

### 3. GatewayRateLimitServiceImpl

业务逻辑实现类，核心功能包括：

#### 创建限流配置

```java
@Transactional(rollbackFor = Exception.class)
public Long createRateLimitConfig(RateLimitConfigReqVO reqVO) {
    // 1. 构建实体对象
    GatewayRateLimitDO rateLimitDO = buildEntity(reqVO);

    // 2. 保存到数据库
    rateLimitMapper.insert(rateLimitDO);

    // 3. 同步到Redis
    syncConfigToRedis(rateLimitDO);

    // 4. 通知所有网关节点更新配置
    publishConfigUpdate(rateLimitDO);

    return rateLimitDO.getId();
}
```

#### 更新限流配置

```java
@Transactional(rollbackFor = Exception.class)
public Boolean updateRateLimitConfig(RateLimitConfigReqVO reqVO) {
    // 1. 查询原配置
    GatewayRateLimitDO rateLimitDO = rateLimitMapper.selectById(reqVO.getId());

    // 2. 更新字段
    updateFields(rateLimitDO, reqVO);

    // 3. 更新数据库
    rateLimitMapper.updateById(rateLimitDO);

    // 4. 同步到Redis
    syncConfigToRedis(rateLimitDO);

    // 5. 通知所有网关节点更新配置
    publishConfigUpdate(rateLimitDO);

    return true;
}
```

#### 删除限流配置

```java
@Transactional(rollbackFor = Exception.class)
public Boolean deleteRateLimitConfig(Long id) {
    // 1. 查询配置
    GatewayRateLimitDO rateLimitDO = rateLimitMapper.selectById(id);

    // 2. 从数据库删除
    rateLimitMapper.deleteById(id);

    // 3. 从Redis删除
    String redisKey = buildRedisKey(rateLimitDO);
    redisTemplate.delete(redisKey);

    // 4. 通知所有网关节点删除配置
    publishConfigUpdate(rateLimitDO);

    return true;
}
```

#### 同步配置到Redis

```java
private void syncConfigToRedis(GatewayRateLimitDO config) {
    String redisKey = buildRedisKey(config);

    Map<String, Object> configMap = new HashMap<>();
    configMap.put("id", config.getId());
    configMap.put("ruleName", config.getRuleName());
    configMap.put("limitType", config.getLimitType());
    configMap.put("limitTarget", config.getLimitTarget());
    configMap.put("limitCount", config.getLimitCount());
    configMap.put("timeWindow", config.getTimeWindow());
    configMap.put("enabled", config.getStatus() == 1);
    configMap.put("strategy", config.getStrategy());

    redisTemplate.opsForHash().putAll(redisKey, configMap);
}
```

**Redis Key格式：**
```
rate_limit_config:{limitType}:{limitTarget}
```

#### 发布配置更新消息

```java
private void publishConfigUpdate(GatewayRateLimitDO config) {
    Map<String, Object> message = new HashMap<>();
    message.put("id", config.getId());
    message.put("ruleName", config.getRuleName());
    message.put("limitType", config.getLimitType());
    message.put("limitTarget", config.getLimitTarget());
    message.put("limitCount", config.getLimitCount());
    message.put("timeWindow", config.getTimeWindow());
    message.put("enabled", config.getStatus() == 1);
    message.put("strategy", config.getStrategy());

    redisTemplate.convertAndSend("rate-limit-config-update",
        JSON.toJSONString(message));
}
```

**消息格式：**
- **频道**：`rate-limit-config-update`
- **内容**：JSON格式的配置信息
- **特殊消息**：`RELOAD_ALL` - 触发全量重载

### 4. GatewayRateLimitController

接口控制层，提供RESTful API。

```java
@RestController
@RequestMapping("/gateway-rate-limit")
public class GatewayRateLimitController {
    @Resource
    private GatewayRateLimitService rateLimitService;

    // API接口实现...
}
```

## API接口文档

### 1. 创建限流配置

**接口地址：** `POST /gateway-rate-limit/create`

**请求参数：**
```json
{
  "ruleName": "全局限流",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 10000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": 1234567890
}
```

### 2. 更新限流配置

**接口地址：** `PUT /gateway-rate-limit/update`

**请求参数：**
```json
{
  "id": 1234567890,
  "ruleName": "全局限流（已更新）",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 15000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": true
}
```

### 3. 删除限流配置

**接口地址：** `DELETE /gateway-rate-limit/delete/{id}`

**路径参数：**
- `id`: 配置ID

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": true
}
```

### 4. 启用/禁用限流配置

**接口地址：** `PUT /gateway-rate-limit/status/{id}/{status}`

**路径参数：**
- `id`: 配置ID
- `status`: 状态（0-禁用，1-启用）

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": true
}
```

### 5. 查询限流配置详情

**接口地址：** `GET /gateway-rate-limit/detail/{id}`

**路径参数：**
- `id`: 配置ID

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": {
    "id": 1234567890,
    "ruleName": "全局限流",
    "limitType": "GLOBAL",
    "limitTarget": "GLOBAL",
    "limitCount": 10000,
    "timeWindow": 1,
    "status": 1,
    "strategy": "TOKEN_BUCKET",
    "createTime": "2025-11-12 10:00:00",
    "updateTime": "2025-11-12 10:00:00"
  }
}
```

### 6. 分页查询限流配置列表

**接口地址：** `GET /gateway-rate-limit/list`

**请求参数：**
- `pageNum`: 页码（默认1）
- `pageSize`: 每页大小（默认10）
- `limitType`: 限流类型（可选）

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": {
    "list": [
      {
        "id": 1,
        "ruleName": "全局限流",
        "limitType": "GLOBAL",
        "limitTarget": "GLOBAL",
        "limitCount": 10000,
        "timeWindow": 1,
        "status": 1,
        "strategy": "TOKEN_BUCKET",
        "createTime": "2025-11-12 10:00:00",
        "updateTime": "2025-11-12 10:00:00"
      }
    ],
    "total": 10,
    "pageNum": 1,
    "pageSize": 10
  }
}
```

### 7. 刷新所有网关节点配置

**接口地址：** `POST /gateway-rate-limit/refresh`

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "data": null
}
```

## 配置推送机制

### 1. 推送流程

```
配置变更 → 保存数据库 → 同步Redis → 发布消息 → 网关节点接收 → 更新本地配置
```

### 2. 消息格式

#### 单个配置更新
```json
{
  "id": 1234567890,
  "ruleName": "全局限流",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 10000,
  "timeWindow": 1,
  "enabled": true,
  "strategy": "TOKEN_BUCKET"
}
```

#### 全量重载
```
RELOAD_ALL
```

### 3. 网关节点处理

网关节点通过`RateLimitConfigListener`监听配置更新：

```java
@Override
public void onMessage(Message message, byte[] pattern) {
    String body = new String(message.getBody());

    if ("RELOAD_ALL".equals(body)) {
        // 重新加载所有配置
        loadAllRateLimitConfigs();
    } else {
        // 更新单个配置
        RateLimitConfig config = JSON.parseObject(body, RateLimitConfig.class);
        rateLimiter.updateConfig(buildConfigKey(config), config);
    }
}
```

## 使用场景

### 场景1：全局限流保护

**需求：** 保护网关集群，限制总QPS为10000

**配置：**
```json
{
  "ruleName": "全局限流",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 10000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

**效果：** 所有请求都会经过全局限流检查，超过10000 QPS的请求会被拒绝

### 场景2：服务级限流

**需求：** 保护用户服务，限制QPS为1000

**配置：**
```json
{
  "ruleName": "用户服务限流",
  "limitType": "SERVICE",
  "limitTarget": "user-service",
  "limitCount": 1000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

**效果：** 所有访问user-service的请求都会经过服务级限流检查

### 场景3：接口级限流

**需求：** 保护登录接口，限制QPS为100

**配置：**
```json
{
  "ruleName": "登录接口限流",
  "limitType": "INTERFACE",
  "limitTarget": "user-service:/api/login",
  "limitCount": 100,
  "timeWindow": 1,
  "status": 1,
  "strategy": "SLIDING_WINDOW"
}
```

**效果：** 登录接口的请求会经过接口级限流检查，使用滑动窗口算法精确控制

### 场景4：IP级限流防攻击

**需求：** 防止恶意IP攻击，限制单个IP的QPS为50

**配置：**
```json
{
  "ruleName": "IP限流",
  "limitType": "IP",
  "limitTarget": "192.168.1.100",
  "limitCount": 50,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET"
}
```

**效果：** 来自192.168.1.100的请求会经过IP级限流检查

### 场景5：动态调整限流阈值

**需求：** 根据系统负载动态调整限流阈值

**操作步骤：**
1. 监控系统负载
2. 调用更新接口调整limitCount
3. 配置自动推送到所有网关节点
4. 实时生效，无需重启

## 最佳实践

### 1. 限流规则设计

#### 分层限流策略
```
全局限流（10000 QPS）
  ↓
服务级限流（1000 QPS）
  ↓
接口级限流（100 QPS）
  ↓
IP级限流（50 QPS）
```

**原则：**
- 从粗到细，层层防护
- 上层限流保护整体，下层限流保护细节
- 避免限流规则冲突

#### 限流阈值计算

```
限流阈值 = 系统容量 × 安全系数

其中：
- 系统容量：通过压测得出
- 安全系数：通常为0.7-0.8
```

**示例：**
- 系统容量：15000 QPS
- 安全系数：0.8
- 限流阈值：15000 × 0.8 = 12000 QPS

### 2. 限流策略选择

| 场景 | 推荐策略 | 原因 |
|-----|---------|------|
| 全局限流 | TOKEN_BUCKET | 允许突发流量，提高资源利用率 |
| 服务级限流 | TOKEN_BUCKET | 保护后端服务，允许短时突发 |
| 接口级限流 | SLIDING_WINDOW | 精确控制，防止接口被打垮 |
| IP级限流 | TOKEN_BUCKET | 防止恶意攻击，允许正常突发 |

### 3. 配置管理流程

#### 新增限流规则
```
1. 评估需求 → 2. 设计规则 → 3. 测试验证 → 4. 灰度发布 → 5. 全量上线
```

#### 更新限流规则
```
1. 监控告警 → 2. 分析原因 → 3. 调整阈值 → 4. 观察效果 → 5. 持续优化
```

#### 删除限流规则
```
1. 确认影响 → 2. 备份配置 → 3. 禁用规则 → 4. 观察一段时间 → 5. 删除规则
```

### 4. 监控和告警

#### 监控指标
- 限流拦截率
- 限流规则数量
- 配置更新频率
- Redis同步延迟

#### 告警规则
- 限流拦截率 > 10%：可能需要扩容
- 限流拦截率 > 50%：紧急扩容
- 配置同步失败：立即处理
- Redis连接异常：立即处理

## 故障处理

### 1. 配置未生效

**现象：** 更新配置后，网关节点未生效

**排查步骤：**
1. 检查数据库配置是否更新成功
2. 检查Redis中的配置是否同步
3. 检查Redis消息是否发布成功
4. 检查网关节点是否接收到消息
5. 查看网关节点日志

**解决方案：**
- 调用刷新接口：`POST /gateway-rate-limit/refresh`
- 重启网关节点（最后手段）

### 2. 配置冲突

**现象：** 多个限流规则同时生效，导致误拦截

**排查步骤：**
1. 查询所有启用的限流规则
2. 分析规则之间的关系
3. 确认是否存在冲突

**解决方案：**
- 调整限流阈值
- 禁用冲突的规则
- 重新设计限流策略

### 3. Redis同步失败

**现象：** 配置保存成功，但Redis同步失败

**排查步骤：**
1. 检查Redis连接状态
2. 检查Redis内存使用情况
3. 查看错误日志

**解决方案：**
- 修复Redis连接问题
- 清理Redis内存
- 调用刷新接口重新同步

## 安全考虑

### 1. 接口鉴权

建议为限流配置管理接口添加鉴权：
```java
@PreAuthorize("hasRole('ADMIN')")
public Result<Long> createRateLimitConfig(RateLimitConfigReqVO reqVO)
```

### 2. 操作审计

记录所有配置变更操作：
- 操作人
- 操作时间
- 操作内容
- 操作结果

### 3. 配置备份

定期备份限流配置：
- 数据库定期备份
- Redis配置导出
- 配置变更历史记录

## 扩展功能

### 1. 配置模板

提供常用的限流配置模板：
- 全局限流模板
- 服务级限流模板
- 接口级限流模板
- IP限流模板

### 2. 配置导入导出

支持批量导入导出限流配置：
- JSON格式导出
- Excel格式导出
- 批量导入

### 3. 配置版本管理

记录配置变更历史：
- 版本号
- 变更内容
- 变更时间
- 支持回滚

### 4. 可视化监控

提供限流监控大屏：
- 实时限流拦截率
- 各维度限流统计
- 限流趋势图表
- 告警信息展示

## 总结

网关中心的分布式限流配置管理系统提供了完整的限流规则管理功能：

- ✅ **集中管理**：统一管理所有网关节点的限流配置
- ✅ **实时生效**：配置变更实时推送，无需重启
- ✅ **灵活配置**：支持四级限流粒度和两种限流算法
- ✅ **易于使用**：提供RESTful API和管理界面
- ✅ **高可用**：配置持久化到数据库和Redis
- ✅ **可扩展**：支持自定义限流策略和监控

通过网关中心的限流配置管理，可以轻松实现对整个网关集群的限流策略管理，保护后端服务不被打垮。

