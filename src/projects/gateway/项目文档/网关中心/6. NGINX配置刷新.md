# NGINX配置刷新

## 添加必要依赖

```xml
<dependencies>
    <dependency>
        <groupId>com.jcraft</groupId>
        <artifactId>jsch</artifactId>
        <version>0.1.55</version>
    </dependency>
    <dependency>
        <groupId>org.yaml</groupId>
        <artifactId>snakeyaml</artifactId>
        <version>1.33</version>
    </dependency>
</dependencies>
```

## 配置类定义

```yaml
nginx:
  config:
    remote:
      host: nginx-server-hostname
      port: 22
      username: your-ssh-user
      password: your-ssh-password
      config-path: /etc/nginx/conf.d/gateway.conf
      reload-command: "sudo nginx -s reload"
```

## 配置属性类

```java
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Data
@Component
@ConfigurationProperties(prefix = "nginx.config")
public class NginxConfigProperties {
    private Remote remote = new Remote();

    public static class Remote {
        private String host;
        private int port = 22;
        private String username;
        private String password;
        private String configPath;
        private String reloadCommand;

    }
}
```

## 网关实例类

```java
@Data
public class GatewayInstance {
    private final String address;
    private int weight;

    public GatewayInstance(String address, int weight) {
        this.address = address;
        this.weight = weight;
    }
}
```

## 核心组件实现

```java
import com.jcraft.jsch.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.ByteArrayInputStream;
import java.io.OutputStream;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.ReentrantLock;

@Component
public class NginxConfigManager {
    
    // 使用线程安全的集合存储实例
    private final Map<String, GatewayInstance> instances = new ConcurrentHashMap<>();
    private final ReentrantLock refreshLock = new ReentrantLock();
    
    private final NginxConfigProperties properties;
    
    @Autowired
    public NginxConfigManager(NginxConfigProperties properties) {
        this.properties = properties;
    }
    
    @PostConstruct
    public void init() {
        // TODO可添加初始化逻辑
    }
    
    @PreDestroy
    public void cleanup() {
        // TODO清理资源
    }
    
    /**
     * 添加实例
     * @param address 网关地址（host:port）
     * @param weight 权重
     */
    public void addInstance(String address, int weight) {
        GatewayInstance instance = new GatewayInstance(address, weight);
        instances.put(address, instance);
        refreshNginxConfig();
    }
    
    /**
     * 删除实例
     * @param address 网关地址（host:port）
     */
    public void removeInstance(String address) {
        if (instances.remove(address) != null) {
            refreshNginxConfig();
        }
    }
    
    /**
     * 更新实例权重
     * @param address 网关地址
     * @param newWeight 新权重
     */
    public void updateInstanceWeight(String address, int newWeight) {
        GatewayInstance instance = instances.get(address);
        if (instance != null && instance.getWeight() != newWeight) {
            instance.setWeight(newWeight);
            refreshNginxConfig();
        }
    }
    
    /**
     * 刷新NGINX配置
     */
    public void refreshNginxConfig() {
        if (!refreshLock.tryLock()) {
            // 防止并发刷新
            return;
        }
        
        try {
            String config = generateNginxConfig();
            uploadConfigToRemote(config);
            reloadNginxOnRemote();
        } finally {
            refreshLock.unlock();
        }
    }
    
    /**
     * 生成NGINX负载均衡配置
     */
    private String generateNginxConfig() {
        StringBuilder builder = new StringBuilder();
        builder.append("# Auto-generated by GatewayManager\n");
        builder.append("upstream gateway_backend {\n");
        
        // 添加健康检查策略（可选）
        builder.append("    least_conn;  # 最少连接策略\n");
        builder.append("    keepalive 32;\n");
        
        // 添加实例配置
        for (GatewayInstance instance : instances.values()) {
            String[] parts = instance.getAddress().split(":");
            String server = parts[0];
            String port = parts.length > 1 ? parts[1] : "80";
            
            builder.append(String.format(
                "    server %s:%s weight=%d max_fails=3 fail_timeout=30s;\n",
                server, port, instance.getWeight()
            ));
        }
        
        builder.append("}\n\n");
        
        // 代理配置
        builder.append("server {\n");
        builder.append("    listen 80;\n");
        builder.append("    location / {\n");
        builder.append("        proxy_pass http://gateway_backend;\n");
        builder.append("        proxy_set_header Host $host;\n");
        builder.append("        proxy_set_header X-Real-IP $remote_addr;\n");
        builder.append("    }\n");
        builder.append("}\n");
        
        return builder.toString();
    }
    
    /**
     * 上传配置到远程服务器
     * @param configContent 配置内容
     */
    private void uploadConfigToRemote(String configContent) {
        NginxConfigProperties.Remote remote = properties.getRemote();
        Session session = null;
        ChannelSftp channel = null;
        
        try {
            JSch jsch = new JSch();
            session = jsch.getSession(remote.getUsername(), remote.getHost(), remote.getPort());
            session.setPassword(remote.getPassword());
            session.setConfig("StrictHostKeyChecking", "no");
            session.connect();
            
            channel = (ChannelSftp) session.openChannel("sftp");
            channel.connect();
            
            // 上传配置文件
            try (OutputStream out = channel.put(remote.getConfigPath())) {
                byte[] contentBytes = configContent.getBytes();
                out.write(contentBytes);
            }
            
        } catch (JSchException | SftpException | java.io.IOException e) {
            throw new RuntimeException("NGINX配置上传失败: " + e.getMessage(), e);
        } finally {
            if (channel != null) channel.disconnect();
            if (session != null) session.disconnect();
        }
    }
    
    /**
     * 远程重载NGINX
     */
    private void reloadNginxOnRemote() {
        NginxConfigProperties.Remote remote = properties.getRemote();
        Session session = null;
        ChannelExec channel = null;
        
        try {
            JSch jsch = new JSch();
            session = jsch.getSession(remote.getUsername(), remote.getHost(), remote.getPort());
            session.setPassword(remote.getPassword());
            session.setConfig("StrictHostKeyChecking", "no");
            session.connect();
            
            channel = (ChannelExec) session.openChannel("exec");
            channel.setCommand(remote.getReloadCommand());
            channel.connect();
            
            // 等待命令执行完成
            while (!channel.isClosed()) {
                Thread.sleep(500);
            }
            
            // 检查退出状态
            if (channel.getExitStatus() != 0) {
                throw new RuntimeException("NGINX重载命令执行失败，错误码: " + channel.getExitStatus());
            }
            
        } catch (JSchException | InterruptedException e) {
            throw new RuntimeException("NGINX重载失败: " + e.getMessage(), e);
        } finally {
            if (channel != null) channel.disconnect();
            if (session != null) session.disconnect();
        }
    }
}
```

## 使用示例

```java
// 添加实例
nginxConfigManager.addInstance("192.168.1.10:8080", 3);
nginxConfigManager.addInstance("192.168.1.11:8080", 2);

// 删除实例
nginxConfigManager.removeInstance("192.168.1.10:8080");

// 更新权重
nginxConfigManager.updateInstanceWeight("192.168.1.11:8080", 5);
```
