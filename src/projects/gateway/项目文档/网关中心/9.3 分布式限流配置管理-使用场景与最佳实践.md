# 分布式限流配置管理 - 使用场景与最佳实践

## 一、典型使用场景

### 7.1 场景1：全局限流保护

**需求：** 保护网关集群，限制总QPS为10000

**配置示例：**
```json
{
  "ruleName": "全局限流",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 10000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET",
  "mode": "DISTRIBUTED",
  "localBatchSize": 100,
  "localCapacityMultiplier": 1.0
}
```

**选择理由：**
- **令牌桶算法**：允许一定程度的突发流量，提高资源利用率
- **全局粒度**：保护整个网关集群，避免过载

**效果：**
- 所有请求都会经过全局限流检查
- 超过10000 QPS的请求会被拒绝
- 允许短时间的流量突发（令牌桶特性）

### 7.2 场景2：服务级限流

**需求：** 保护用户服务，限制QPS为1000

**配置示例：**
```json
{
  "ruleName": "用户服务限流",
  "limitType": "SERVICE",
  "limitTarget": "user-service",
  "limitCount": 1000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET",
  "mode": "LOCAL_DISTRIBUTED",
  "localBatchSize": 100,
  "localCapacityMultiplier": 1.0
}
```

**选择理由：**
- **令牌桶算法**：保护后端服务，允许短时突发
- **服务粒度**：针对特定服务限流，不影响其他服务

**效果：**
- 所有访问user-service的请求都会经过服务级限流检查
- 保护后端服务不被打垮
- 提升用户体验（允许突发）

### 7.3 场景3：接口级限流

**需求：** 保护登录接口，限制QPS为100，防止暴力破解

**配置示例：**
```json
{
  "ruleName": "登录接口限流",
  "limitType": "INTERFACE",
  "limitTarget": "user-service:/api/login",
  "limitCount": 100,
  "timeWindow": 1,
  "status": 1,
  "strategy": "SLIDING_WINDOW",
  "mode": "DISTRIBUTED",
  "localBatchSize": 100,
  "localCapacityMultiplier": 1.0
}
```

**选择理由：**
- **滑动窗口算法**：精确控制，防止暴力破解
- **接口粒度**：针对核心接口，严格限制

**效果：**
- 登录接口的请求会经过接口级限流检查
- 严格限制请求频率，防止暴力破解
- 不允许突发流量（滑动窗口特性）

### 7.4 场景4：IP级限流防攻击

**需求：** 防止恶意IP攻击，限制单个IP的QPS为50

**配置示例：**
```json
{
  "ruleName": "IP限流",
  "limitType": "IP",
  "limitTarget": "192.168.1.100",
  "limitCount": 50,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET",
  "mode": "LOCAL_DISTRIBUTED",
  "localBatchSize": 100,
  "localCapacityMultiplier": 1.0
}
```

**选择理由：**
- **令牌桶算法**：防止恶意攻击，允许正常用户的突发请求
- **IP粒度**：针对特定IP限流，不影响其他用户

**效果：**
- 来自192.168.1.100的请求会经过IP级限流检查
- 防止单个IP的恶意攻击
- 允许正常用户的突发请求

### 7.5 场景5：动态调整限流阈值

**需求：** 根据系统负载动态调整限流阈值

**操作步骤：**

1. **监控系统负载**
```
当前QPS：8000
系统CPU：60%
系统内存：70%
```

2. **调整限流阈值**
```bash
curl -X PUT http://gateway-center/gateway-rate-limit/update \
  -H "Content-Type: application/json" \
  -d '{
    "id": 1234567890,
    "ruleName": "全局限流",
    "limitType": "GLOBAL",
    "limitTarget": "GLOBAL",
    "limitCount": 12000,
    "timeWindow": 1,
    "status": 1,
    "strategy": "TOKEN_BUCKET",
    "mode": "DISTRIBUTED",
    "localBatchSize": 100,
    "localCapacityMultiplier": 1.0
  }'
```

3. **配置自动推送**
- 网关中心保存配置到数据库
- 同步配置到Redis
- 发布配置更新消息

4. **网关节点接收**
- 所有网关节点接收消息
- 更新本地限流器
- 配置实时生效

5. **验证效果**
```
新的限流阈值：12000 QPS
配置生效时间：< 1秒
无需重启网关节点
```

### 7.6 场景6：分层限流策略

**需求：** 对用户服务的登录接口实施分层限流

**配置组合：**

```json
// 1. 全局限流
{
  "ruleName": "全局限流",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 10000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET",
  "mode": "DISTRIBUTED",
  "localBatchSize": 100,
  "localCapacityMultiplier": 1.0
}

// 2. 服务级限流
{
  "ruleName": "用户服务限流",
  "limitType": "SERVICE",
  "limitTarget": "user-service",
  "limitCount": 2000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET",
  "mode": "LOCAL_DISTRIBUTED",
  "localBatchSize": 100,
  "localCapacityMultiplier": 1.0
}

// 3. 接口级限流
{
  "ruleName": "登录接口限流",
  "limitType": "INTERFACE",
  "limitTarget": "user-service:/api/login",
  "limitCount": 500,
  "timeWindow": 1,
  "status": 1,
  "strategy": "SLIDING_WINDOW",
  "mode": "DISTRIBUTED",
  "localBatchSize": 100,
  "localCapacityMultiplier": 1.0
}

// 4. IP级限流
{
  "ruleName": "IP限流",
  "limitType": "IP",
  "limitTarget": "192.168.1.100",
  "limitCount": 10,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET",
  "mode": "LOCAL_DISTRIBUTED",
  "localBatchSize": 100,
  "localCapacityMultiplier": 1.0
}
```

**限流检查顺序：**
```
请求 → 全局限流(10000) → 服务级限流(2000) → 接口级限流(500) → IP级限流(10) → 业务处理
```

**效果：**
- 层层防护，从粗到细
- 全局保护网关，服务保护后端，接口保护核心功能，IP防止攻击
- 不同粒度使用不同算法，灵活控制

### 7.7 场景7：本地+分布式混合模式（高性能限流）

**需求：** 在高并发场景下，减少 Redis 访问，提高限流性能

**配置示例：**
```json
{
  "ruleName": "全局限流（高性能模式）",
  "limitType": "GLOBAL",
  "limitTarget": "GLOBAL",
  "limitCount": 10000,
  "timeWindow": 1,
  "status": 1,
  "strategy": "TOKEN_BUCKET",
  "mode": "LOCAL_DISTRIBUTED",
  "localBatchSize": 100,
  "localCapacityMultiplier": 1.0
}
```

**参数说明：**
- `mode`: `LOCAL_DISTRIBUTED` - 启用本地+分布式混合模式
- `localBatchSize`: 100 - 每次从 Redis 批量获取 100 个令牌
- `localCapacityMultiplier`: 1.0 - 本地容量倍数（精确限流）

**工作原理：**
1. 网关节点维护本地令牌计数器
2. 请求到达时，先消费本地令牌
3. 本地令牌不足时，从 Redis 批量获取 100 个令牌
4. 减少 Redis 访问次数，提高性能

**性能对比：**
```
DISTRIBUTED 模式：
- 每个请求都访问 Redis
- Redis 压力大
- 延迟：~5ms

LOCAL_DISTRIBUTED 模式：
- 大部分请求消费本地令牌
- 只有 1/100 的请求访问 Redis
- 延迟：~0.1ms（本地）/ ~5ms（Redis）
- 性能提升：50-100 倍
```

**适用场景：**
- 高并发场景（QPS > 10000）
- 对延迟敏感的业务
- Redis 压力较大的情况
- 需要精确限流的场景

**注意事项：**
- 本地令牌计数器在网关节点重启时会重置
- 不同网关节点的本地令牌是独立的
- 总体限流精度由 Redis 侧保证
- 建议与全局限流配合使用

## 二、最佳实践

### 8.1 限流规则设计原则

#### 1. 分层限流策略

```
第一层：全局限流（保护网关整体）
  ↓
第二层：服务级限流（保护后端服务）
  ↓
第三层：接口级限流（保护核心接口）
  ↓
第四层：IP级限流（防止恶意攻击）
```

**原则：**
- 从粗到细，层层防护
- 上层限流保护整体，下层限流保护细节
- 避免限流规则冲突（下层阈值 < 上层阈值）

#### 2. 限流阈值计算

```
限流阈值 = 系统容量 × 安全系数

其中：
- 系统容量：通过压测得出
- 安全系数：通常为0.7-0.8
```

**示例：**
```
系统容量：15000 QPS（压测结果）
安全系数：0.8
限流阈值：15000 × 0.8 = 12000 QPS
```

**注意事项：**
- 预留20%-30%的余量，应对突发流量
- 定期压测，更新系统容量
- 根据实际情况调整安全系数

#### 3. 限流策略选择

| 场景 | 推荐策略 | 理由 |
|-----|---------|------|
| **全局限流** | 令牌桶 | 允许突发流量，提高资源利用率 |
| **服务级限流** | 令牌桶 | 保护后端服务，允许短时突发 |
| **接口级限流** | 滑动窗口 | 精确控制核心接口，防止接口被打垮 |
| **IP级限流** | 令牌桶 | 防止恶意攻击，允许正常用户的突发请求 |
| **登录接口** | 滑动窗口 | 防止暴力破解，严格限制尝试次数 |
| **支付接口** | 滑动窗口 | 保护资金安全，精确控制请求频率 |

#### 4. 限流模式选择

| 场景 | 推荐模式 | 理由 |
|-----|---------|------|
| **低并发场景** | DISTRIBUTED | 简单可靠，无需本地缓存 |
| **中等并发** | DISTRIBUTED | 性能足够，Redis 压力可控 |
| **高并发场景** | LOCAL_DISTRIBUTED | 减少 Redis 访问，性能提升 50-100 倍 |
| **对延迟敏感** | LOCAL_DISTRIBUTED | 本地令牌消费延迟 < 1ms |
| **Redis 压力大** | LOCAL_DISTRIBUTED | 减少 Redis 请求 99% |
| **需要精确限流** | DISTRIBUTED | 每个请求都经过 Redis 验证 |

**模式选择建议：**
- QPS < 1000：使用 DISTRIBUTED
- 1000 < QPS < 10000：根据 Redis 压力选择
- QPS > 10000：优先使用 LOCAL_DISTRIBUTED

### 8.2 配置管理流程

#### 1. 新增限流规则

```
1. 评估需求
   - 确定限流目标（全局/服务/接口/IP）
   - 确定限流阈值（通过压测）
   - 确定限流策略（令牌桶/滑动窗口）

2. 设计规则
   - 编写限流配置
   - 检查规则冲突
   - 评估影响范围

3. 测试验证
   - 在测试环境验证
   - 模拟流量测试
   - 确认限流效果

4. 灰度发布
   - 先在部分节点生效
   - 观察监控指标
   - 确认无异常

5. 全量上线
   - 推送到所有节点
   - 持续监控
   - 记录变更日志
```

#### 2. 更新限流规则

```
1. 监控告警
   - 收到限流告警
   - 分析告警原因
   - 确定是否需要调整

2. 分析原因
   - 是否流量突增？
   - 是否系统容量不足？
   - 是否配置不合理？

3. 调整阈值
   - 计算新的限流阈值
   - 更新限流配置
   - 推送到所有节点

4. 观察效果
   - 监控限流拒绝率
   - 监控系统负载
   - 确认调整效果

5. 持续优化
   - 定期review限流配置
   - 根据业务变化调整
   - 优化限流策略
```

#### 3. 删除限流规则

```
1. 确认影响
   - 评估删除影响范围
   - 确认是否有依赖
   - 通知相关人员

2. 备份配置
   - 导出当前配置
   - 保存到配置仓库
   - 便于回滚

3. 禁用规则
   - 先禁用规则（status=0）
   - 观察一段时间
   - 确认无异常

4. 观察一段时间
   - 监控系统指标
   - 确认无负面影响
   - 收集反馈

5. 删除规则
   - 从数据库删除
   - 从Redis删除
   - 记录变更日志
```

### 8.3 性能优化建议

#### 1. 本地限流器容量设置

```java
// 本地限流器设置为配置值的1.2倍
double permitsPerSecond = config.getLimitCount() * 1.2 / config.getTimeWindow();
```

**优势：**
- 保护Redis不被打垮
- 减少20%的Redis请求
- 提高限流性能

#### 2. 配置缓存

```java
// 配置缓存
private final Map<String, RateLimitConfig> configCache = new ConcurrentHashMap<>();

// 本地限流器缓存
private final Map<String, RateLimiter> localLimiters = new ConcurrentHashMap<>();
```

**优势：**
- 避免频繁查询Redis
- 提高限流判断性能
- 降低Redis压力

#### 3. Lua脚本优化

```lua
-- 使用Lua脚本保证原子性
-- 避免多次网络往返
-- 减少Redis压力
```

**优势：**
- 原子性保证
- 减少网络开销
- 提高执行效率

### 8.4 监控与告警

#### 1. 关键指标监控

```
- 限流拒绝率：被限流拒绝的请求比例
- 限流QPS：每秒限流的请求数
- Redis异常率：Redis限流异常的比例
- 配置更新延迟：从发布到生效的时间
```

#### 2. 告警规则

```
- 限流拒绝率 > 10%：告警
- Redis异常率 > 1%：告警
- 配置更新延迟 > 1秒：告警
- 配置加载失败：告警
```

#### 3. 日志记录

```java
// 限流拒绝日志
log.warn("限流拒绝: type={}, target={}, ip={}", limitType, limitTarget, clientIp);

// Redis异常日志
log.error("Redis限流异常，降级为本地限流: key={}", key, e);

// 配置更新日志
log.info("限流配置更新: key={}, oldCount={}, newCount={}", key, oldCount, newCount);
```

### 8.5 故障处理

#### 1. Redis异常

**现象：**
- Redis连接失败
- Redis响应超时
- Redis限流异常

**处理：**
```java
try {
    // Redis分布式限流
    return tryAcquireDistributed(key, config);
} catch (Exception e) {
    log.error("Redis限流异常，降级为本地限流", e);
    return true; // 降级策略：Redis异常时放行
}
```

**保障：**
- 自动降级为本地限流
- 服务不中断
- 记录异常日志

#### 2. 配置推送失败

**现象：**
- 消息推送失败
- 网关节点未接收到消息
- 配置未生效

**处理：**
```java
// 手动触发全量重载
POST /gateway-rate-limit/refresh
```

**保障：**
- 支持手动刷新
- 启动时自动加载
- 配置持久化到MySQL

#### 3. 配置冲突

**现象：**
- 下层限流阈值 > 上层限流阈值
- 多个规则冲突

**处理：**
```java
// 参数校验
private void validateConfig(RateLimitConfigReqVO reqVO) {
    // 检查规则冲突
    checkConflict(reqVO);
}
```

**保障：**
- 创建时校验
- 更新时校验
- 避免冲突配置

## 三、常见问题

### Q1: 限流配置多久生效？

**A:** 配置更新后，通过Redis Pub/Sub推送到所有网关节点，通常在1秒内生效，无需重启网关节点。

### Q2: 如何选择限流策略？

**A:**
- 需要允许突发流量 → 令牌桶
- 需要精确控制 → 滑动窗口
- 性能要求高 → 令牌桶
- 安全要求高 → 滑动窗口

### Q3: 限流阈值如何设置？

**A:**
```
限流阈值 = 系统容量 × 安全系数
- 系统容量：通过压测得出
- 安全系数：通常为0.7-0.8
```

### Q4: Redis异常时限流器如何工作？

**A:** Redis异常时，自动降级为本地限流，保证服务可用性。本地限流器仍然生效，避免限流器成为单点故障。

### Q5: 如何避免限流规则冲突？

**A:**
- 下层限流阈值 < 上层限流阈值
- 创建时进行校验
- 定期review限流配置

### Q6: 如何监控限流效果？

**A:**
- 监控限流拒绝率
- 监控限流QPS
- 监控Redis异常率
- 查看限流日志

### Q7: 如何回滚限流配置？

**A:**
- 从数据库查询历史配置
- 调用更新接口恢复配置
- 配置自动推送到所有节点

### Q8: 本地限流和Redis限流的区别？

**A:**
- 本地限流：单机限流，速度快，容量为配置值的1.2倍
- Redis限流：分布式限流，跨节点协调，容量为精确配置值
- 协同工作：本地限流保护Redis，Redis限流精确控制

### Q9: 本地+分布式混合模式如何工作？

**A:**
- 网关节点维护本地令牌计数器
- 请求到达时，先消费本地令牌（无需访问Redis）
- 本地令牌不足时，从Redis批量获取（减少Redis访问）
- 性能提升50-100倍，同时保证分布式限流精度

### Q10: 如何选择限流模式？

**A:**
- QPS < 1000：使用 DISTRIBUTED（简单可靠）
- 1000 < QPS < 10000：根据Redis压力选择
- QPS > 10000：优先使用 LOCAL_DISTRIBUTED（高性能）

