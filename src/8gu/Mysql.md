# MySQL

## 什么是DoubleWrite

1. **​解决什么问题？​**​
   - InnoDB的数据操作单元是“页”（默认为16KB）。
   - 操作系统（OS）和磁盘硬件（如HDD/SSD）的写操作通常以更小的“块”（如4KB）为单位进行。
   - 当InnoDB将修改后的脏页**刷回**磁盘（如`.ibd`数据文件）时，如果**系统崩溃或断电发生在写这16KB页的中间过程**（例如只写了前4KB或前8KB），就会导致该页**部分数据更新成功，部分未更新**，造成**页撕裂/部分写**。这种页在逻辑上是损坏的，无法通过redo log（重做日志）恢复，因为redo log的前提是磁盘上的原始页是完整的。
2. **如何工作？**
   - **两步写入：** 在将脏页写入其最终数据文件位置之前，InnoDB会**先将脏页的副本**写入一个专门的、连续分配的磁盘区域，叫做**doublewrite buffer（双写缓冲区）**。这个缓冲区通常位于系统表空间 (`ibdata1`) 中。
   - **顺序写入：** 多个脏页的副本会被连续地、顺序地写入到doublewrite buffer区域。
   - **刷回实际位置：** 只有在doublewrite buffer成功写完后，InnoDB才会将这些脏页实际写入（可能是随机写入）到它们各自在表空间数据文件 (`*.ibd`) 中的最终位置。
3. **如何保障数据？**
   - 如果在第二步（写入实际位置）**之前**发生崩溃：doublewrite buffer里的副本是完整的（因为是原子写入较小的块或由存储保证），最终位置的数据页未更新或仍是旧的完整页。重启恢复时，InnoDB用doublewrite buffer里的完整副本来覆盖最终位置的数据页。
   - 如果在第二步（写入实际位置）**期间**发生崩溃（部分写）：最终位置的数据页是损坏的，但doublewrite buffer里的副本是完整的。重启恢复时，InnoDB发现最终位置数据页损坏，于是用doublewrite buffer里的完整副本来修复它。

**简单说：doublewrite是先写一份完整的“备份”到一个安全区域，再写正式位置。如果写正式位置时出错了，就用安全区的“备份”来修复。它牺牲了一点写性能（两次写），换取了数据页物理完整性的关键保障，使得数据库在崩溃后能安全恢复。** 对于使用保证原子写入（如大多数现代SSD的16K原子写入）的系统，可以关闭doublewrite以提升性能，但通常默认启用以保证最大可靠性。

## 什么是索引下推

1. 核心原理（一句话概括）：

> **将 `WHERE` 子句中与索引列相关的部分过滤条件下推给存储引擎（如InnoDB），在扫描索引过程中提前过滤无效数据，避免将所有索引记录都返回给MySQL服务器层再过滤。**

2. 具体工作流程对比：

* **未使用索引下推（传统方式）：**

1. **存储引擎**：根据索引定位到满足**最左匹配原则的条件**的记录。
2. **存储引擎→服务器层**：将所有满足最左条件的记录对应的**主键（或行ID）返回**。
3. **服务器层**：根据主键回表查询完整行数据 → 再应用 `WHERE` 子句**剩余的过滤条件**进行二次过滤。
4. **问题**：如果索引初步筛选的结果集很大，但实际匹配的记录很少，会产生大量无效回表操作。

* **使用索引下推（ICP）：**

1. **存储引擎**：根据索引定位到满足**最左匹配条件**的记录。

2. **存储引擎内部过滤**：直接在索引结构中检查 **`WHERE` 子句剩余的其他索引列条件**（即使不满足最左匹配）。

3. **存储引擎→服务器层**：只返回**同时满足所有索引列条件**的记录的主键。

4. **服务器层**：仅对少量主键回表查询完整数据 → 执行最终过滤（如非索引列条件）。

## Binlog的格式有哪几种?

### STATEMENT (基于语句的复制 - SBR)

- **记录内容：** 记录的是实际执行的 **SQL 语句本身**（如 `UPDATE users SET name='Alice' WHERE id=1;`）。
- 优点：
   - **日志文件小：** 因为只记录 SQL 语句，对于影响大量行的操作（如 `UPDATE ... WHERE ...` 匹配很多行），日志量远小于 ROW 模式。
   - **可读性强：** 直接查看 binlog 文件或使用 `mysqlbinlog` 工具可以清晰地看到执行过的 SQL，便于人工审计和理解。
   - **历史悠久：** 是最早的 binlog 格式，兼容性好。
- 缺点：
   - **主从不一致风险 (最主要缺点)：** 某些 SQL 语句的执行结果可能依赖于上下文（如使用了 `NOW()`, `RAND()`, `USER()`, `UUID()`, 存储过程/函数、触发器、使用了不同索引等），导致在主库和从库上执行相同的 SQL 语句可能产生不同的结果，造成数据不一致。
   - **锁竞争可能更严重：** 某些需要在从库上重放的语句（如 `UPDATE ... WHERE ...` 没有使用索引）可能在从库上造成全表扫描和锁表。
- **适用场景：** 对数据一致性要求不是极其严格，且 SQL 模式简单（避免使用不确定函数、存储过程等）的场景；或者需要节省磁盘空间和网络带宽的场景（需谨慎评估不一致风险）。

### ROW (基于行的复制 - RBR)

- **记录内容：** 记录的是**每一行数据在修改前和修改后的内容**（或仅修改后的内容）。对于 `UPDATE`，记录被修改行的主键（或唯一标识）以及所有列的新值（或仅被修改列的新值）；对于 `INSERT`，记录新行的所有列值；对于 `DELETE`，记录被删除行的主键（或唯一标识）和所有列值。
- 优点：
   - **数据一致性高 (最主要优点)：** 由于记录的是实际行的变化，而不是 SQL 语句，因此复制过程与 SQL 语句的执行上下文无关，能最大程度保证主从数据的一致性。解决了 `STATEMENT` 模式下不确定函数等问题。
   - **减少锁竞争：** 在从库应用更改时，通常是基于行 ID 操作，可以减少锁的粒度（行锁），降低锁竞争。
   - **更安全的复制：** 对存储过程、触发器、不确定函数等更友好。
- 缺点：
   - **日志文件大：** 对于影响大量行的操作（如批量更新、删除），每条被修改的行都会产生一条记录，日志量会非常大，占用更多磁盘空间和网络带宽（尤其是在主从同步时）。
   - **可读性差：** 使用 `mysqlbinlog` 查看时，看到的是行的二进制数据或 Base64 编码（除非使用 `-v` 或 `--verbose` 选项解析），不如 SQL 语句直观。
   - **生成日志慢：** 写入每行变更通常比记录一条 SQL 语句开销更大。
- **适用场景：** **推荐默认使用**，尤其是在对数据一致性要求极高的场景（如金融交易）、使用了不确定函数、存储过程、触发器，或者主从表结构不完全一致（但需注意列映射）的情况。MySQL 5.7.7 及以后版本的默认 binlog 格式就是 `ROW`。

### MIXED (混合模式复制)

- 记录内容：

  结合了 `STATEMENT` 和 `ROW` 两种模式。

  MySQL 会根据执行的 SQL 语句动态决定使用哪种格式记录 binlog。

   - 对于**安全**的、可以确定在主从库上执行结果一致的语句（如不包含不确定函数的简单 CRUD），使用 `STATEMENT` 格式记录（节省空间）。
   - 对于**不安全**的、可能导致主从不一致的语句（如包含 `NOW()`, `UUID()`, 用户自定义函数 UDF 等），则自动切换到 `ROW` 格式记录（保证一致性）。

- 优点：

   - **兼顾空间和一致性：** 试图在 `STATEMENT` 的空间效率和 `ROW` 的数据一致性之间取得平衡。
   - **灵活性：** 自动选择最优（或最安全）的记录方式。

- 缺点：

   - **规则复杂：** 需要理解 MySQL 判断“安全”和“不安全”的内部规则。
   - **仍有小概率不一致风险：** 虽然减少了 `STATEMENT` 的风险，但理论上如果 MySQL 错误地将一个“不安全”的语句判断为“安全”并用 `STATEMENT` 记录，仍可能导致不一致（不过这种情况较少）。
   - **日志大小不确定：** 日志大小取决于实际执行的语句类型，不如单一模式可预测。

- **适用场景：** 希望在一定程度上平衡日志大小和数据一致性风险的场景。在 MySQL 5.7.7 之前是默认格式。

## SQL语句的执行过程

   ![1676276921091-c44ad9b7-f173-4099-9bed-39486d5dbd07.png](https://pub-8f51c562924b4b9f89b40704dbb3bc16.r2.dev/PicGo/1676276921091-c44ad9b7-f173-4099-9bed-39486d5dbd07-357586.png)

   ①使用**连接器**，通过客户端/服务器通信协议与 MySQL 建立连接。并查询是否有权限

   ②Mysql8.0之前**检查是否开启缓存**，开启了 Query Cache 且命中完全相同的 SQL 语句，则将查询结果直接返回给客户端；

   ③由**解析器(分析器)** 进行语法分析和语义分析，并生成解析树。如查询是select、表名users、条件是age='18' and name='Hollis'，**预处理器**则会根据 MySQL 规则进一步检查解析树是否合法。比如检查要查询的数据表或数据列是否存在等。

   ④由**优化器**生成执行计划。根据索引看看是否可以优化

   ⑤**执行器**来执行SQL语句，这里具体的执行会操作MySQL的存储引擎来执行 SQL 语句，根据存储引擎类型，得到查询结果。若开启了 Query Cache，则缓存，否则直接返回。

## 不可重复读怎么解决幻读问题?它解决不了哪些幻读？

**MySQL的InnoDB引擎利用间隙锁和临键锁，在其可重复读隔离级别下有效地阻止了其他事务向当前事务查询范围插入新行，从而防止了幻读的发生。**

 MySQL的可重复读隔离级别通过MVCC和Next-Key Lock**解决了大部分幻读场景**，但两类操作仍可能突破防线：

1. 事务内混用快照读和当前读时，因数据可见性不一致导致逻辑幻读。
2. 在表末尾插入数据时，因间隙锁无法覆盖无限区间而产生物理幻读。

## 修改一条记录什么情况下会锁表？什么情况下会锁行？

| **情况**                  | **锁表还是锁行？**                                           | **关键决定因素**                                             |
| :------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **WHERE 无法利用索引**    | 几乎总是锁表                                                 | 数据库无法精确定位目标行，只能进行全表扫描                   |
| **显式表锁操作**          | 锁表                                                         | 显式执行了 `LOCK TABLES` 等命令                              |
| **DDL 操作（ALTER等）**   | 锁表                                                         | 修改表结构需要独占整个表                                     |
| **大量修改导致锁升级**    | 锁表                                                         | 修改行数过多，超出阈值                                       |
| **没有 WHERE 条件**       | 锁表                                                         | 操作涉及表中所有行                                           |
| **WHERE 能利用索引**      | **锁行** (包括索引记录和可能的间隙)                          | 数据库能通过索引精确定位一个或多个目标行                     |
| **主键/唯一键冲突的插入** | **锁行** (锁冲突的具体索引记录)                              | 能精确定位到已存在的键值                                     |
| **意向锁 (IS, IX)**       | **不是锁表操作！** (协调锁的辅助机制，通常与其他行锁或表锁共存) | 表明事务的意图（稍后要在某些行加锁）。虽然作用在表级别，但本身非常轻量且兼容，不影响大部分并发操作 |

