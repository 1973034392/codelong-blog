# JDK动态代理与CGLib动态代理的核心区别

在Java开发中，动态代理是一种非常重要的技术，它允许程序在运行时动态地创建代理对象，从而在不修改源代码的情况下增强方法、实现AOP（面向切面编程）等。最主流的两种动态代理实现方式是JDK官方提供的动态代理和第三方库CGLib。

它们两者在实现原理、使用限制和性能上都有着显著的区别。

## 核心区别速览

| 特性             | JDK 动态代理                                                 | CGLib 动态代理                                          |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| **实现原理**     | 利用Java的 **反射机制**，创建一个实现共同接口的代理类。      | 利用 **ASM字节码增强** 技术，创建一个被代理类的子类。   |
| **代理对象要求** | 被代理的类 **必须实现至少一个接口**。                        | 被代理的类 **无需实现接口**，但不能是`final`修-饰的类。 |
| **代理范围**     | 只能代理接口中定义的方法。                                   | 可以代理类中所有非`final`的`public`和`protected`方法。  |
| **代理类型**     | 生成的代理类与被代理类实现相同的接口，是兄弟关系。           | 生成的代理类是 **被代理类的子类**，是父子关系。         |
| **性能**         | 在现代高版本JDK（8及以后）中，性能与CGLib相当，甚至在代理创建速度上更快。 | 早期版本中执行效率更高，但代理创建过程较慢。            |
| **依赖**         | JDK自带，无需引入任何第三方库。                              | 需要引入第三方`cglib`库。                               |

## 详细解析

### 1. 实现原理

- **JDK 动态代理** 它的核心是 `java.lang.reflect.Proxy` 类和 `java.lang.reflect.InvocationHandler` 接口。当你调用 `Proxy.newProxyInstance()` 方法时，JDK会在内存中动态地构建一个`$Proxy0`之类的代理类。这个代理类会实现你指定的目标接口，并将所有的方法调用都委托给一个`InvocationHandler`实例的`invoke`方法来处理。你可以在`invoke`方法中加入自定义的逻辑（如日志、事务等），然后再通过反射调用目标对象的原始方法。
- **CGLib (Code Generation Library)** CGLib的原理则更为深入。它通过一个名为ASM的字节码操作框架，在运行时动态地修改目标类的字节码，并生成一个继承自该类的子类作为代理。当调用代理对象的方法时，会被`MethodInterceptor`（方法拦截器）拦截，你可以在拦截器中实现增强逻辑，并通过`MethodProxy`调用父类（即原始目标类）的同名方法。

### 2. 核心限制与差异

- **接口依赖**：这是两者最根本的区别。JDK动态代理强制要求目标类必须实现接口，它只能为接口创建代理。而CGLib则可以为普通的类创建代理，因为它采用的是继承的方式。
- **final关键字**：由于CGLib是通过继承来创建代理的，所以它无法代理`final`类（因为`final`类不能被继承）。同理，类中被`final`修饰的方法也无法被代理（因为`final`方法不能被子类重写）。JDK动态代理则没有这个限制，因为它是基于接口实现的。

### 3. 性能演进

在早期的Java版本中（如JDK 6或7），CGLib的执行性能通常优于JDK动态代理。这是因为CGLib直接操作字节码，而JDK代理则依赖于反射，反射调用在当时相对较慢。

然而，从 **JDK 8** 开始，Java虚拟机对反射调用进行了大量的优化（如方法内联、JIT编译优化等），使得JDK动态代理的性能得到了极大的提升。在现代的Java应用中，两者的执行性能差距已经微乎其微。在某些场景下，特别是代理对象的创建速度上，JDK动态代理甚至会比CGLib更快。

### 4. 在Spring AOP中的应用

Spring框架的AOP功能完美地体现了这两种代理的选择策略：

- **默认策略**：如果目标Bean **实现了接口**，Spring AOP会默认使用 **JDK动态代理**。
- **备用策略**：如果目标Bean **没有实现任何接口**，Spring AOP则会使用 **CGLib** 来创建代理。
- **强制使用CGLib**：你也可以通过配置（例如，在Spring Boot中设置 `spring.aop.proxy-target-class=true`）来强制Spring AOP对所有Bean（无论是否实现接口）都使用CGLib代理。这样做可以避免因代理类型不同而引发的一些问题（例如，在类内部调用另一个被AOP增强的方法时，可能导致增强失效）。

## 总结

总的来说，选择哪种代理方式主要取决于你的目标对象设计：

- 如果你的应用是面向接口编程的，那么 **JDK动态代理** 是一个简单、高效且无需额外依赖的选择。
- 如果需要代理一个没有实现接口的普通类，或者需要代理类中的特定方法（而非接口中的方法），那么 **CGLib** 是你唯一的选择。

在现代框架如Spring Boot中，由于其更强的通用性，CGLib的使用变得越来越普遍。
