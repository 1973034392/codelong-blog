# Spring 核心揭秘：IoC 与 AOP

Spring 框架之所以能够在 Java 开发中经久不衰，很大程度上归功于其两大核心思想：**控制反转 (Inversion of Control, IoC)** 和 **面向切面编程 (Aspect-Oriented Programming, AOP)**。理解了它们，就等于掌握了 Spring 的精髓。

## 一、 IoC (控制反转) —— 专业的事交给专业的人

IoC 不是一个具体的技术，而是一种**设计思想**。它彻底改变了我们组织代码和管理对象的方式。

### 1. “控制”指的是什么？

在传统的程序开发中，我们通常直接在代码中通过 `new` 关键字来创建对象。

```java
// 传统方式：自己创建依赖的对象
public class UserService {
    private UserDao userDao = new UserDaoImpl(); // 主动创建依赖

    public void findUser() {
        userDao.query();
    }
}
```

在这里，`UserService` **主动控制**了 `UserDaoImpl` 对象的创建。如果未来需要将 `UserDaoImpl` 更换为 `UserDaoMongoImpl`，就必须修改 `UserService` 的源代码。这种代码间的强耦合关系，使得系统难以维护和扩展。

### 2. 如何“反转”？

**控制反转**的核心思想是：**将创建和管理对象的“控制权”从我们的应用程序代码中移交出去，交给一个外部的“容器”(Container) 来负责。**

这个容器，在 Spring 中就是 **IoC 容器**。我们不再自己 `new` 对象，而是告诉容器我们需要什么，容器会主动把我们需要的东西“注入”进来。

```java
// Spring IoC 方式：由容器注入依赖
public class UserService {
    private UserDao userDao; // 只声明依赖，不主动创建

    // 通过构造函数或 setter 方法让容器注入
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }

    public void findUser() {
        userDao.query();
    }
}
```

现在，`UserService` 不再关心 `UserDao` 的具体实现是什么，也不关心它如何被创建。它只负责使用。对象的创建和它们之间依赖关系的管理，都由 Spring IoC 容器完成了。**控制权从应用代码反转到了 Spring 容器**，这就是“控制反转”。

### 3. 依赖注入 (Dependency Injection, DI)

DI 是 IoC 思想最主流、最经典的实现方式。上面代码中，容器将 `userDao` 实例传递（注入）给 `userService` 的过程，就是**依赖注入**。

Spring 支持多种注入方式：

- **构造函数注入 (Constructor Injection)**: 通过构造函数传入依赖，最推荐的方式，能保证对象在创建后就是完整可用的。
- **Setter 注入 (Setter Injection)**: 通过 `setXxx()` 方法注入依赖，灵活性更高。
- **字段注入 (Field Injection)**: 直接在字段上使用 `@Autowired` 注解，代码最简洁，但存在一些缺点（如不利于单元测试）。

**总结：IoC 是一种思想，DI 是其具体实现。它们的目标是“解耦”，让组件之间的关系变得松散，从而使整个系统更加灵活、可维护、易于测试。**

## 二、 AOP (面向切面编程) —— 给你的代码“加点料”

如果说 IoC 是 Spring 的骨架，负责组装对象，那么 AOP 就是 Spring 的血肉，它允许我们在不修改源代码的情况下，为程序增加额外的功能。

### 1. 什么是“切面”？

在我们的业务逻辑中，常常会散布着一些与核心业务无关，但又必不可少的功能，比如：

- 日志记录
- 事务管理
- 安全检查
- 性能监控

这些功能像藤蔓一样缠绕在我们的核心业务代码中，导致代码臃肿、难以维护。这种散布在各处的通用功能被称为 **横切关注点 (Cross-cutting Concerns)**。

**AOP 的目标就是将这些“横切关注点”从业务逻辑中抽离出来，形成一个独立的模块，这个模块就叫“切面” (Aspect)。**

### 2. AOP 核心概念

理解 AOP 需要先了解几个关键术语：

- **Aspect (切面)**: 对横切关注点的封装。它包含了要在哪里（Pointcut）以及做什么（Advice）的完整定义。例如，一个“日志切面”就封装了所有关于日志记录的逻辑。
- **Join Point (连接点)**: 程序执行过程中的一个特定位置，比如方法的调用、异常的抛出等。在 Spring AOP 中，连接点通常指的就是**方法的执行**。
- **Advice (通知)**: 切面在特定的连接点上执行的**动作**。通知有多种类型：
  - `@Before`: 在目标方法执行**前**运行。
  - `@After`: 在目标方法执行**后**运行（无论成功还是失败）。
  - `@AfterReturning`: 在目标方法**成功返回后**运行。
  - `@AfterThrowing`: 在目标方法**抛出异常后**运行。
  - `@Around`: **环绕**目标方法执行，功能最强大，可以控制方法是否执行，修改返回值等。
- **Pointcut (切点)**: 一个**表达式**，用于筛选匹配的连接点。它精确地定义了 Advice 应该作用于哪些方法的调用上。
- **Target (目标对象)**: 被一个或多个切面所“通知”的对象。
- **Proxy (代理)**: AOP 的核心机制。Spring AOP 会为目标对象创建一个**代理对象**。当外部调用目标方法时，实际上是调用了这个代理对象的方法，代理对象会在调用原始方法前后，执行切面中定义的 Advice。

**简单来说，AOP 就是在说：“嘿，Spring！请用我这个‘切面’(Aspect)，在符合‘切点’(Pointcut) 描述的所有地方，执行我指定的‘通知’(Advice)。”**

### 3. AOP 的工作原理

Spring AOP 默认使用两种动态代理技术来实现：

1. **JDK 动态代理**: 如果目标对象实现了接口，Spring 会使用 JDK 自带的动态代理来创建代理对象。
2. **CGLIB 代理**: 如果目标对象没有实现接口，Spring 会使用 CGLIB 库，通过继承目标类的方式来创建代理对象。

无论哪种方式，最终效果都是在不侵入原始代码的情况下，将通用功能（如日志、事务）织入到业务流程中。

### 总结

- **IoC** 关注的是**对象之间的关系**，通过解耦让系统结构更清晰。
- **AOP** 关注的是**分离业务逻辑和横切关注点**，让代码职责更单一。

IoC 是基础，它负责创建和管理包括切面和目标对象在内的所有 Bean。AOP 在此基础上，通过动态代理技术，将切面的功能动态地应用到目标 Bean 上。两者相辅相成，共同构成了 Spring 框架强大而灵活的技术内核。