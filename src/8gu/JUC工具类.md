# JUC并发工具类详解

在 Java 的 `java.util.concurrent` 包中，提供了几个强大的并发工具类，用于协调和控制多线程的执行。其中，`CountDownLatch`、`CyclicBarrier` 和 `Semaphore` 是最常用也最经典的三种。

## 1. CountDownLatch (倒计时门闩)

`CountDownLatch` 允许一个或多个线程等待其他一组线程完成操作。它就像一个倒计时器，当计时器减到零时，所有等待的线程都会被唤醒。

- **生活比喻：火箭发射**
  - 想象一下火箭发射的场景。发射控制中心（主线程）必须等待所有系统自检（多个子线程，如燃料检查、导航系统检查等）全部完成，才能下达“点火”指令。
  - `CountDownLatch` 的初始计数就是检查项的总数。每个检查项完成，就调用 `countDown()` 方法，计数减一。
  - 发射控制中心则调用 `await()` 方法，一直阻塞等待，直到计数变为零，才继续执行点火。
- **核心方法:**
  - `CountDownLatch(int count)`: 构造函数，设置初始计数值。
  - `await()`: 调用该方法的线程会被阻塞，直到计数器变为 0。
  - `countDown()`: 将计数器减 1。
- **关键特性:**
  - **一次性:** 计数器减到 0 后，`CountDownLatch` 就完成了它的使命，不能被重置或重复使用。
  - **一对多/多对多:** 可以是一个线程等待多个线程，也可以是多个线程等待另外多个线程。
- **适用场景:**
  - 当一个主任务需要等待多个子任务执行完毕后才能继续执行时。例如，并行计算后汇总结果，或者在应用程序启动时，主线程需要等待所有必要的服务都加载完毕。

## 2. CyclicBarrier (循环栅栏)

`CyclicBarrier` 的目标是让一组线程相互等待，直到所有线程都到达一个公共的屏障点（barrier point），然后这些线程才能继续执行。

- **生活比喻：组团旅游**
  - 想象一个旅行团约定早上 8 点在酒店门口集合，然后一起出发去景点。每个人（线程）准备好后，就到门口等待。
  - `CyclicBarrier` 就是这个“酒店门口”。当最后一个人到达后，“栅栏”被打破，所有人（所有线程）才一起出发。
  - 更重要的是，这个栅栏是**可循环使用**的。他们到达第一个景点后，可以再次使用同一个栅栏等待所有人到齐，然后再去下一个景点。
- **核心方法:**
  - `CyclicBarrier(int parties)`: 构造函数，`parties` 指的是需要在此栅栏处等待的线程数量。
  - `CyclicBarrier(int parties, Runnable barrierAction)`: 一个高级构造函数，当所有线程都到达栅栏时，会优先执行 `barrierAction` 这个任务，然后再释放所有等待的线程。
  - `await()`: 线程调用此方法表示自己已到达栅栏，并开始等待其他线程。
- **关键特性:**
  - **可重用性:** 当所有等待的线程被释放后，栅栏可以被重用。
  - **集体行动:** 强调的是“所有线程都到达”这个集体条件，而不是像 `CountDownLatch` 那样关心“任务是否完成”。
- **适用场景:**
  - 多线程计算中，需要将一个大任务拆分成多个阶段，确保所有线程都完成了当前阶段，才能进入下一阶段。

## 3. Semaphore (信号量)

`Semaphore` 用于控制同一时间能够访问特定资源的线程数量。它内部维护了一组“许可证”（permits）。

- **生活比喻：停车场**
  - 一个停车场只有 10 个车位。`Semaphore` 就相当于停车场的入口管理员，他手上有 10 张停车许可证。
  - 每当有车（线程）想进入停车场，就必须从管理员那里获取一张许可证 (`acquire()`)。如果许可证发完了，后来的车就必须在入口外排队等待。
  - 每当有车离开停车场，它会交还许可证 (`release()`)，这样等待的车辆中就有一辆可以进入了。
- **核心方法:**
  - `Semaphore(int permits)`: 构造函数，设置许可证的总数量。
  - `acquire()`: 获取一个许可证。如果许可证已耗尽，线程将阻塞等待。
  - `release()`: 释放一个许可证，将其归还给信号量。
- **关键特性:**
  - **流量控制:** 核心功能是限制并发访问资源的线程数，而不是线程间的同步等待。
  - **公平性:** 可以配置为公平模式，即按照线程请求的先后顺序来分配许可证。
- **适用场景:**
  - 任何需要限制并发访问数量的场景。例如，数据库连接池、实现一个有界的对象池，或者对某个计算密集型API的调用进行限流。

## 总结对比

| 特性         | CountDownLatch (倒计时门闩)        | CyclicBarrier (循环栅栏)       | Semaphore (信号量)             |
| ------------ | ---------------------------------- | ------------------------------ | ------------------------------ |
| **核心功能** | 一个或多个线程等待其他线程完成操作 | 一组线程相互等待到达某个公共点 | 控制同时访问特定资源的线程数量 |
| **可重用性** | 否，一次性使用                     | 是，可以循环使用               | 是，许可证可以获取和释放       |
| **关注点**   | 任务的完成（计数）                 | 线程的到达（栅栏）             | 资源的访问（许可证）           |
| **线程关系** | 等待方和被等待方                   | 所有线程地位平等，相互等待     | 竞争资源方                     |
