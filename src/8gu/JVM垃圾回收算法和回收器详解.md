# JVM垃圾回收算法与回收器详解

在Java虚拟机（JVM）中，垃圾回收（Garbage Collection, GC）是一项至关重要的自动内存管理机制。它的核心任务是识别并回收不再被程序使用的对象所占用的内存。理解其背后的算法和不同的回收器实现，对于进行JVM调优和构建高性能Java应用至关重要。

## 一、 核心垃圾回收算法

GC算法是垃圾回收器实现其功能的理论基础。在进行回收前，首先需要解决一个问题：**如何判断对象是“垃圾”？** 目前主流的方法是**可达性分析（Reachability Analysis）**。该算法将一系列称为“GC Roots”的对象作为起点（如虚拟机栈中引用的对象、静态属性引用的对象等），从这些节点开始向下搜索，凡是能够被搜索到的对象都被认为是“存活”的，反之则为“垃圾”。

确定了垃圾之后，就轮到具体的回收算法登场了。

### 1. 标记-清除（Mark-Sweep）算法

这是最基础的回收算法，分为两个阶段：

- **标记（Mark）**：遍历所有GC Roots，标记所有可达的（存活的）对象。
- **清除（Sweep）**：遍历整个堆，回收所有未被标记的对象所占用的空间。
- **优点**：实现简单，不需要移动对象。
- **缺点**：
  - **效率问题**：标记和清除两个过程的效率都不算高。
  - **空间碎片化**：清除后会产生大量不连续的内存碎片。当需要分配一个较大的对象时，可能会因为找不到足够大的连续空间而不得不提前触发又一次GC。

### 2. 标记-复制（Mark-Copy）算法

为了解决碎片化问题，复制算法应运而生。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。

- **过程**：当这一块内存用完时，就将还存活的对象**复制**到另一块上面，然后再把已使用过的内存空间一次性清理掉。
- **优点**：
  - **无内存碎片**：每次回收后，内存都是连续的。
  - **实现简单，运行高效**：尤其是在存活对象很少的情况下，复制操作的成本很低。
- **缺点**：
  - **空间浪费**：可用内存缩小为原来的一半，代价较高。

### 3. 标记-整理（Mark-Compact）算法

该算法结合了“标记-清除”和“标记-复制”的优点，旨在解决前者的碎片化问题和后者的空间浪费问题。

- **过程**：
  - **标记（Mark）**：过程与“标记-清除”算法一样。
  - **整理（Compact）**：不是直接清理未标记对象，而是将所有存活的对象都向内存空间的一端移动，然后直接清理掉端边界以外的内存。
- **优点**：
  - **无内存碎片**：解决了碎片化问题。
  - **空间利用率高**：没有像复制算法那样的空间浪费。
- **缺点**：
  - **效率较低**：移动对象是一个相对耗时的操作，需要更新所有指向这些对象的引用。

### 4. 分代收集（Generational Collection）算法

这是当前商业虚拟机普遍采用的核心思想，它并非一种具体的算法，而是一种**策略**。该策略基于一个重要的观察：**绝大多数对象都是“朝生夕死”的**。

- **核心思想**：根据对象存活周期的不同将内存划分为几个区域，主要是**新生代（Young Generation）\**和\**老年代（Old Generation）**。
  - **新生代**：存放生命周期短的对象。每次GC时都有大量对象被回收，只有少量存活。因此，新生代通常采用**标记-复制算法**，只需付出少量存活对象的复制成本就可以完成收集。新生代内部又细分为一个Eden区和两个Survivor区（From/To）。
  - **老年代**：存放生命周期长或者经历过多次新生代GC后依然存活的对象。老年代对象存活率高，没有额外空间对它进行分配担保，因此必须使用**标记-清除**或**标记-整理**算法进行回收。

## 二、 主流垃圾回收器

垃圾回收器是GC算法的具体实现。它们在单线程/多线程、并发/并行、以及目标（吞吐量优先/停顿时间优先）等方面有所不同。

### 1. Serial / Serial Old

- **特点**：**单线程**工作的垃圾回收器。“Serial”体现在它进行垃圾回收时，必须暂停所有其他的工作线程（这个过程称为“Stop-The-World”, STW）。
- **算法**：新生代使用“标记-复制”，老年代使用“标记-整理”。
- **适用场景**：主要用于**客户端模式**下的虚拟机，或者在硬件配置较低（如单核CPU）的环境中。对于交互不强的后台计算任务也是一个选择。

### 2. Parallel Scavenge / Parallel Old

- **特点**：Serial回收器的**多线程版本**。在GC期间，它会使用多个线程并行地进行垃圾回收，从而缩短STW的时间。
- **关注点**：**高吞吐量（Throughput）**。吞吐量 = 用户代码运行时间 / (用户代码运行时间 + GC时间)。它致力于让单位时间内完成尽可能多的用户任务。
- **算法**：新生代使用“标记-复制”，老年代使用“标记-整理”。
- **适用场景**：在**后台计算**、数据处理等不需要太多交互，且能容忍一定停顿时间的场景。这是**JDK 8及之前版本的默认回收器**。

### 3. CMS (Concurrent Mark Sweep)

- **特点**：一款以获取**最短回收停顿时间**为目标的回收器。它在GC的大部分阶段（如并发标记、并发清除）都允许用户线程和GC线程**并发执行**，从而显著降低STW时间。
- **关注点**：**低延迟（Low Latency）**。
- **算法**：基于“**标记-清除**”算法实现。
- **缺点**：
  1. **对CPU资源敏感**：并发阶段会占用一部分CPU，导致用户程序变慢。
  2. **产生“浮动垃圾”**：在并发清理阶段，用户线程新产生的垃圾无法被本次GC处理，只能留到下一次。
  3. **内存碎片**：基于“标记-清除”算法，会产生大量碎片，可能导致Full GC。
- **状态**：在 **JDK 9 中被标记为废弃**，在 **JDK 14 中被移除**。

### 4. G1 (Garbage-First)

- **特点**：一款面向服务端应用的、开创性的垃圾回收器。它将整个Java堆划分为多个大小相等的独立区域（Region），并跟踪这些Region里垃圾的价值大小，在后台维护一个优先列表，每次根据**可预测的停顿时间**，优先回收价值最大的Region。
- **关注点**：在**高吞吐量**和**低延迟**之间取得平衡，并提供**可预测的停顿时间模型**。
- **算法**：从整体来看是基于“**标记-整理**”算法，从局部（两个Region之间）来看是基于“**标记-复制**”算法。这意味着它不会产生内存碎片。
- **适用场景**：大内存（6GB以上）的多核服务器，要求兼顾吞吐量和延迟。**自JDK 9起成为默认的垃圾回收器**。

### 5. ZGC (The Z Garbage Collector) - 超低延迟回收器

ZGC 是一款革命性的垃圾回收器，其设计目标只有一个：**实现可扩展的、极低延迟的垃圾回收**。它致力于将 STW（Stop-The-World）停顿时间控制在**毫秒甚至亚毫秒级别**，并且这个停顿时间不会随着堆内存或存活对象大小的增加而增长。

#### ZGC 的核心设计与关键技术

- **基于 Region 的堆内存布局 (ZPages)**：与 G1 类似，ZGC 也将堆划分为多个区域（ZPage），但 ZPage 的大小是动态的（分为小、中、大三类），管理更灵活。
- **着色指针 (Colored Pointers)**：这是 ZGC 最具颠覆性的核心技术。它将对象的标记信息直接存储在 64 位的指针中，而不是对象头里。这使得 GC 在并发处理时能快速判断对象状态，而无需访问对象本身。
- **读屏障 (Load Barrier)**：为了配合着色指针，JIT 编译器会在从堆中加载对象引用的地方注入一小段代码（读屏障）。当应用线程访问对象时，读屏障会检查指针的“颜色”，如果发现对象已被移动，它会负责修正指针到新地址（这个过程也叫“自愈”），从而实现并发的对象转移。
- **多重映射 (Multi-Mapping)**：ZGC 利用虚拟内存技术，将同一块物理内存映射到三个不同的虚拟地址空间，分别对应指针的不同状态。这使得读屏障可以高效地判断指针状态，而无需执行复杂的逻辑。

#### ZGC 的垃圾回收周期

ZGC 的一次完整 GC 周期绝大部分工作都是并发执行的，仅包含短暂的 STW。

1. **初始标记 (Pause Mark Start) - STW**：标记 GC Roots 直接引用的对象，速度极快。
2. **并发标记 (Concurrent Mark)**：并发遍历对象图，找出所有存活对象。
3. **再标记 (Pause Mark End) - STW**：处理并发标记期间发生变化的对象。
4. **并发重定位/转移 (Concurrent Relocate)**：并发地将存活对象复制到新的 Region，消除碎片。

#### 演进与总结

- **分代 ZGC (Generational ZGC)**：从 JDK 21 开始，ZGC 引入了分代机制，可以更高效地回收生命周期短的对象，进一步降低了 GC 开销和 CPU 占用。
- **优点**：极低的停顿时间、高可扩展性（支持 TB 级堆）、无内存碎片。
- **缺点**：相对消耗更多的 CPU 资源，且仅支持 64 位平台。

### 6. Shenandoah

Shenandoah 是另一款与 ZGC 目标相似（追求极低延迟）的垃圾回收器，由 Red Hat 主导开发。它也采用了并发标记和并发整理技术，但其实现细节（如通过转发指针而非着色指针）与 ZGC 不同。它同样是一款优秀的低延迟回收器。

## 三、 总结与对比

| 回收器名称            | 工作线程  | 核心关注点           | 主要算法              | STW时间       | 适用场景                     | JDK版本信息            |
| --------------------- | --------- | -------------------- | --------------------- | ------------- | ---------------------------- | ---------------------- |
| **Serial**            | 单线程    | 响应速度             | 标记-复制 / 标记-整理 | 长            | 客户端模式，单核CPU          | 所有版本               |
| **Parallel Scavenge** | 多线程    | **高吞吐量**         | 标记-复制 / 标记-整理 | 中等          | 后台计算，数据处理           | **JDK 8及之前默认**    |
| **CMS**               | 并发      | **低延迟**           | **标记-清除**         | 短            | 对响应时间有要求的服务       | JDK 9废弃, 14移除      |
| **G1**                | 并发/并行 | **可预测的停顿时间** | 标记-整理 / 标记-复制 | 可控          | 大内存服务端应用             | **JDK 9及之后默认**    |
| **ZGC / Shenandoah**  | 并发      | **极低延迟**         | 复杂的并发算法        | 极短 (亚毫秒) | 超大内存、超低延迟要求的服务 | JDK 11+ 引入，持续演进 |

总的来说，JVM垃圾回收器的发展历程，是从最初简单的“能用就行”（Serial），到关注“多干活”（Parallel），再到追求“快响应”（CMS），最终演进到“既要干得好，又要响应快且稳”（G1、ZGC）的趋势。选择哪款回收器，完全取决于你的应用特性、业务需求以及硬件配置。
