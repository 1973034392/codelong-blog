# Java AbstractQueuedSynchronizer 深度解析：并发控制的基石

#### **第 1 部分：AbstractQueuedSynchronizer (AQS) 导论**

- **AQS 在 `java.util.concurrent` (JUC) 框架中的角色与重要性**

  在 Java 并发编程的宏伟蓝图之中，`AbstractQueuedSynchronizer`（简称 AQS）扮演着无可替代的基石角色。它并非一个直接面向最终用户的工具类，而是 `java.util.concurrent` (JUC) 包中绝大多数同步器（Synchronizer）的底层实现框架 。可以将其理解为一个专为并发工具开发者设计的“同步器构建套件”。

  AQS 由并发编程领域的大师 Doug Lea 在 Java 规范请求 JSR 166 中提出并实现，其核心目标是为锁（Locks）、信号量（Semaphores）、屏障（Barriers）等多种同步机制提供一个通用的、高效的、可伸缩的实现基础 。在 AQS 出现之前，开发者若想构建一个新的同步器，可能需要从更原始的并发原语（如 

  `synchronized` 或 `wait/notify`）从零开始，这不仅过程复杂、极易出错，而且难以保证性能和可伸缩性。AQS 的诞生，正是为了解决这一难题。

  AQS 的核心价值主张在于，它封装并处理了并发编程中最复杂且最容易出错的环节——包括原子化的状态管理、线程的排队、阻塞与唤醒等。这使得并发工具的开发者可以将精力集中于定义其同步器特定的同步逻辑（Policy），而无需关心底层的队列管理、线程调度等繁琐的机制（Mechanism）。

- **核心设计哲学：基于状态同步的可重用框架**

  AQS 的设计哲学根植于一个简洁而强大的理念：几乎所有同步器的行为，都可以抽象为对一个共享“状态”（State）的获取与释放操作。这个状态由一个单一的、被原子性管理的整型变量 `state` 表示 。

  这个 `state` 变量的含义完全由 AQS 的子类来定义，从而赋予了框架极大的灵活性。例如，在一个锁的实现中，`state` 可以表示锁是否被持有（0 代表未锁定，1 代表锁定）；在一个信号量中，`state` 可以表示当前可用的“许可”数量 。AQS 的核心任务，就是提供一套健壮的机制，来安全、高效地管理基于这个 

  `state` 的线程访问规则。

- **关键能力概览：独占模式、共享模式、条件队列与可配置公平性**

  AQS 框架提供了丰富的功能，以支持各种复杂的同步场景，其核心能力可概括为以下几点：

  - **双模式支持**：AQS 支持两种基本的操作模式，且两种模式的线程可以共享同一个等待队列。
    - **独占模式 (Exclusive Mode)**：在任何时刻，只允许一个线程持有同步状态。这是实现互斥锁（如 `ReentrantLock`）的基础 。
    - **共享模式 (Shared Mode)**：允许多个线程同时获取同步状态。这是实现读写锁中的读锁（`ReadWriteLock.readLock()`）、信号量（`Semaphore`）等并发工具的基础 。
  - **条件队列 (Condition Queues)**：通过其内部类 `ConditionObject`，AQS 提供了强大的线程协调机制。它允许线程在获取锁之后，因特定业务条件未满足而挂起，并等待其他线程发出“信号”来唤醒。这比简单的等待锁释放提供了更精细的控制粒度 。
  - **可配置的公平性策略**：AQS 允许其子类在实现时选择公平（Fair）或非公平（Non-fair）的获取策略。公平策略保证等待时间最长的线程将优先获得资源，而非公平策略则允许“插队”，通常能带来更高的吞吐量。这种设计将性能与公平性之间的权衡交给了开发者 。

  AQS 的设计精髓在于其清晰地贯彻了软件工程中的一个经典原则：**机制与策略分离 (Separation of Mechanism and Policy)**。这里的“机制”是指 AQS 内部提供的、通用的、不随具体应用场景变化的底层设施，包括线程排队、等待状态管理、原子化状态更新等。这些是 AQS 已经完美实现的部分。而“策略”则是指特定同步器所定义的、独特的同步规则，例如 `state` 变量的具体含义是什么？在何种条件下可以获取或释放它？这部分逻辑则由 AQS 的子类通过重写特定方法（如 `tryAcquire`）来定义。

  正是这种机制与策略的分离，赋予了 AQS 无与伦比的强大功能和灵活性。它不仅仅是模板方法模式的一个应用实例，更是该模式背后设计思想的深刻体现。这一设计决策使得 `java.util.concurrent` 包从诞生之初就具备了高度的可扩展性，它赋能库开发者乃至专家级应用开发者，能够基于一个稳定、高效的内核，创造出满足特定需求的新型同步工具，而无需重复“造轮子”去解决复杂的并发队列管理问题——这正是 Doug Lea 设计 AQS 的初衷之一 。

------

#### **第 2 部分：AQS 的核心架构**

AQS 的强大功能构建于一个设计精巧的内部架构之上，该架构主要由三部分组成：一个表示同步状态的 `volatile` 变量、一套基于 CAS 的原子操作，以及一个高效的线程等待队列。

- **同步状态 `state`：作为控制基石的 `volatile int`**

  AQS 架构的核心是 `private volatile int state` 这个成员变量 。它是一切同步逻辑的中心。

  - **`volatile` 关键字的作用**：使用 `volatile` 修饰 `state` 变量至关重要。它确保了对 `state` 变量的任何修改都能立即对所有线程可见。根据 Java 内存模型（JMM）的 `volatile` 变量规则，对一个 `volatile` 变量的写操作先行发生于（happens-before）后续对这个变量的读操作。这为基于 AQS 的同步器提供了最基本的内存一致性保障 。

  - **`state` 的多重语义**：`state` 的具体含义由 AQS 的子类来定义，这体现了框架的灵活性。

    - 在 `ReentrantLock` 中，`state` 表示当前持有锁的线程的“重入次数”。`state` 为 0 时表示锁未被持有；每当线程获取锁，`state` 加 1 。
    - 在 `Semaphore` 中，`state` 表示当前可用的“许可”数量 。
    - 在 `CountDownLatch` 中，`state` 表示需要倒数的计数器值 。

  - **受控的访问接口**：为了保证对 `state` 操作的正确性，AQS 提供了三个 `protected final` 方法作为唯一的访问途径：`getState()`、`setState()` 和 `compareAndSetState()` 。

    `final` 关键字禁止子类重写这些方法，从而保证了 AQS 框架对状态访问方式的绝对控制。

- **基于 CAS 的原子状态转换**

  在多线程环境下，对共享状态 `state` 的修改必须是原子操作，否则就会产生竞态条件。AQS 并未使用重量级的 `synchronized` 锁来保护 `state`，而是采用了一种更高效的乐观锁机制——CAS（Compare-And-Swap）。

  - **CAS 操作原理**：CAS 是一种由硬件直接支持的原子指令。它接受三个参数：内存地址 V、预期值 A 和新值 B。只有当内存地址 V 的当前值等于预期值 A 时，处理器才会原子性地将该地址的值更新为新值 B。否则，它什么也不做。这个“比较并交换”的过程是一个不可分割的原子操作 。
  - **`compareAndSetState` 的应用**：AQS 的 `protected final boolean compareAndSetState(int expect, int update)` 方法正是对底层 CAS 指令的封装。它使得线程可以尝试以非阻塞的方式原子性地更新 `state` 。
    - 一个典型的例子是 `ReentrantLock` 的非公平锁在尝试获取锁时的操作：`compareAndSetState(0, 1)`。这行代码的意图是：“如果当前 `state` 的值是 0（锁未被持有），那么就尝试把它原子性地更新为 1（表示我已持有锁）”。如果此操作成功，当前线程就成功获取了锁。如果失败，则意味着在它操作的瞬间，`state` 的值已经被其他线程改变了，当前线程获取锁失败，需要进入后续的排队逻辑 。

- **CLH 队列：一个可伸缩的、非阻塞的 FIFO 等待队列**

  当一个线程尝试获取同步状态失败后，AQS 不会使其盲目地自旋等待，而是会将其放入一个等待队列中挂起。这个队列是 AQS 实现可伸缩性的关键。

  - **队列结构**：该队列是 CLH (Craig, Landin, and Hagersten) 锁算法的一种变体实现，其本质是一个虚拟的、双向链表的 FIFO（先进先出）队列 。它的主要优点在于，节点的入队和出队操作是无锁的（lock-free），极大地减少了在高并发场景下管理等待队列的开销。
  - **`Node` 节点结构**：队列由 `Node` 类的实例链接而成，`Node` 是 AQS 的一个静态内部类，是队列的基本数据单元。其关键字段包括 ：
    - `thread`：封装了在此节点上等待的线程。
    - `prev` 和 `next`：分别指向前驱和后继节点的指针，构成双向链表。
    - `waitStatus`：一个整型值，表示节点当前的状态，这是控制线程阻塞和唤醒的核心。
    - `SHARED` 和 `EXCLUSIVE`：`Node` 内部定义的两个静态常量，用于标记节点是在等待共享模式还是独占模式的资源。这使得两种模式的线程可以共存于同一个队列中。
  - **哨兵 `head` 节点的作用**：AQS 队列的头节点（`head`）是一个“哨兵节点”或“哑节点”（dummy node）。它不代表任何等待的线程，仅仅是一个占位符。这种设计的巧妙之处在于，它极大地简化了队列操作的逻辑。任何时候，第一个真正等待的线程节点的前驱节点（`prev`）总是指向这个非 `null` 的 `head` 节点，从而避免了在处理队列为空或只有一个元素等边界情况时需要编写复杂的条件判断 。
  - **`waitStatus` 状态深度解析**：`waitStatus` 是理解 AQS 线程协作机制的关键。它精确地描述了每个等待节点的需求和责任。

| **表 1: AQS Node `waitStatus` 值及其语义** |
| ------------------------------------------ |
| **状态**                                   |
| `CANCELLED`                                |
| `SIGNAL`                                   |
| `CONDITION`                                |
| `PROPAGATE`                                |
| 0 (初始状态)                               |

导出到 Google 表格

```
一个需要澄清的重要概念是，尽管 AQS 的等待队列被称为“非阻塞队列”，但这指的是对队列本身的操作（如 `enq` 入队）是无锁的，通过 CAS 实现，避免了对队列头尾指针的锁定。然而，被放入队列中的线程本身，毫无疑问是**被阻塞**的。它们通过 `LockSupport.park()` 方法被挂起，交出 CPU 的控制权，进入休眠状态。

这种设计体现了 AQS 的工程实用主义。它通过无锁的队列管理操作，最小化了维护等待队列的开销和竞争，这是提升可伸缩性的关键因素，与 Doug Lea 的设计目标完全一致 [1]。同时，它避免了让等待线程进行 CPU 密集型的忙等待（自旋），因为当锁被持有的时间稍长时，忙等待会极大地浪费系统资源。这种“无锁队列操作”与“有锁线程等待”相结合的混合模式，是 AQS 设计上的一大亮点。
```

------

#### **第 3 部分：模板方法模式：AQS 的扩展框架**

AQS 的设计是模板方法（Template Method）设计模式的典范之作。该模式的核心思想是：在一个父类中定义一个算法的骨架，而将一些可变步骤的实现延迟到子类中。这使得子类可以在不改变算法整体结构的情况下，重新定义该算法的某些特定步骤 。

- **AQS 作为模板方法模式的权威实现**

  AQS 完美地诠释了模板方法模式。AQS 本身作为抽象父类，提供了一系列 `public final` 的方法，如 `acquire`、`release` 等。这些方法定义了资源获取和释放的通用流程和算法骨架（即“模板”）。而获取和释放资源的具体逻辑——如何判断资源是否可被获取，如何更新状态——则被抽象为一系列 `protected` 的方法，如 `tryAcquire`、`tryRelease` 等。这些方法在 AQS 中或者抛出 `UnsupportedOperationException`，或者只有一个简单的默认实现，它们是留给子类去实现的“原语操作” 。

- **不变的算法骨架：`acquire`, `release`, `acquireShared`, `releaseShared`**

  这些由 AQS 提供的 `public final` 方法，构成了同步器不变的执行逻辑。开发者调用这些方法，AQS 会在内部遵循一个固定的流程。

  - `acquire(int arg)` 的逻辑骨架可以简化为：`if (!tryAcquire(arg)) { enqueue thread; block; }` 。这个流程是普适的：首先调用子类实现的 

    `tryAcquire` 尝试获取资源。如果成功，方法返回；如果失败，则将当前线程封装成节点加入等待队列，并将其阻塞。

  - `release(int arg)` 的逻辑骨架可以简化为：`if (tryRelease(arg)) { unblock successor; }` 。这个流程同样是普适的：首先调用子类实现的 

    `tryRelease` 尝试释放资源。如果释放成功（并且子类的实现表明有线程需要被唤醒），AQS 就会负责唤醒等待队列中的下一个线程。

  - 共享模式的对应方法 `acquireShared` 和 `releaseShared` 也遵循类似的、但为共享场景特化的算法骨架 。

- **可扩展的原语：重写 `tryAcquire`, `tryRelease`, `tryAcquireShared`, `tryReleaseShared`**

  这些 `protected` 方法是 AQS 留给子类开发者的“填空题”，是实现特定同步器语义的关键 。

  - `protected boolean tryAcquire(int arg)`：子类实现尝试以**独占模式**获取资源的逻辑。如果成功获取，必须返回 `true`；失败则返回 `false`。
  - `protected boolean tryRelease(int arg)`：子类实现尝试以**独占模式**释放资源的逻辑。如果本次释放操作使得等待的线程有可能被唤醒，必须返回 `true`。
  - `protected int tryAcquireShared(int arg)`：子类实现尝试以**共享模式**获取资源的逻辑。其返回值有特殊含义：负值表示获取失败；0 表示获取成功，但后续已无剩余资源；正值表示获取成功，且后续仍有剩余资源。
  - `protected boolean tryReleaseShared(int arg)`：子类实现尝试以**共享模式**释放资源的逻辑。如果本次释放可能使得等待的线程能够成功获取资源，必须返回 `true`。
  - `protected boolean isHeldExclusively()`：另一个重要的原语，主要由 `ConditionObject` 使用，用于判断当前线程是否独占地持有资源。

| **表 2: AQS 模板方法在 JUC 中的实现** |
| ------------------------------------- |
| **同步器**                            |
| `ReentrantLock`                       |
| `Semaphore`                           |
| `CountDownLatch`                      |
| `ReadWriteLock.ReadLock`              |
| `ReadWriteLock.WriteLock`             |

导出到 Google 表格

```
将 `acquire`、`release` 等模板方法声明为 `final` 是一个至关重要的设计决策 [22]。这并非随意为之，而是为了强制维持算法骨架的完整性和正确性。如果子类能够重写 `acquire` 方法，它们就可能绕过 AQS 精心设计的队列管理和线程阻塞机制，这将彻底破坏 AQS 的核心契约，并极易导致实现的同步器行为不正确、不具备可伸缩性，甚至引入难以察觉的并发 bug。

这一设计强制实现了严格的**关注点分离**。AQS 的作者 Doug Lea 已经为并发编程中最困难的部分（线程排队、阻塞、唤醒、内存可见性）提供了经过验证的、正确的、高效的实现。通过将模板方法设为 `final`，该框架迫使子类的开发者只需关注定义其特定同步器语义的状态转换逻辑。这是一种在提供强大能力的同时，也强制保障安全性的高明设计。
```

------

#### **第 4 部分：独占模式同步：`ReentrantLock` 案例研究**

`ReentrantLock` 是 AQS 在独占模式下最经典的应用。通过深入分析其实现，我们可以清晰地看到 AQS 的架构是如何被具体应用的。

- **通过 `tryAcquire` 和 `tryRelease` 实现独占访问**

  `ReentrantLock` 内部定义了 `FairSync` 和 `NonfairSync` 两个静态内部类，它们都继承自 AQS，并实现了独占模式的核心方法 。

  - `tryAcquire(int acquires)` 的实现逻辑非常清晰：它首先检查同步状态 `state`。如果 `state` 为 0，表示锁是自由的，它会尝试使用 CAS 操作将 `state` 设置为 1，并将当前线程设置为独占所有者。如果 `state` 不为 0，它会检查当前持有锁的线程是否就是当前线程，如果是，则进入重入逻辑。否则，获取失败。

- **实现可重入性：将递归深度映射到 `state` 计数**

  可重入性（Reentrancy）意味着一个已经持有锁的线程，可以再次成功获取该锁而不会被自己阻塞。AQS 的 `state` 变量为实现这一特性提供了天然的支持。

  - 当一个已经持有锁的线程再次调用 `lock()` 时，`tryAcquire` 方法会检测到调用者就是当前的锁所有者。此时，它不会阻塞，而是简单地将 `state` 计数器加 1 。这个 

    `state` 值就代表了该线程对该锁的“重入深度”。

  - 相应地，每次调用 `unlock()` 方法时，`state` 计数器会减 1。锁并不会在第一次调用 `unlock()` 时就释放，只有当 `state` 的值减到 0 时，表示线程已经退出了所有重入层级，锁才会被真正释放，并将所有者字段清空，从而允许其他线程获取该锁 。

- **`acquireQueued` 流程：线程入队与 Park/Unpark 机制**

  当一个线程调用 `lock()` 并且 `tryAcquire` 返回 `false` 时，AQS 精密的排队机制便开始启动。

  1. **`addWaiter(Node.EXCLUSIVE)`**：首先，AQS 会将当前线程封装成一个 `Node` 对象，并标记为 `EXCLUSIVE`（独占）模式。然后，通过一个基于 CAS 的自旋操作，将这个新节点安全地添加到 CLH 等待队列的尾部 。

  2. **`acquireQueued(Node node, int arg)`**：节点入队后，便进入此方法，开始在一个循环中等待获取锁。在这个循环里，节点会检查它的前驱节点是否是头节点（`head`）。如果是，意味着它现在是队列中的第一个等待者，有资格去尝试获取锁。于是它会再次调用 `tryAcquire`。

  3. **`shouldParkAfterFailedAcquire` 和 `parkAndCheckInterrupt`**：如果节点发现它的前驱不是头节点，或者它是头节点但尝试获取锁再次失败，那么它就需要被阻塞以避免浪费 CPU。在阻塞之前，AQS 会执行一个关键操作：调用 `shouldParkAfterFailedAcquire`。此方法会找到该节点的前驱节点，并尝试将其 `waitStatus` 设置为 `SIGNAL`。这个 `SIGNAL` 状态就像一个“唤醒我”的请求。只有在前驱节点的状态成功设置为 `SIGNAL` 之后，当前线程才会在下一次循环中调用 `LockSupport.park(this)` 将自己挂起，进入休眠状态 。当锁被释放时，持有锁的线程会找到队列头部的后继节点（也就是这个休眠的线程），并调用 

     `LockSupport.unpark()` 来唤醒它。

- **公平与非公平实现：`FairSync` 与 `NonfairSync` 的深度剖析**

  `ReentrantLock` 允许在构造时选择公平或非公平策略，这两种策略的核心区别就在于 `tryAcquire` 的实现上。

  - **`NonfairSync` (非公平锁)**：其 `tryAcquire` 方法非常直接。当一个新线程调用 `lock()` 时，它会首先尝试一次 CAS 操作 `compareAndSetState(0, 1)`。如果恰好此时锁是自由的，这个新线程就能立刻获得锁，成功“插队”，而无视队列中可能已经等待了很久的其他线程。这种行为被称为“闯入”（Barging）。
  - **`FairSync` (公平锁)**：其 `tryAcquire` 方法在尝试获取锁之前，会增加一个额外的检查：`hasQueuedPredecessors()`。这个方法会判断等待队列中是否存在其他等待的线程。如果存在，`tryAcquire` 会直接返回 `false`，即使锁当前是自由的。这意味着新来的线程必须乖乖排队，只有队列的头部线程才有资格获取锁 。

  这种设计上的差异直接导致了性能上的权衡，这将在第 7 部分详细讨论。

  在 `acquireQueued` 流程中，`shouldParkAfterFailedAcquire` 方法的设计展现了 AQS 的精妙之处。一个简单的实现可能会在线程获取锁失败后立即将其挂起。然而，AQS 的实现更为复杂和健壮。当一个线程 T2 决定要挂起时，它首先会找到其前驱节点 T1，并尝试将 T1 的 `waitStatus` 设置为 `SIGNAL`。只有在这次设置成功后的**下一次**循环中，T2 才会真正调用 `park()` 来挂起自己。

  这种看似繁琐的两步操作，是为了解决一个致命的竞态条件：**丢失的唤醒（Lost Wakeup）**。想象一下，如果 T2 立即挂起，而它的前驱 T1 在 T2 挂起之前的一瞬间释放了锁并尝试调用 `unpark(T2)` 来唤醒它。由于此时 T2 还没有真正执行 `park()`，这个 `unpark` 调用就无效了，信号就此丢失。当 T2 随后执行 `park()` 时，它将永远地休眠下去。通过强制要求在 `park` 之前必须先成功设置前驱节点的 `SIGNAL` 状态，T2 就为 T1 留下了一个明确的“备忘录”。T1 在释放锁时，会检查其后继节点的 `waitStatus`。如果发现是 `SIGNAL`，它就知道自己有责任去唤醒后继者。这个机制确保了释放和唤醒操作之间的安全交接，从而彻底避免了丢失唤醒的问题，这是并发编程中一个常见且极其危险的陷阱。

------

#### **第 5 部分：共享模式同步：`Semaphore` 与 `CountDownLatch` 案例研究**

共享模式是 AQS 的另一大核心功能，它允许多个线程同时访问一个同步器。`Semaphore`（信号量）和 `CountDownLatch`（倒数门闩）是共享模式的两个典型应用。

- **通过 `tryAcquireShared` 和 `tryReleaseShared` 实现共享访问**

  共享模式与独占模式的核心区别在于 `tryAcquireShared` 方法的返回值。它返回一个 `int` 类型的值，而非 `boolean`，这个返回值携带了更丰富的信息 ：

  - **负值**：表示获取失败，当前线程需要进入等待队列。
  - **零**：表示获取成功，但该同步器上已无更多可用资源，后续的共享获取请求将会失败。
  - **正值**：表示获取成功，并且该同步器上仍有剩余资源，后续的共享获取请求可能还会成功。

  这个整型返回值是实现高效共享模式的关键，它直接影响着 AQS 后续的唤醒策略。

- **案例研究 1：`Semaphore` - 使用 `state` 管理许可池**

  `Semaphore` 用于控制对一组资源的并发访问数量。

  - **初始化**：创建一个 `Semaphore` 时，会指定一个“许可”数量，这个数量被直接设置为 AQS 的初始 `state` 值 。
  - **`tryAcquireShared(int permits)`**：`Semaphore` 的 `acquire(int permits)` 方法最终会调用到 AQS 子类（如 `NonfairSync`）中的 `tryAcquireShared`。该方法在一个无限循环（自旋）中执行：首先读取当前的 `state`（可用许可数），计算出获取指定数量 `permits` 后的剩余值。如果剩余值为负（许可不足），则直接返回负值表示失败。否则，它会使用 CAS 操作尝试将 `state` 更新为这个剩余值。如果 CAS 成功，它会返回这个非负的剩余值，表示获取成功 。
  - **`tryReleaseShared(int permits)`**：`Semaphore` 的 `release(int permits)` 方法则调用 `tryReleaseShared`。该方法同样在一个 CAS 自旋中，原子性地将释放的 `permits` 数量加回到 `state` 中 。

- **案例研究 2：`CountDownLatch` - 使用 `state` 实现一次性屏障**

  `CountDownLatch` 是一种非常有用的一次性（one-shot）屏障，它允许一个或多个线程等待，直到其他一组线程完成操作。

  - **初始化**：`CountDownLatch` 在构造时会指定一个计数值，这个值就是 AQS 的初始 `state` 。
  - **`await()`**：等待线程调用 `await()` 方法，该方法内部会调用 AQS 的 `acquireSharedInterruptibly`。`CountDownLatch` 内部 `Sync` 类实现的 `tryAcquireShared` 逻辑极其简单：检查 `getState()` 是否为 0。如果是，返回 1（表示获取成功，门闩已打开）；如果不是，返回 -1（表示获取失败，需要等待）。
  - **`countDown()`**：执行操作的线程每完成一个任务就调用 `countDown()`，该方法内部调用 AQS 的 `releaseShared`。`CountDownLatch` 的 `tryReleaseShared` 逻辑是：在一个 CAS 循环中将 `state` 减 1。如果减 1 后的新值为 0，它就返回 `true`，这会触发 AQS 唤醒所有等待的线程。由于 `state` 只能减少，不能增加，所以 `CountDownLatch` 是一次性的，无法重置 。

- **`doReleaseShared` 与 `setHeadAndPropagate` 机制：确保级联唤醒**

  这是共享模式实现高性能的关键所在，也是其与独占模式在释放逻辑上的根本不同。

  - 当一个线程调用 `releaseShared` 并成功（`tryReleaseShared` 返回 `true`）后，AQS 会调用 `doReleaseShared` 方法。
  - 与独占模式的 `release` 只唤醒一个后继节点不同，`doReleaseShared` 在唤醒队列头部的后继节点后，并不会立即停止。
  - 它会检查是否还有剩余的共享资源（通过再次调用 `tryAcquireShared` 判断），或者检查被唤醒的节点的 `waitStatus` 是否需要传播。如果需要继续唤醒，它会通过 `setHeadAndPropagate` 方法，将新的头节点（即刚刚被唤醒的节点）的 `waitStatus` 设置为 `PROPAGATE`。
  - 这个 `PROPAGATE` 状态是一个重要的信号。当这个新被唤醒的线程自己成功获取资源并成为新的头节点后，它会检查自己的 `waitStatus`。如果发现是 `PROPAGATE`，它就有责任继续唤醒它的后继节点，从而形成一个“级联唤醒”的效应。

  `SIGNAL` 状态可以理解为一个直接的、一对一的唤醒契约：“我释放了资源，所以我负责唤醒你”。而 `PROPAGATE` 状态则是一个可传递的、一对多的唤醒信号，它的语义是：“一次共享释放发生了，并且可能还有更多资源可用，所以无论谁成为新的队列头，都有责任将唤醒的链条继续下去”。

  这个精巧的机制对于最大化共享模式同步器的吞吐量至关重要。如果没有它，在一个拥有大量许可的 `Semaphore` 和众多等待线程的场景下，一次 `releaseShared` 可能只会唤醒一个线程。这个线程执行完后，又需要再次释放才能唤醒下一个，这会使并行的操作退化为串行。`PROPAGATE` 机制将唤醒过程本身变成了一个并发的、如波浪般传播的过程，这是一种更具可伸缩性和性能的卓越设计，完全符合 Doug Lea 的设计哲学 。

------

#### **第 6 部分：使用条件队列进行高级协调**

除了提供锁机制，AQS 还通过其内部类 `ConditionObject` 提供了 `Condition` 接口的实现，这是一种比 `Object` 的 `wait/notify` 机制更强大、更灵活的线程间通信方式。

- **`ConditionObject` 内部类**

  `ConditionObject` 是 AQS 对 `java.util.concurrent.locks.Condition` 接口的实现 。它允许线程在满足某个前提条件（例如获取锁）后，因为某个业务条件（例如队列为空）尚未满足而暂停执行，并等待其他线程满足该业务条件后发来通知。这与等待锁本身被释放是两个完全不同的概念。

- **双队列模型：AQS 同步队列与条件等待队列**

  理解 `Condition` 的关键在于理解其背后的双队列模型。

  - **同步队列 (Sync Queue)**：即前面章节讨论的 AQS 核心的 CLH 等待队列。所有等待获取锁的线程都在这个队列中排队。
  - **条件队列 (Condition Wait Queue)**：每个 `ConditionObject` 实例都维护着一个独立的、私有的等待队列。这个队列是一个简单的单向链表，用于存放调用了该 `Condition` 对象的 `await()` 方法而被挂起的线程。

  一个线程在任何时刻只能存在于这两个队列中的一个。

- **`await()` 的生命周期：释放锁、等待与重新获取**

  当一个线程调用 `condition.await()` 方法时，它会经历一个严谨且复杂的过程 ：

  1. **前提检查**：调用 `await()` 的线程必须已经持有与该 `Condition` 绑定的独占锁。
  2. **入队并释放锁**：`await()` 方法会原子性地执行两个操作：首先，将当前线程封装成一个节点（`waitStatus` 为 `CONDITION`）加入到条件队列的尾部；然后，它会**完全释放**当前线程持有的锁（通过调用 AQS 的 `release()` 方法，将 `state` 置为 0）。释放锁是至关重要的一步，因为它允许其他线程有机会获取锁，进而修改那个正在被等待的业务条件。
  3. **挂起等待**：释放锁之后，当前线程会调用 `LockSupport.park()` 将自己挂起，静静地在条件队列中等待信号。
  4. **接收信号并转移**：当其他线程调用了该 `Condition` 的 `signal()` 或 `signalAll()` 方法后，这个等待的节点会被从条件队列中移除，并被转移到 AQS 的**同步队列**的尾部。
  5. **重新竞争锁**：此时，被唤醒的线程和其他正在等待锁的线程一样，在同步队列中排队，重新竞争获取锁。
  6. **返回**：只有当该线程再次成功获取到锁之后，`await()` 方法才会返回。

- **`signal()` 与 `signalAll()` 机制：将节点转移至同步队列**

  `signal()` 和 `signalAll()` 的作用不是直接唤醒线程，而是将其从“等待条件”的状态，转变为“等待锁”的状态。

  - `signal()`：此方法会从条件队列的头部取出一个（等待时间最长的）节点，并将其转移到 AQS 同步队列的尾部。被转移的线程并不会立即被 `unpark`，它只是获得了重新排队竞争锁的资格 。
  - `signalAll()`：此方法会将条件队列中的**所有**节点，一次性地全部转移到 AQS 同步队列中 。

  “惊群效应”（Thundering Herd）问题是使用 `signalAll()` 时需要考虑的一个性能问题。当 `signalAll()` 被调用时，所有在条件队列中等待的线程都会被转移到同步队列中，并最终被一一唤醒。然而，通常只有一个线程能够成功获取锁并改变状态。其他被唤醒的线程在获取锁后，会发现它们等待的条件仍然不满足（或者已经被第一个幸运儿改变了），于是它们只好再次调用 `await()` 重新进入休眠状态。这个过程涉及大量的、非必要的上下文切换和锁竞争，效率低下。

  因此，`signal()` 和 `signalAll()` 的选择是一个需要审慎考虑的权衡。如果任何一个等待的线程被唤醒后都能继续工作，那么使用 `signal()` 会更高效。如果多个线程被唤醒后都有可能继续工作，或者线程们在等待不同的子条件，那么使用 `signalAll()` 则是必须的，以保证正确性。AQS 提供了这两种工具，但开发者必须理解其背后的性能和正确性含义。AQS 的设计，通过将线程转移到同步队列而不是直接唤醒，在一定程度上序列化了锁的重新获取过程，缓解了惊群效应的冲击，但问题的根源仍然需要开发者在应用层面进行规避。

------

#### **第 7 部分：性能、权衡与设计理念**

AQS 不仅是一个功能强大的框架，更是一个在性能、公平性和灵活性之间做出精妙权衡的工程杰作。理解这些权衡是高效使用 AQS 的关键。

- **吞吐量 vs. 公平性：定量与定性分析**

  AQS 提供的最直接的权衡之一就是在公平与非公平锁之间进行选择。

  - **非公平锁的“闯入”优势**：默认的非公平锁允许一个新到达的线程“闯入”并获取一个刚刚被释放的锁，即使等待队列中已经有其他线程等待了很长时间 。这种策略通常能带来更高的整体吞吐量。原因是，那个闯入的线程当前正在 CPU 上运行，获取锁无需进行线程上下文切换；而唤醒一个在队列中休眠的线程，则需要一次昂贵的上下文切换。
  - **公平锁的饥饿风险与应用场景**：非公平策略的代价是可能导致“饥饿”（Starvation），即队列头部的线程可能被后续源源不断闯入的线程反复超越，导致长时间无法获得锁。公平锁通过 `hasQueuedPredecessors()` 检查，强制新来的线程排队，确保了严格的 FIFO 获取顺序，从而杜绝了饥饿现象 。但这牺牲了性能，因为它增加了上下文切换的概率。
  - **结论**：AQS 及其实现（如 `ReentrantLock`）默认采用非公平策略是有充分理由的：在绝大多数应用场景中，整体系统的高吞吐量比严格的线程获取顺序更重要 。公平锁是一个专用工具，适用于那些公平性是功能性需求（而不仅仅是期望）的场景。

| **表 3: 公平与非公平锁定策略对比** |
| ---------------------------------- |
| **特性**                           |
| **吞吐量**                         |
| **获取顺序**                       |
| **饥饿问题**                       |
| **典型用例**                       |

导出到 Google 表格

- **性能剖析：`ReentrantLock` vs. `synchronized` 在不同 JVM 版本下的表现**

  - **历史背景**：在 Java 5 时代，`ReentrantLock` 的性能显著优于 `synchronized` 。

  - **现代 JVM 的优化**：从 Java 6 开始，JVM 对 `synchronized` 关键字进行了大量的底层优化，引入了偏向锁（Biased Locking）、轻量级锁（Lightweight Locking）、锁消除（Lock Elision）和自适应自旋（Adaptive Spinning）等技术。这些优化使得 `synchronized` 的性能得到了巨大提升，在低竞争场景下，其性能甚至可能反超 `ReentrantLock` 。

  - **高竞争场景**：在线程竞争激烈的情况下，`ReentrantLock` 通常仍能保持性能优势。这得益于其更精密的、基于 AQS 的队列管理机制，相比 JVM 内部的监视器锁（monitor）实现，其可伸缩性更好 。

  - **结论**：现代 Java 开发中，选择 `ReentrantLock` 还是 `synchronized`，不应再单纯地基于性能臆断，因为性能表现高度依赖于具体的应用场景和竞争程度 。更合理的决策依据是

    **功能需求**：当你需要 `ReentrantLock` 提供的 `synchronized` 所不具备的高级功能时（如可中断的锁等待、带超时的锁等待、公平性选择、或与多个 `Condition` 对象协同工作），就应该选择 `ReentrantLock`。在仅需基本互斥同步的简单场景下，`synchronized` 关键字由于其语法简洁、不易出错的特点，通常是更佳的选择 。

- **Doug Lea 的设计理念：可伸缩性、效率与灵活性**

  通过研读 Doug Lea 的经典论文《The java.util.concurrent Synchronizer Framework》，可以更深刻地理解 AQS 背后的设计哲学 。

  - **首要目标：可伸缩性 (Scalability)**。AQS 的设计旨在即使在高竞争环境下也能保持高效。同步开销应与等待线程的数量无关，保持为一个常数。这主要通过基于 CAS 的无锁队列操作和避免让等待线程自旋来实现。
  - **资源平衡**。设计在 CPU 时间、内存总线流量和线程调度开销之间寻求一种务实的平衡。它是一个工程上的解决方案，而非纯理论模型 。
  - **包容公平性**。框架被明确设计为不强制推行任何一种公平策略。它通过提供 `hasQueuedPredecessors()` 等钩子方法，允许开发者自行实现公平同步器，并清晰地认识到这背后是吞吐量与公平性之间的权衡 。
  - **灵活性与可重用性**。最终目标是创建一个小巧而强大的框架，能够作为绝大多数同步器的实现基础，从而促进代码重用和整个并发库的一致性 。

------

#### **第 8 部分：结论：AQS 的不朽遗产**

- **AQS 对 Java 并发编程的贡献总结**

  `AbstractQueuedSynchronizer` 无疑是 Java 并发库中最卓越的工程杰作之一。它为构建各种同步原语提供了一个健壮、可伸缩且极其灵活的基础框架。其核心贡献可以总结为：

  - 通过**机制与策略分离**的设计原则，极大地简化了新型同步器的开发。
  - 通过**基于 CAS 的原子状态管理**，提供了高效、无锁的状态更新机制。
  - 通过**精巧的 CLH 变体等待队列**，实现了可伸缩的线程排队和调度。

  AQS 的出现，不仅催生了 `java.util.concurrent` 包中一系列高质量的并发工具，更重要的是，它为整个 Java 社区提供了一种思考和构建并发控制组件的标准化范式。

- **实现自定义同步器的常见陷阱与最佳实践**

  尽管 AQS 强大，但构建自定义同步器是一项专家级的任务，充满了陷阱。

  - **陷阱 1：错误的 `tryRelease` 逻辑**。一个常见的错误是 `tryRelease` 的返回值不符合契约。如果错误地返回 `true`，可能导致不必要的线程唤醒，降低性能；如果错误地返回 `false`，则可能导致等待的线程永远无法被唤醒，造成“线程卡死”。
  - **陷阱 2：破坏 `Condition` 契约**。调用 `await()` 的线程必须持有锁，调用 `signal()` 的线程也必须持有锁。违反此规定将抛出 `IllegalMonitorStateException` 。
  - **陷阱 3：忘记 `finally` 代码块**。与 `synchronized` 不同，使用 `ReentrantLock` 等基于 AQS 的锁时，必须将 `unlock()` 调用放在 `finally` 块中。这是为了确保即使在 `try` 块中发生异常，锁也一定会被释放，从而避免死锁 。这是一个极易被忽视但后果严重的错误。
  - **最佳实践**：**优先使用 JUC 提供的标准同步器**。在绝大多数情况下，`ReentrantLock`、`Semaphore`、`CountDownLatch`、`ReadWriteLock` 等已经能够满足需求。只有在遇到标准库无法解决的、独特的、且被充分理解的并发问题时，才应考虑构建自定义同步器。这是一条需要高度审慎和专业知识的道路 。

`AbstractQueuedSynchronizer` 的设计和实现，集中体现了现代并发编程的智慧，它将复杂的底层细节完美封装，同时向上层暴露了清晰、强大且灵活的扩展点。对于任何希望深入理解 Java 并发机制的开发者而言，AQS 都是一座必须翻越且值得探索的高峰。