# 什么是双亲委派机制？

双亲委派机制是Java虚拟机（JVM）在加载类时使用的一种机制。它的核心思想是：**当一个类加载器（ClassLoader）收到加载类的请求时，它不会自己先去尝试加载，而是把这个请求委托给父类加载器去完成。每一层的类加载器都是如此，因此所有的加载请求最终都会被传送到顶层的启动类加载器（Bootstrap ClassLoader）。只有当父加载器在其搜索范围内找不到所需的类，并且反馈无法完成加载时，子加载器才会自己去尝试加载。**

## 类加载器的层次结构

Java中默认有三种主要的类加载器：

1. **启动类加载器 (Bootstrap ClassLoader)**:
   - 这是最顶层的加载器，由C++实现，是JVM自身的一部分。
   - 它负责加载Java的核心库（`JAVA_HOME/jre/lib/rt.jar`、`resources.jar`等），也就是我们最常用的`java.lang.*`等包下的类。
2. **扩展类加载器 (Extension ClassLoader)**:
   - 它负责加载`JAVA_HOME/jre/lib/ext`目录下的，或者被`java.ext.dirs`系统变量所指定的路径中的所有类库。
3. **应用程序类加载器 (Application ClassLoader)**:
   - 也称为系统类加载器（System ClassLoader）。它负责加载用户类路径（Classpath）上所指定的类库。我们自己编写的Java代码，默认就是由它来加载的。

这三者之间以及我们自定义的类加载器（Custom ClassLoader）通常存在着如下的父子关系（注意，这并非继承关系，而是组合关系）：

```
      Bootstrap ClassLoader
              ^
              | (父)
      Extension ClassLoader
              ^
              | (父)
    Application ClassLoader
              ^
              | (父)
      Custom ClassLoader
```

## 为什么需要双亲委派？

1. **避免类的重复加载**：通过委派给父加载器，可以确保一个类只会被一个加载器加载一次。例如，无论哪个加载器尝试加载 `java.lang.String`，最终都会被委派给顶层的启动类加载器，从而保证了 `String` 类在JVM中的唯一性。
2. **保证安全性**：防止核心API库被随意篡改。如果没有这个机制，黑客就可以编写一个自定义的 `java.lang.String` 类，并用自己的类加载器去加载它，这可能会引发严重的安全问题。双亲委派机制确保了核心类库始终由启动类加载器加载，外部代码无法替代。

## 源码分析 (`java.lang.ClassLoader`)

双亲委派机制的实现逻辑主要封装在 `ClassLoader` 的 `loadClass()` 方法中。以下是简化后的源码逻辑：

```java
// java.lang.ClassLoader
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 1. 检查这个类是否已经被加载过了
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                // 2. 如果没有被加载，则委托给父加载器去加载
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    // 如果父加载器是null，说明父加载器是Bootstrap ClassLoader
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 父加载器抛出异常，说明在父加载器的路径下没有找到这个类
            }

            if (c == null) {
                // 3. 如果父加载器无法加载，再调用自己的findClass()方法进行加载
                long t1 = System.nanoTime();
                c = findClass(name);

                // ... 省略部分代码
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

从源码可以清晰地看到委派流程：**检查已加载 -> 委派父加载器 -> 自己加载 (`findClass`)**。

## 如何打破双亲委派机制？

从上面的源码分析可知，双亲委派的核心逻辑完全在 `loadClass()` 方法中。因此，**打破双亲委派机制最直接的方法就是重写 `loadClass()` 方法，在其中改变原有的加载顺序。**

下面，我将用一个代码示例来演示如何创建一个“不守规矩”的类加载器。

```java
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * 自定义类加载器，用于打破双亲委派模型。
 */
class MyClassLoader extends ClassLoader {

    // 自定义类加载器的类文件存放路径
    private String classPath;

    public MyClassLoader(String classPath) {
        this.classPath = classPath;
    }

    /**
     * 重写loadClass方法，这是打破双亲委派模型的关键。
     * 这里的逻辑是：
     * 1. 先检查我们自定义的加载器是否已经加载过这个类。
     * 2. 如果没有，则优先尝试用我们自己的findClass方法加载。
     * 3. 如果我们自己加载失败（比如在我们的路径下找不到.class文件），
     * 再“无奈地”委托给父加载器去加载。
     * 这就打破了“先委派，后加载”的原则。
     */
    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // 1. 检查该类是否已经被加载
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                // 2. 优先尝试使用我们自己的加载逻辑
                try {
                    // 判断是否是我们需要加载的特定类（避免加载系统类）
                    // 这里我们只处理我们自己定义的类，对于Java核心库的类，还是交给父加载器
                    if (name.startsWith("com.example")) { 
                        c = findClass(name);
                    }
                } catch (ClassNotFoundException e) {
                    // 自己加载失败，忽略异常
                }

                // 3. 如果我们自己加载失败，或者不是我们想要加载的类，再委托给父加载器
                if (c == null) {
                    // 调用父加载器的loadClass，遵循正常的委派流程
                    c = getParent().loadClass(name);
                }
            }
            
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }


    /**
     * 重写findClass方法，定义如何根据类的名称找到对应的.class文件并加载它。
     *
     * @param name 类的完全限定名 (e.g., "com.example.MyTestClass")
     * @return 加载后的Class对象
     * @throws ClassNotFoundException 如果找不到类文件
     */
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            // 将包名转换为文件路径 (e.g., "com.example.MyTestClass" -> "/path/to/classes/com/example/MyTestClass.class")
            String fileName = name.replace('.', File.separatorChar) + ".class";
            String filePath = this.classPath + File.separator + fileName;
            
            File classFile = new File(filePath);
            if (!classFile.exists()) {
                throw new ClassNotFoundException("Class not found: " + name);
            }

            // 读取.class文件的字节码
            byte[] classBytes = loadClassBytes(classFile);
            if (classBytes == null || classBytes.length == 0) {
                throw new ClassNotFoundException("Cannot load class: " + name);
            }

            // 调用defineClass方法，将字节码转换为Class对象
            // 这是ClassLoader的核心方法，用于将字节数组转换成Class实例
            return defineClass(name, classBytes, 0, classBytes.length);

        } catch (IOException e) {
            throw new ClassNotFoundException("Error finding class " + name, e);
        }
    }

    /**
     * 辅助方法，用于从.class文件中读取字节码。
     */
    private byte[] loadClassBytes(File file) throws IOException {
        try (InputStream in = new FileInputStream(file);
             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            
            byte[] buffer = new byte[1024];
            int len;
            while ((len = in.read(buffer)) != -1) {
                baos.write(buffer, 0, len);
            }
            return baos.toByteArray();
        }
    }
}


/**
 * 主测试类
 * 运行前请先手动编译 MyTestClass.java 并将其.class文件放到指定目录。
 * * 步骤:
 * 1. 创建一个目录, 例如 D:/temp/classes/com/example/
 * 2. 创建一个 MyTestClass.java 文件:
 * package com.example;
 * public class MyTestClass {
 * public void sayHello() {
 * System.out.println("Hello from MyTestClass! Loaded by: " + this.getClass().getClassLoader());
 * }
 * }
 * 3. 编译它: javac MyTestClass.java
 * 4. 将生成的 MyTestClass.class 文件移动到 D:/temp/classes/com/example/ 目录下。
 * 5. 运行本文件 (BreakDelegationDemo.java)。
 */
public class BreakDelegationDemo {
    public static void main(String[] args) throws Exception {
        // 定义我们自定义类加载器的加载路径
        String classPath = "D:/temp/classes"; // 请替换为你自己的路径

        // 创建自定义类加载器实例
        MyClassLoader myClassLoader = new MyClassLoader(classPath);

        // 使用自定义类加载器加载类
        // 注意，类的全限定名要正确
        String className = "com.example.MyTestClass";
        Class<?> myTestClass = myClassLoader.loadClass(className);

        // 创建实例并调用方法
        Object instance = myTestClass.getDeclaredConstructor().newInstance();
        myTestClass.getMethod("sayHello").invoke(instance);

        // 打印出加载该类的类加载器，验证是否是我们的自定义加载器
        System.out.println("Class loaded by: " + myTestClass.getClassLoader());
        System.out.println("Parent of myClassLoader: " + myClassLoader.getParent());

        // 对比：如果用系统默认加载器加载，会是什么结果？
        // System.out.println("AppClassLoader: " + ClassLoader.getSystemClassLoader());
        // Class.forName(className); // 这会使用AppClassLoader加载
    }
}
```

