# 不同JDK版本中字符串常量池的演进

字符串常量池（String Constant Pool）是Java中一个非常重要的概念，它用于存储字符串字面量和通过`String.intern()`方法添加的字符串。其在内存中的位置随着JDK版本的更迭发生了几次关键变化，这些变化主要影响了内存管理和性能。

### JDK 6 及更早版本

在JDK 6以及之前的版本中，字符串常量池位于 **方法区（Method Area）** 的一个特定部分，即 **永久代（Permanent Generation, PermGen）**。

- **位置**: 永久代（PermGen）。
- **特点**:
  - 永久代是方法区的一种实现，它拥有**固定大小**的内存空间，可以通过JVM参数 `-XX:PermSize` 和 `-XX:MaxPermSize` 进行设置。
  - 这块内存区域的垃圾回收（GC）条件非常苛刻，效率也较低。
- **主要问题**:
  - 由于永久代大小固定，如果程序在运行时动态生成并`intern()`了大量字符串（例如，通过循环调用`String.intern()`），很容易将永久代填满，从而抛出 `java.lang.OutOfMemoryError: PermGen space` 异常，导致应用崩溃。这在需要处理大量动态字符串的场景中是一个常见的痛点。

### JDK 7

JDK 7版本对字符串常量池的位置做出了一个里程碑式的改动：将其从永久代移动到了 **Java堆（Java Heap）** 中。

- **位置**: Java堆（Heap）。
- **特点**:
  - 字符串常量池不再占用独立的永久代空间，而是和普通的Java对象一样，在堆内存中分配。
  - 这意味着字符串常量池的大小受整个堆大小（通过 `-Xmx` 参数设置）的限制，空间更加灵活和宽裕。
  - 堆中的字符串可以被常规的垃圾回收器（如Minor GC和Major GC）高效地管理和回收。
- **带来的好处**:
  - 极大地降低了因字符串过多而导致 `PermGen space` 内存溢出的风险。
  - `String.intern()` 方法的实现也发生了变化。如果一个字符串已经存在于堆中，`intern()`会直接返回堆中该对象的引用，而不会在永久代中再创建一个副本。

#### 代码示例分析 (JDK 6 vs JDK 7)

考虑以下代码：

```java
String s1 = new StringBuilder("ja").append("va").toString();
String s2 = s1.intern();
String s3 = "java";

System.out.println(s1 == s3); // 在JDK 6和JDK 7+中结果不同
System.out.println(s2 == s3); // 结果始终为true
```

- **在 JDK 6 中**:
  1. `s1` 指向堆中一个新建的 "java" 字符串对象。
  2. `s1.intern()` 被调用时，JVM发现在字符串常量池（位于PermGen）中还没有 "java" 这个字符串。于是，它会在**PermGen中创建一个新的 "java" 字符串**，并让`s2`指向它。
  3. `s3` 指向的是常量池中的 "java" 字符串。
  4. 因此，`s1` 指向堆，而 `s3` 指向永久代，地址不同。**结果为 `false`**。
- **在 JDK 7/8+ 中**:
  1. `s1` 同样指向堆中一个新建的 "java" 字符串对象。
  2. `s1.intern()` 被调用时，JVM发现字符串常量池（现在位于堆中）里没有 "java"。于是，它**不会在堆中再创建一个新的 "java" 对象**，而是会将 `s1` 的引用直接记录到常量池中，并返回这个引用。
  3. `s3` 在初始化时，会去常量池查找，此时会直接获取到上一步存入的 `s1` 的引用。
  4. 因此，`s1` 和 `s3` 指向的是堆中同一个对象。**结果为 `true`**。

### JDK 8 及更高版本

JDK 8移除了永久代（PermGen），取而代之的是 **元空间（Metaspace）**，它使用的是本地内存（Native Memory）。

- **位置**: 字符串常量池**仍然在Java堆（Heap）**中。
- **特点**:
  - JDK 8的主要变化是方法区的实现方式变了（元空间取代了永久代），但这并**没有影响**在JDK 7中已经迁移到堆里的字符串常量池。
  - 所以，从JDK 7开始，字符串常量池的位置和行为基本保持一致，一直延续到最新的JDK版本。
  - 元空间的引入主要是为了解决永久代大小固定、容易溢出的问题，它默认可以动态扩展，只受限于可用的本地内存。

### 总结对比

| JDK 版本         | 字符串常量池位置     | 主要特点和影响                                               |
| ---------------- | -------------------- | ------------------------------------------------------------ |
| **JDK 6 及更早** | **永久代 (PermGen)** | 空间大小固定，GC效率低。大量使用`intern()`容易导致 `OutOfMemoryError: PermGen space`。 |
| **JDK 7**        | **Java 堆 (Heap)**   | 移至堆区，空间更灵活，受GC统一管理。大大降低了内存溢出的风险，`intern()`行为发生改变。 |
| **JDK 8 及更高** | **Java 堆 (Heap)**   | 位置与JDK 7保持一致。永久代被元空间（Metaspace）取代，但字符串常量池仍在堆中，行为没有变化。 |

总而言之，将字符串常量池从永久代迁移到堆区是Java内存管理方面的一项重要优化，它解决了长期困扰开发者的`PermGen space`问题，使得字符串的使用更加安全和高效
