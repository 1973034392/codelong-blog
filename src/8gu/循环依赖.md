# 什么是循环依赖？

循环依赖，顾名思义，就是两个或多个Bean之间相互依赖，形成一个闭环。最简单的形式是两个Bean互相依赖：

- **Bean A** 依赖 **Bean B**。
- **Bean B** 又反过来依赖 **Bean A**。

用代码表示就是：

```java
@Component
public class BeanA {
    @Autowired
    private BeanB beanB;
}

@Component
public class BeanB {
    @Autowired
    private BeanA beanA;
}
```

当Spring容器启动并尝试创建这两个Bean时，就会遇到一个难题：

1. 要创建`BeanA`，必须先注入`BeanB`。
2. 要获取`BeanB`，必须先创建`BeanB`。
3. 要创建`BeanB`，又必须先注入`BeanA`。
4. 这样就形成了一个“先有鸡还是先有蛋”的死循环。

## Spring如何解决循环依赖？

很多人会惊讶地发现，上面那个例子在Spring中居然可以正常运行！这是因为Spring设计了一套精巧的机制来解决**单例（Singleton）作用域下，基于setter或字段注入**的循环依赖问题。

这个机制的核心是**三级缓存（Three-Level Cache）**。

你可以把这三级缓存想象成三个不同状态的Bean“加工车间”：

1. **一级缓存 (`singletonObjects`)：成品车间**
   - **作用**：存放已经**完全初始化好**的Bean实例。这些Bean已经经历了完整的生命周期，可以直接使用。
   - **类型**：`Map<String, Object>`
2. **二级缓存 (`earlySingletonObjects`)：半成品车间**
   - **作用**：存放**早期暴露**的Bean实例。这些Bean已经被实例化，但可能尚未完成属性注入和初始化。它存在的意义是，如果一个Bean需要被AOP代理，那么其他Bean获取到的早期引用就应该是代理后的对象，而不是原始对象。
   - **类型**：`Map<String, Object>`
3. **三级缓存 (`singletonFactories`)：原材料车间**
   - **作用**：存放用于创建早期Bean实例的**工厂（ObjectFactory）**。当一个Bean被实例化但尚未初始化时，Spring会创建一个工厂并放入三级缓存。这个工厂的`getObject()`方法被调用时，才会真正创建并返回一个“早期引用”的Bean。如果需要AOP，代理的创建就在这个工厂里完成。
   - **类型**：`Map<String, ObjectFactory<?>>`

### 解决流程（A、B循环依赖为例）：

让我们一步步跟踪Spring如何利用这三级缓存来打破循环：

1. **创建BeanA**：
   - 容器尝试从一级缓存获取`BeanA`，没找到。
   - 容器开始创建`BeanA`，并将其标记为“正在创建中”。
   - **实例化`BeanA`**：通过构造函数创建一个`BeanA`的原始对象（此时`beanB`属性为`null`）。
   - **暴露早期引用**：Spring并**不直接**将这个原始对象放入二级缓存，而是创建一个`ObjectFactory`（可以理解为一个lambda表达式 `() -> getEarlyBeanReference(...)`），并以`"beanA"`为键存入**三级缓存 (`singletonFactories`)**。这个工厂的作用是，如果需要，它可以返回`BeanA`的早期引用（可能是原始对象，也可能是代理对象）。
2. **注入BeanB到BeanA**：
   - Spring开始为`BeanA`填充属性，发现它需要`BeanB`。
   - 容器尝试获取`BeanB`。
3. **创建BeanB**（这个过程与创建`BeanA`类似）：
   - 容器从一级缓存获取`BeanB`，没找到。
   - 开始创建`BeanB`，标记为“正在创建中”。
   - **实例化`BeanB`**，创建一个原始对象（此时`beanA`属性为`null`）。
   - 同样，为`BeanB`创建一个`ObjectFactory`并存入**三级缓存**。
4. **注入BeanA到BeanB（关键一步）**：
   - Spring为`BeanB`填充属性，发现它需要`BeanA`。
   - 容器尝试获取`BeanA`。
   - **检查缓存**：
     - 首先在一级缓存（成品）中查找`beanA`，没找到。
     - 然后检查`beanA`是否“正在创建中”，发现是的！
     - 于是在二级缓存（半成品）中查找`beanA`，还是没找到。
     - 最后，在**三级缓存（原材料）**中查找`beanA`的工厂，**找到了！**
5. **打破循环**：
   - Spring从三级缓存中获取到`beanA`的`ObjectFactory`。
   - 调用该工厂的`getObject()`方法，生成一个`BeanA`的**早期引用**（如果需要AOP，此时会创建代理）。
   - 这个早期引用被放入**二级缓存 (`earlySingletonObjects`)**，并从三级缓存中移除对应的工厂。
   - `BeanB`成功获取到了`BeanA`的早期引用，并完成了自己的属性注入。
6. **完成BeanB的创建**：
   - `BeanB`继续执行其后续的初始化流程（如`@PostConstruct`等）。
   - 一个**完全初始化**的`BeanB`诞生了！
   - 这个完整的`BeanB`被放入**一级缓存 (`singletonObjects`)**。
7. **返回并完成BeanA的创建**：
   - 现在，`BeanA`终于等到了它所依赖的`BeanB`（从一级缓存中获取）。
   - `BeanA`完成了属性注入。
   - `BeanA`继续执行其后续初始化流程。
   - 一个**完全初始化**的`BeanA`也诞生了！
   - 这个完整的`BeanA`被放入**一级缓存**（替换掉之前可能存在的早期引用）。

至此，循环依赖被成功解决。核心思想就是**提前暴露一个未完成初始化的Bean的引用**。

## Spring无法解决的循环依赖

并非所有循环依赖都能被解决。以下两种情况是Spring无能为力的：

1. **构造器注入（Constructor Injection）的循环依赖**
   - **原因**：当使用构造器注入时，对象的创建和依赖的注入是**原子操作**。必须在调用构造函数时就提供所有依赖。这意味着在`new BeanA(beanB)`时，`beanB`必须已经是一个完整的实例。在循环依赖的场景下，这显然无法做到，因为`new BeanB(beanA)`同样需要一个完整的`beanA`。对象无法被实例化，三级缓存机制也无从谈起。
   - **结果**：Spring会直接抛出`BeanCurrentlyInCreationException`异常。
2. **原型作用域（Prototype Scope）的循环依赖**
   - **原因**：Spring容器**不缓存**原型Bean。每次请求都会创建一个全新的实例，并且Spring不会管理其完整的生命周期（特别是销毁阶段）。因此，无法通过缓存来提前暴露引用，从而打破循环。
   - **结果**：同样会抛出`BeanCurrentlyInCreationException`。



## 如何处理和避免循环依赖？

虽然Spring能够处理某些循环依赖，但这通常被认为是**代码设计不良的信号（Code Smell）**。它表明你的类职责划分不清，耦合度过高。

**最佳实践是避免它，而不是依赖Spring去解决它。**

1. **重新设计和重构（最佳方案）**

   - 审视你的类设计。A和B是否真的需要直接相互引用？
   - **提取新类**：将两个Bean共享的逻辑提取到一个新的第三个类C中，让A和B都依赖C。
   - **使用接口**：面向接口编程，降低耦合度，有时也能帮助理清依赖关系。

2. **使用 `@Lazy` 注解**

   - 在注入点使用`@Lazy`注解可以打破循环。

     ```java
     @Component
     public class BeanA {
         @Autowired
         @Lazy // 关键点
         private BeanB beanB;
     }
     ```

   - **原理**：Spring在注入`beanB`时，不会立即去获取`BeanB`的实例，而是会创建一个`BeanB`的**代理对象**注入给`BeanA`。只有当`BeanA`第一次实际调用`beanB`的方法时，这个代理对象才会真正去容器中获取`BeanB`的实例来执行方法。这相当于推迟了依赖的获取，从而打破了创建时的循环。

3. **使用 Setter/Field 注入**

   - 如前所述，确保你的循环依赖是基于setter或字段注入的，而不是构造器注入。

4. **实现 `ApplicationContextAware` 或使用 `@PostConstruct`**

   - 这是一种更手动的解决方案。你可以不通过`@Autowired`注入，而是让Bean实现`ApplicationContextAware`接口，在容器设置好`ApplicationContext`后，手动调用`applicationContext.getBean()`来获取依赖。或者在`@PostConstruct`标记的方法中手动获取。这种方法破坏了IoC的原则，不推荐使用。

## 总结

| 依赖注入方式         | 作用域        | 是否能解决 | 原因                                   |
| -------------------- | ------------- | ---------- | -------------------------------------- |
| **Setter/Field注入** | **Singleton** | ✅ **能**   | 通过三级缓存和提前暴露早期引用。       |
| **Constructor注入**  | Singleton     | ❌ **不能** | 无法实例化对象，依赖需要在构造时就绪。 |
| 任何方式             | **Prototype** | ❌ **不能** | 不缓存Bean，无法提前暴露引用。         |

希望这个详细的解释能帮助你彻底理解Spring中的循环依赖问题！
