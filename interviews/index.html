<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.24" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.94" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"个人面经分享","image":[""],"dateModified":"2025-09-07T13:51:42.000Z","author":[{"@type":"Person","name":"CodeLong","url":"codelong.top"}]}</script><meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/interviews/"><meta property="og:site_name" content="CodeLong"><meta property="og:title" content="个人面经分享"><meta property="og:description" content="个人面经分享 我将在这里分享我的面试经历并附加Gemini AI的相关回答,这是我的简历"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2025-09-07T13:51:42.000Z"><meta property="article:modified_time" content="2025-09-07T13:51:42.000Z"><title>个人面经分享 | CodeLong</title><meta name="description" content="个人面经分享 我将在这里分享我的面试经历并附加Gemini AI的相关回答,这是我的简历">
    <link rel="preload" href="/assets/style-vl06K0q0.css" as="style"><link rel="stylesheet" href="/assets/style-vl06K0q0.css">
    <link rel="modulepreload" href="/assets/app-CMkao8yc.js"><link rel="modulepreload" href="/assets/index.html-Dinv6d8Z.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-C4eW44BS.js" as="script"><link rel="prefetch" href="/assets/5种IO模型.html-BfdPLpFb.js" as="script"><link rel="prefetch" href="/assets/AQS原理深入解析.html-CXoCHmL2.js" as="script"><link rel="prefetch" href="/assets/BitMap和流量统计.html-rFD3D6sn.js" as="script"><link rel="prefetch" href="/assets/BufferPool的缓存清除策略详解.html-BTr2U3pD.js" as="script"><link rel="prefetch" href="/assets/Hashmap_ConcurrentHashmap以及它们各个JDK下的差异.html-v995XIQe.js" as="script"><link rel="prefetch" href="/assets/JDK动态代理和CGlib动态代理的区别.html-BD8c9d7p.js" as="script"><link rel="prefetch" href="/assets/JIT优化及逃逸分析.html-B15nG9Uk.js" as="script"><link rel="prefetch" href="/assets/JUC.html-D9obN8ML.js" as="script"><link rel="prefetch" href="/assets/JUC工具类.html-Dr4OhobA.js" as="script"><link rel="prefetch" href="/assets/JVM.html-Clo083Tn.js" as="script"><link rel="prefetch" href="/assets/JVM垃圾回收算法和回收器详解.html-CzDWU--a.js" as="script"><link rel="prefetch" href="/assets/Java基础.html-BwcNVWtk.js" as="script"><link rel="prefetch" href="/assets/MVCC原理与实现.html-CiT4JAmP.js" as="script"><link rel="prefetch" href="/assets/Mysql.html-DjC6iAvY.js" as="script"><link rel="prefetch" href="/assets/index.html-DAN8dl7d.js" as="script"><link rel="prefetch" href="/assets/Redisson 分布式锁：全面解析.html-Dpsv7-Yd.js" as="script"><link rel="prefetch" href="/assets/SPI 机制详解.html-CvQicrCU.js" as="script"><link rel="prefetch" href="/assets/Spring.html-DLQx7zHm.js" as="script"><link rel="prefetch" href="/assets/Synchronized详解.html-Bm_jSoRm.js" as="script"><link rel="prefetch" href="/assets/ThreadLocal 全面解析.html-DhSzHP_M.js" as="script"><link rel="prefetch" href="/assets/不同JDK版本中字符串常量池的演进.html-Do9vsWPN.js" as="script"><link rel="prefetch" href="/assets/什么是JMM.html-CvIOY2Vo.js" as="script"><link rel="prefetch" href="/assets/介绍一下IOC和AOP.html-Hm92ggvB.js" as="script"><link rel="prefetch" href="/assets/双亲委派机制.html-BabeMVXT.js" as="script"><link rel="prefetch" href="/assets/循环依赖.html-4bz8dF26.js" as="script"><link rel="prefetch" href="/assets/线程池核心参数解析.html-CRUQT6vH.js" as="script"><link rel="prefetch" href="/assets/零拷贝详解.html-Cx2lisnh.js" as="script"><link rel="prefetch" href="/assets/index.html-BftnRIJ9.js" as="script"><link rel="prefetch" href="/assets/index.html-Cuof0Jzt.js" as="script"><link rel="prefetch" href="/assets/API接口定制化防刷与数据存储策略详解.html-CIjXKSWN.js" as="script"><link rel="prefetch" href="/assets/ES预加载.html-CWUGRGAB.js" as="script"><link rel="prefetch" href="/assets/index.html-BHxASt37.js" as="script"><link rel="prefetch" href="/assets/分布式id组件.html-BVe_ygDV.js" as="script"><link rel="prefetch" href="/assets/分布式锁.html-DojmTnEd.js" as="script"><link rel="prefetch" href="/assets/参数加解密.html-CoXeXmHD.js" as="script"><link rel="prefetch" href="/assets/图形验证码.html-Bw6WRwJP.js" as="script"><link rel="prefetch" href="/assets/幂等组件.html-BN5qxCFX.js" as="script"><link rel="prefetch" href="/assets/支付服务详解.html-Be1tgFIU.js" as="script"><link rel="prefetch" href="/assets/数据库表.html-DDPuEm3t.js" as="script"><link rel="prefetch" href="/assets/用户服务详解.html-BhOwMMxV.js" as="script"><link rel="prefetch" href="/assets/系统分库分表详解.html-BhqwIGrF.js" as="script"><link rel="prefetch" href="/assets/线程池组件.html-B6m0dgJE.js" as="script"><link rel="prefetch" href="/assets/组件设计.html-DzuCYn82.js" as="script"><link rel="prefetch" href="/assets/节目服务详解.html-T4JIYIG2.js" as="script"><link rel="prefetch" href="/assets/订单服务详解.html-C_mbBhTU.js" as="script"><link rel="prefetch" href="/assets/限流组件.html-CCLdjd6A.js" as="script"><link rel="prefetch" href="/assets/index.html-BkwiesG0.js" as="script"><link rel="prefetch" href="/assets/index.html-C79KhZ3l.js" as="script"><link rel="prefetch" href="/assets/split.html-7CGQ-2JF.js" as="script"><link rel="prefetch" href="/assets/判题机相关.html-BTTloPh6.js" as="script"><link rel="prefetch" href="/assets/main.html-D_q801zS.js" as="script"><link rel="prefetch" href="/assets/pre.html--jyEPrM2.js" as="script"><link rel="prefetch" href="/assets/reconstruction.html-6cdHxBYs.js" as="script"><link rel="prefetch" href="/assets/design.html-D6RUjzTA.js" as="script"><link rel="prefetch" href="/assets/系统架构设计.html-irARF_0b.js" as="script"><link rel="prefetch" href="/assets/其他.html-CZBCyWBM.js" as="script"><link rel="prefetch" href="/assets/判题服务优化.html-CcSBmShI.js" as="script"><link rel="prefetch" href="/assets/判题模块.html-Edm9kph9.js" as="script"><link rel="prefetch" href="/assets/华为云OBS配置.html-CKYMplyE.js" as="script"><link rel="prefetch" href="/assets/接口编写.html-DBY8AOmQ.js" as="script"><link rel="prefetch" href="/assets/配置邮件发送.html-Bp0gJwGs.js" as="script"><link rel="prefetch" href="/assets/项目搭建.html-BsGnHLeo.js" as="script"><link rel="prefetch" href="/assets/表关系图.html-CUjWMe51.js" as="script"><link rel="prefetch" href="/assets/表结构设计.html-BoEr155D.js" as="script"><link rel="prefetch" href="/assets/表结构设计.html-B9lu6x1S.js" as="script"><link rel="prefetch" href="/assets/1. 组件说明.html-CjFZLkI9.js" as="script"><link rel="prefetch" href="/assets/2. 如何使用.html-C7HiRK3G.js" as="script"><link rel="prefetch" href="/assets/3. 详情介绍.html-BOEkK5hz.js" as="script"><link rel="prefetch" href="/assets/1. 组件说明.html-DmtJvzhB.js" as="script"><link rel="prefetch" href="/assets/2. 如何使用.html-BrBsB1Cj.js" as="script"><link rel="prefetch" href="/assets/3. 详情介绍.html-DxqblD6V.js" as="script"><link rel="prefetch" href="/assets/0. 项目的结构是怎么样的.html-BHnfwczh.js" as="script"><link rel="prefetch" href="/assets/1. 贯穿服务的全局配置.html-CNS9D0_F.js" as="script"><link rel="prefetch" href="/assets/2. 请求处理的整个流程.html-DvE4K5Hq.js" as="script"><link rel="prefetch" href="/assets/3. 如何进行请求鉴权.html-mNbUf-LW.js" as="script"><link rel="prefetch" href="/assets/4. 自定义熔断是怎么实现的.html-CHCTooRC.js" as="script"><link rel="prefetch" href="/assets/5. 请求是怎么解析的.html-ByJj7i0a.js" as="script"><link rel="prefetch" href="/assets/6. 请求调用与结果包装.html-DFm81M55.js" as="script"><link rel="prefetch" href="/assets/7. 自定义接口缓存池.html-CtlWdqlk.js" as="script"><link rel="prefetch" href="/assets/8. 基于SPI机制实现多执行器扩展.html-C3v0jZHv.js" as="script"><link rel="prefetch" href="/assets/1. 项目初期配置.html-qcqS9542.js" as="script"><link rel="prefetch" href="/assets/2. 雪花算法生成唯一id.html-DqQzy08o.js" as="script"><link rel="prefetch" href="/assets/3. 基本CRUD接口编写.html-B29vBrtE.js" as="script"><link rel="prefetch" href="/assets/4. 接口和方法信息注册.html-B4CImVsF.js" as="script"><link rel="prefetch" href="/assets/5. 心跳续约机制.html-BoUp3v5X.js" as="script"><link rel="prefetch" href="/assets/6. NGINX配置刷新.html-C9lKV94-.js" as="script"><link rel="prefetch" href="/assets/7. 事件通知.html-Bq3FA6wS.js" as="script"><link rel="prefetch" href="/assets/8. Redis过期事件监听.html-DUkRMMIZ.js" as="script"><link rel="prefetch" href="/assets/404.html-WWHYjpq5.js" as="script"><link rel="prefetch" href="/assets/index.html-Dd_JFkCB.js" as="script"><link rel="prefetch" href="/assets/index.html--K-I22Ds.js" as="script"><link rel="prefetch" href="/assets/index.html-Cf3TuGU1.js" as="script"><link rel="prefetch" href="/assets/index.html-CCwGumF6.js" as="script"><link rel="prefetch" href="/assets/index.html-CdwXPerc.js" as="script"><link rel="prefetch" href="/assets/index.html-bBmGXKwv.js" as="script"><link rel="prefetch" href="/assets/index.html-BFXOr8Sf.js" as="script"><link rel="prefetch" href="/assets/index.html-CvtdYx8B.js" as="script"><link rel="prefetch" href="/assets/index.html-Crb7pGXH.js" as="script"><link rel="prefetch" href="/assets/index.html-D1cqaD_a.js" as="script"><link rel="prefetch" href="/assets/index.html-BpyJicuQ.js" as="script"><link rel="prefetch" href="/assets/index.html-DXp6sp6x.js" as="script"><link rel="prefetch" href="/assets/index.html-DR468IJP.js" as="script"><link rel="prefetch" href="/assets/index.html-BS4FUD-6.js" as="script"><link rel="prefetch" href="/assets/index.html-DNjrkQEu.js" as="script"><link rel="prefetch" href="/assets/mermaid.esm.min-B1X38Ebh.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-CKV1Bsxh.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container no-sidebar external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="带我回家"><img class="vp-nav-logo" src="/favicon.ico" alt><!----><span class="vp-site-name hide-in-pad">CodeLong</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="主页"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:house" sizing="height" height="1em"></iconify-icon><!--]-->主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/8gu/" aria-label="八股"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:calendar" sizing="height" height="1em"></iconify-icon><!--]-->八股<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link route-link-active auto-link" href="/interviews/" aria-label="🐉🐉一百面"><!---->🐉🐉一百面<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/projects/gateway/" aria-label="百万级网关系统"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:lightbulb" sizing="height" height="1em"></iconify-icon><!--]-->百万级网关系统<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/projects/easypass/" aria-label="畅购通购票系统"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:lightbulb" sizing="height" height="1em"></iconify-icon><!--]-->畅购通购票系统<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/projects/markdown/" aria-label="Markdown 渲染"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:lightbulb" sizing="height" height="1em"></iconify-icon><!--]-->Markdown 渲染<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/projects/algorithm/" aria-label="山西大学算法队OJ系统"><!--[--><iconify-icon class="vp-icon" icon="fa6-solid:lightbulb" sizing="height" height="1em"></iconify-icon><!--]-->山西大学算法队OJ系统<!----></a></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/1973034392/api-gateway-codelong" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><!----><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->个人面经分享</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="codelong.top" target="_blank" rel="noopener noreferrer">CodeLong</a></span><span property="author" content="CodeLong"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2025/9/7</span><meta property="datePublished" content="2025-09-07T13:12:31.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 41 分钟</span><meta property="timeRequired" content="PT41M"></span><!----><!----></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><h1 id="个人面经分享" tabindex="-1"><a class="header-anchor" href="#个人面经分享"><span>个人面经分享</span></a></h1><p>我将在这里分享我的面试经历并附加Gemini AI的相关回答,这是我的简历</p><div class="pdf-viewer-wrapper" style="width:100%;height:auto;"><div></div><button class="pdf-fullscreen-button"><svg xmlns="http://www.w3.org/2000/svg" class="pdf-fullscreen-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="enter-fullscreen icon" name="enter-fullscreen"><path d="M762.773 90.24h-497.28c-96.106 0-174.4 78.293-174.4 174.4v497.28c0 96.107 78.294 174.4 174.4 174.4h497.28c96.107 0 175.04-78.293 174.4-174.4V264.64c0-96.213-78.186-174.4-174.4-174.4zm-387.2 761.173H215.04c-21.867 0-40.427-17.92-41.067-41.066V649.92c0-22.507 17.92-40.427 40.427-40.427 11.307 0 21.227 4.694 28.48 11.947 7.253 7.253 11.947 17.92 11.947 28.48v62.293l145.28-145.28c15.893-15.893 41.813-15.893 57.706 0 15.894 15.894 15.894 41.814 0 57.707l-145.28 145.28h62.294c22.506 0 40.426 17.92 40.426 40.427s-17.173 41.066-39.68 41.066zM650.24 165.76h160.427c21.866 0 40.426 17.92 41.066 41.067v160.426c0 22.507-17.92 40.427-40.426 40.427-11.307 0-21.227-4.693-28.48-11.947-7.254-7.253-11.947-17.92-11.947-28.48v-62.186L625.6 450.347c-15.893 15.893-41.813 15.893-57.707 0-15.893-15.894-15.893-41.814 0-57.707l145.28-145.28H650.88c-22.507 0-40.427-17.92-40.427-40.427s17.174-41.173 39.787-41.173z"></path></svg></button></div><h2 id="欧斯特智能-上海" tabindex="-1"><a class="header-anchor" href="#欧斯特智能-上海"><span>欧斯特智能(上海)</span></a></h2><p><strong>2025.09.01</strong></p><ul><li><p>学校那边可以搞定吗?</p></li><li><p>有使用过三级缓存吗?</p></li><li><p>缓存一致性怎么保证?</p></li><li><p>如果数据库不支持Binlog怎么保证一致性?</p></li><li><p>你提到了延时双删,它有什么问题?</p></li><li><p>JDK21有什么新特性?</p></li><li><p>虚拟线程有了解过吗?</p></li><li><p>IO密集型的线程池怎么设计(虚拟线程)?</p></li><li><p>MQ消息怎么避免重复消费和未消费?</p></li><li><p>在使用Redis和MQ之后怎么保证消息不丢失(分级分用户入库+WAL)?</p></li><li><p>Springboot3相较2有哪些新的注解?</p></li><li><p>了解过grpc吗?</p></li><li><p>了解过DDD吗?</p></li><li><p>了解过向量数据库吗?</p></li></ul><blockquote><h3 id="_1-有使用过三级缓存吗" tabindex="-1"><a class="header-anchor" href="#_1-有使用过三级缓存吗"><span>1. 有使用过三级缓存吗?</span></a></h3><p>在实际的应用开发中，&quot;三级缓存&quot; 通常指的是一个多层次的缓存架构，旨在最大化缓存命中率，降低对后端数据源的压力。虽然没有一个严格的、放之四海而皆准的“三级缓存”定义，但一个经典的实现通常包含以下几个层次：</p><ol><li><strong>一级缓存（本地缓存/堆内存缓存）</strong>: <ul><li><strong>实现</strong>: 通常使用<code>ConcurrentHashMap</code>、<code>Guava Cache</code>或<code>Caffeine</code>等库在应用内部实现。</li><li><strong>优点</strong>: 速度最快，没有网络开销，直接从内存读取。</li><li><strong>缺点</strong>: 容量有限，受限于单机内存；多实例部署时，缓存数据不共享，存在一致性问题。</li><li><strong>应用场景</strong>: 缓存更新不频繁但读取极其频繁的热点数据。</li></ul></li><li><strong>二级缓存（分布式缓存）</strong>: <ul><li><strong>实现</strong>: 使用Redis、Memcached等独立的分布式缓存系统。</li><li><strong>优点</strong>: 独立部署，容量大，所有应用实例共享，解决了本地缓存的数据共享问题。</li><li><strong>缺点</strong>: 存在网络I/O开销，速度慢于本地缓存。</li><li><strong>应用场景</strong>: 系统中的核心热点数据，读多写少的场景。</li></ul></li><li><strong>三级缓存（兜底缓存/近线缓存）</strong>: <ul><li><strong>实现</strong>: 这一层的实现比较多样化，可以是： <ul><li><strong>分布式文件系统/对象存储</strong>: 如NFS、HDFS、S3等，用于存储非结构化或半结构化的数据。</li><li><strong>NoSQL数据库</strong>: 如Elasticsearch、HBase等，用于特定场景的查询加速。</li><li><strong>更持久化的二级缓存</strong>: 例如Redis的AOF或RDB持久化文件，在缓存服务重启时可以快速恢复一部分热数据。</li></ul></li><li><strong>优点</strong>: 持久化，容量更大，作为数据库前的最后一道防线，防止大量请求直接穿透到数据库。</li><li><strong>缺点</strong>: 速度最慢，通常用于对时效性要求不那么高的数据。</li></ul></li></ol><p><strong>总结</strong>: 是的，在构建复杂的高性能系统时，这种分层缓存的思想被广泛应用。例如，一个典型的电商系统在查询商品详情时，会先查Caffeine，未命中则查Redis，再未命中则查询Elasticsearch或最终的数据库，这便构成了一个事实上的多级缓存体系</p><h3 id="_2-缓存一致性怎么保证" tabindex="-1"><a class="header-anchor" href="#_2-缓存一致性怎么保证"><span>2. 缓存一致性怎么保证?</span></a></h3><p>保证缓存与数据库之间的数据一致性是缓存应用中的核心难题。常见的保证方案有以下几种，需要根据业务场景对一致性要求的级别来选择：</p><ol><li><strong>Cache-Aside Pattern (旁路缓存模式)</strong>: 这是最常用的一种模式。 <ul><li><strong>读</strong>: 先读缓存，缓存命中则直接返回；缓存未命中，则读数据库，然后将数据写入缓存，再返回。</li><li><strong>写</strong>: <strong>先更新数据库，再删除缓存</strong>。</li><li><strong>为什么是删除缓存而不是更新缓存？</strong><ul><li><strong>懒加载</strong>: 只有在下次读取时才加载，避免了无效的写操作。如果更新了缓存但该数据后续一直没被访问，就浪费了资源。</li><li><strong>并发问题</strong>: &quot;先更新数据库，再更新缓存&quot; 在并发场景下，可能会导致缓存和数据库数据不一致（脏数据）。例如，线程A更新数据库，线程B更新数据库，线程B先更新了缓存，线程A后更新了缓存，导致缓存中是A的数据（旧数据）。而删除操作是幂等的，多次删除结果一致。</li></ul></li></ul></li><li><strong>Read-Through/Write-Through/Write-Behind (读穿透/写穿透/回写模式)</strong>: 这类模式通常由一些缓存框架或组件提供支持，将缓存和数据库的操作封装起来，对应用层透明。 <ul><li><strong>Read-Through</strong>: 应用读缓存，如果缓存未命中，由缓存服务自己负责从数据库加载数据并返回。</li><li><strong>Write-Through</strong>: 应用写缓存，由缓存服务负责将数据写入数据库，两者都成功后才返回。保证了强一致性，但牺牲了性能。</li><li><strong>Write-Behind (Write-Back)</strong>: 应用只管写缓存，由缓存服务异步地、批量地将数据写入数据库。性能最好，但存在数据丢失的风险（例如缓存服务宕机）。</li></ul></li><li><strong>订阅Binlog，异步更新缓存</strong>: <ul><li><strong>思路</strong>: 通过Canal、Debezium等工具订阅MySQL的Binlog日志，获取数据库的实时变更数据。</li><li><strong>流程</strong>: 当监听到数据库发生变更（INSERT, UPDATE, DELETE）时，由一个专门的服务去解析Binlog，然后去更新或删除对应的缓存。</li><li><strong>优点</strong>: 业务代码与缓存维护逻辑解耦，对业务代码无侵入；可以实现最终一致性，延迟较低。</li><li><strong>缺点</strong>: 架构复杂度高，需要引入额外的中间件和维护成本。</li></ul></li></ol><h3 id="_3-如果数据库不支持binlog怎么保证一致性" tabindex="-1"><a class="header-anchor" href="#_3-如果数据库不支持binlog怎么保证一致性"><span>3. 如果数据库不支持Binlog怎么保证一致性?</span></a></h3><p>如果底层数据库（例如一些NoSQL数据库或老旧的关系型数据库）不提供类似MySQL Binlog的事务日志订阅功能，一致性的保证会变得更加困难，通常可以采用以下策略：</p><ol><li><strong>消息队列 (Message Queue)</strong>: <ul><li><strong>思路</strong>: 在更新数据库的业务逻辑中，同时发送一条消息到MQ。</li><li><strong>流程</strong>: 一个独立的消费者服务订阅该消息，当收到消息后，去执行缓存的删除或更新操作。</li><li><strong>挑战</strong>: 这引入了分布式事务的问题。如何保证“更新数据库”和“发送MQ消息”这两个操作的原子性？ <ul><li><strong>本地消息表/发件箱模式 (Outbox Pattern)</strong>: 将业务操作和要发送的消息放在同一个本地事务中完成。一个后台任务定时轮询这张消息表，将消息发送到MQ，并标记为已发送。这是保证最终一致性的可靠方案。</li><li><strong>事务消息</strong>: 依赖MQ提供的事务消息功能（如RocketMQ），但会增加业务代码的复杂度。</li></ul></li></ul></li><li><strong>定时任务轮询/ETL</strong>: <ul><li><strong>思路</strong>: 通过一个定时任务，周期性地去扫描数据库中的数据变更（例如通过一个<code>last_updated_time</code>时间戳字段）。</li><li><strong>流程</strong>: 定时任务拉取变更的数据，然后更新缓存。</li><li><strong>缺点</strong>: 一致性的延迟较高，取决于轮询的频率；对数据库有一定的查询压力。适用于对一致性要求不高的场景。</li></ul></li><li><strong>应用层双写</strong>: <ul><li>在应用代码中，同时写入数据库和缓存。这种方式问题最多，并发控制复杂，很容易出现不一致，<strong>通常不推荐</strong>。</li></ul></li></ol><h3 id="_4-你提到了延时双删-它有什么问题" tabindex="-1"><a class="header-anchor" href="#_4-你提到了延时双删-它有什么问题"><span>4. 你提到了延时双删,它有什么问题?</span></a></h3><p>&quot;延时双删&quot; 是对Cache-Aside模式中“先更新数据库，再删除缓存”方案的一种优化，旨在解决一个特定的并发问题。</p><p><strong>问题场景</strong>:</p><ol><li>线程A请求更新数据。</li><li>线程A执行<code>UPDATE database</code>。</li><li>线程A执行<code>DELETE cache</code>。<strong>在删除前</strong>，线程B发起了一次读请求。</li><li>线程B <code>SELECT</code> 缓存，发现缓存不存在（或已被一个更早的写操作删除）。</li><li>线程B <code>SELECT database</code>，读取到了<strong>旧数据</strong>（因为此时线程A的事务可能还未提交）。</li><li>线程B将<strong>旧数据</strong>写入了缓存。</li><li>线程A完成了缓存删除操作。</li></ol><p>此时，缓存中的数据是旧的，而数据库中的是新的，导致了不一致，且这个脏数据会一直存在，直到缓存过期或下次被更新。</p><p><strong>延时双删策略</strong>:</p><ol><li>先淘汰缓存。</li><li>再写数据库。</li><li>休眠一段时间（例如几百毫秒）。</li><li>再次淘汰缓存。</li></ol><p><strong>延时双删的问题</strong>:</p><ol><li><strong>休眠时间的确定是难题</strong>: 这个“延时”时间到底设置多久？ <ul><li>太短，可能无法覆盖掉并发读操作将旧数据写入缓存的时间窗口，问题依旧存在。</li><li>太长，会影响系统吞吐量，并且在这段时间内，数据的不一致性是确定存在的。这个时间需要根据业务的读写耗时来估算，但很难精确。</li></ul></li><li><strong>吞吐量下降</strong>: 引入了<code>sleep</code>操作，使得写操作的耗时显著增加，降低了系统的整体吞吐能力。</li><li><strong>无法完全避免问题</strong>: 在极端情况下，例如主从数据库延迟很高时，延时双删依然可能失败。如果休眠时间小于主从同步的延迟，那么在第二次删除缓存后，读请求依然可能从“从库”读取到旧数据并写回缓存。</li></ol><p><strong>结论</strong>: 延时双删是一种“妥协”的方案，实现复杂且效果不完美。在绝大多数场景下，<strong>“先更新数据库，再删除缓存”，并为缓存设置合理的过期时间</strong>，已经能够满足需求。如果对一致性要求非常高，那么应该优先考虑<strong>订阅Binlog的异步更新方案</strong>。</p><h3 id="_5-jdk21有什么新特性" tabindex="-1"><a class="header-anchor" href="#_5-jdk21有什么新特性"><span>5. JDK21有什么新特性?</span></a></h3><p>JDK 21是一个长期支持（LTS）版本，带来了许多重要的新特性，其中最引人注目的是：</p><ol><li><strong>虚拟线程 (Virtual Threads) - 正式版</strong>: 这是Project Loom的核心成果。虚拟线程是由JDK而非操作系统内核管理的轻量级线程。它们极大地简化了编写、维护和观察高吞吐量并发应用的过程。</li><li><strong>结构化并发 (Structured Concurrency) - 预览阶段</strong>: 简化并发编程，将不同线程中运行的相关任务组视为一个工作单元，简化错误处理和取消操作，提高代码的可靠性和可观察性。</li><li><strong>作用域值 (Scoped Values) - 预览阶段</strong>: 提供了一种在线程内以及线程间共享不可变数据的新方式，是<code>ThreadLocal</code>的更优替代方案，尤其是在使用大量虚拟线程时。</li><li><strong>字符串模板 (String Templates) - 预览阶段</strong>: 简化字符串拼接和格式化，通过模板和嵌入式表达式生成字符串，比传统的<code>+</code>拼接或<code>String.format()</code>更易读、更安全。</li><li><strong>未命名类和实例主方法 (Unnamed Classes and Instance Main Methods) - 预览阶段</strong>: 旨在降低Java学习的门槛，让初学者可以编写更简洁的“Hello, World!”程序。</li><li><strong>序列化集合 (Sequenced Collections)</strong>: 引入了新的接口<code>SequencedCollection</code>, <code>SequencedSet</code>, 和 <code>SequencedMap</code>，为集合提供统一的、定义明确的遍历顺序，并提供了获取第一个/最后一个元素、反向遍历等标准API。</li><li><strong>switch模式匹配 (Pattern Matching for switch) - 正式版</strong>: 扩展了<code>switch</code>语句和表达式，使其可以对对象的类型和结构进行匹配，代码更简洁、更安全。</li><li><strong>记录模式 (Record Patterns) - 正式版</strong>: 用于解构记录（Record）实例，可以与模式匹配（如<code>instanceof</code>和<code>switch</code>）结合使用，方便地提取组件数据。</li></ol><h3 id="_6-虚拟线程有了解过吗" tabindex="-1"><a class="header-anchor" href="#_6-虚拟线程有了解过吗"><span>6. 虚拟线程有了解过吗?</span></a></h3><p>是的，有深入了解。</p><p>核心概念:</p><p>虚拟线程（Virtual Thread）是JDK实现的用户态线程，它并不直接映射到操作系统的内核线程（Platform Thread）。相反，大量的虚拟线程可以运行在少数几个内核线程上。</p><p><strong>工作原理</strong>:</p><ul><li>当一个虚拟线程执行I/O操作或其他阻塞操作时，它不会阻塞底层的内核线程。</li><li>JVM会<strong>挂起</strong>这个虚拟线程，并将其从内核线程上卸下（unmount）。</li><li>内核线程（Carrier Thread）可以立即去执行另一个准备就绪的虚拟线程。</li><li>当之前的I/O操作完成后，被挂起的虚拟线程会重新变为可运行状态，并被调度到任意一个可用的内核线程上继续执行（mount）。</li></ul><p><strong>优势</strong>:</p><ol><li><strong>极高的吞吐量</strong>: 可以轻松创建数百万个虚拟线程而不会耗尽系统资源。因为虚拟线程本质上只是一个轻量级的Java对象，占用的内存很小。</li><li><strong>简化并发编程</strong>: 可以用传统的回车符换行，同步阻塞式的编程模型（per-request-per-thread）来编写代码，而无需使用复杂、易错的异步/响应式编程（如<code>CompletableFuture</code>或<code>Reactive Streams</code>），就能达到异步编程的性能和扩展性。代码更易读、易调试、易维护。</li><li><strong>兼容现有API</strong>: 大部分现有的Java同步API（如<code>InputStream</code>, <code>OutputStream</code>, <code>Socket</code>等）在虚拟线程中运行时，会自动触发挂起/恢复的调度，无需修改代码。</li></ol><p>适用场景:</p><p>非常适合I/O密集型或网络密集型的应用，例如：</p><ul><li>微服务网关</li><li>Web服务器</li><li>数据库连接代理</li><li>任何需要处理大量并发连接和请求，且大部分时间花在等待网络或磁盘响应的场景。</li></ul><p>不适用场景:</p><p>不适合CPU密集型的任务。因为虚拟线程的目标是提高并发吞吐量，而不是并行计算能力。CPU密集型任务需要的是与CPU核心数相当的内核线程来并行执行，使用虚拟线程不会带来性能提升，反而可能因为额外的调度开销而略有下降。</p><h3 id="_7-io密集型的线程池怎么设计-虚拟线程" tabindex="-1"><a class="header-anchor" href="#_7-io密集型的线程池怎么设计-虚拟线程"><span>7. IO密集型的线程池怎么设计(虚拟线程)?</span></a></h3><p>使用虚拟线程来处理IO密集型任务，线程池的设计思想发生了根本性的转变。</p><p><strong>传统线程池设计 (使用平台线程)</strong>:</p><ul><li>需要精心计算线程池大小，通常根据<code>核心数 * (1 + 等待时间/计算时间)</code>的公式来估算。</li><li>线程数是一个宝贵的、有限的资源，需要池化来复用。</li><li>任务队列是必须的，用于缓冲无法立即处理的请求。</li></ul><p>使用虚拟线程的设计:</p><p>不需要传统的线程池了！</p><p>正确的做法是：<strong>为每一个任务（例如，每一个进来的HTTP请求）创建一个新的虚拟线程</strong>。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在JDK 21中，可以这样简单地处理请求</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> executor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Executors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newVirtualThreadPerTaskExecutor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1000000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Runnable</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> task </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> () </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 执行IO密集型任务，例如调用一个远程API</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 或者查询数据库</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 这里的代码是同步阻塞式的</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            handleRequest</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        executor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">submit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(task);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// try-with-resources 会自动关闭 executor</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么可以这样做？</strong></p><ul><li><strong>创建成本极低</strong>: 创建一个虚拟线程几乎没有开销，和创建一个普通对象类似。</li><li><strong>无限的并发能力</strong>: 理论上可以创建任意数量的虚拟线程，受限于内存而非操作系统线程数限制。</li><li><strong>自动调度</strong>: JVM的ForkJoinPool会负责将这些虚拟线程调度到后端的少量平台线程（Carrier Threads）上去执行。当虚拟线程遇到IO阻塞时，会自动让出平台线程。</li></ul><p><strong>结论</strong>: 在虚拟线程的世界里，对于IO密集型任务，我们不再需要管理和池化线程。设计模式回归到了最简单的“一个请求一个线程”模型，但却获得了异步编程的性能。你只需要使用 <code>Executors.newVirtualThreadPerTaskExecutor()</code>，然后放心地为每个任务提交一个新的虚拟线程即可。</p><h3 id="_8-mq消息怎么避免重复消费和未消费" tabindex="-1"><a class="header-anchor" href="#_8-mq消息怎么避免重复消费和未消费"><span>8. MQ消息怎么避免重复消费和未消费?</span></a></h3><p>这是保证MQ消息可靠性的两个核心问题。</p><p><strong>1. 避免未消费 (保证消息至少被消费一次 At-Least-Once)</strong></p><ul><li><strong>ACK机制</strong>: 这是最核心的机制。消费者在成功处理完消息后，向MQ发送一个确认（ACK）信号。 <ul><li><strong>自动ACK</strong>: 消费者拉取到消息后，客户端库立即自动发送ACK。这种方式如果消费者在处理消息过程中宕机，消息会丢失。</li><li><strong>手动ACK</strong>: 消费者在业务逻辑<strong>完全成功</strong>执行完毕后，手动调用API发送ACK。如果在处理过程中出现异常，则不发送ACK（或发送NACK，表示消费失败）。</li></ul></li><li><strong>重试机制</strong>: 当MQ没有在规定时间内收到消费者的ACK时（或收到NACK），它会认为消息没有被成功消费，并在一段时间后将该消息<strong>重新投递</strong>给其他（或同一个）消费者。</li></ul><p><strong>2. 避免重复消费 (保证消息最多被消费一次 At-Most-Once 或 精确一次 Exactly-Once)</strong></p><p>由于重试机制的存在（例如，消费者成功处理了消息，但在发送ACK时网络中断或宕机），重复消费是可能发生的。解决方案的核心是：<strong>保证消费逻辑的幂等性 (Idempotence)</strong>。</p><p>幂等性意味着对同一个操作执行一次和执行多次，结果是完全相同的。实现幂等性的常见方法有：</p><ul><li><strong>数据库唯一键</strong>: 利用数据库的唯一索引或主键约束。例如，订单创建消息，可以用订单ID作为主键，重复的消息在<code>INSERT</code>时会因为主键冲突而失败。</li><li><strong>状态机控制</strong>: 在数据库中为业务数据设计一个状态字段。例如，订单状态有“待支付”、“已支付”、“已取消”。如果一个“支付成功”的消息来了，只有当订单状态是“待支付”时才执行更新操作，如果已经是“已支付”，则直接忽略。 <ul><li><code>UPDATE orders SET status = &#39;PAID&#39; WHERE order_id = ? AND status = &#39;PENDING&#39;;</code></li><li>通过返回值判断影响的行数，如果为0，说明是重复消费。</li></ul></li><li><strong>全局唯一ID + 记录表</strong>: <ul><li>为每条消息生成一个全局唯一的ID（可以使用业务ID，如订单号；或消息自身的Message ID）。</li><li>消费者端准备一个“消费记录表”。</li><li>在处理消息前，先查询这个ID是否在记录表中存在。</li><li>如果存在，说明是重复消息，直接忽略并ACK。</li><li>如果不存在，则将该ID插入记录表，然后处理业务逻辑。<strong>这两个操作需要放在同一个本地事务中</strong>，保证原子性。</li></ul></li></ul><p><strong>总结</strong>: 通过 <strong>手动ACK + 重试机制</strong> 保证了消息“至少被消费一次”，再通过 <strong>消费端实现幂等性</strong> 来解决重试带来的重复消费问题，最终可以实现“精确一次消费”的业务效果。</p><h3 id="_9-在使用redis和mq之后怎么保证消息不丢失-分级分用户入库-wal" tabindex="-1"><a class="header-anchor" href="#_9-在使用redis和mq之后怎么保证消息不丢失-分级分用户入库-wal"><span>9. 在使用Redis和MQ之后怎么保证消息不丢失(分级分用户入库+WAL)?</span></a></h3><p>这个问题场景比较复杂，结合了缓存、消息队列和数据库持久化，旨在构建一个高可靠的数据处理链路。这里的“分级分用户入库+WAL”是一种具体的、高级的可靠性保证方案。我们来分解一下。</p><p><strong>消息不丢失需要保证三个环节的可靠性</strong>:</p><ol><li><strong>生产者 -&gt; MQ</strong>: 消息不能在发送过程中丢失。</li><li><strong>MQ自身</strong>: 消息在MQ中存储时不能丢失。</li><li><strong>MQ -&gt; 消费者</strong>: 消息在消费过程中不能丢失。</li></ol><p><strong>综合解决方案</strong>:</p><ol><li><strong>生产者端可靠性</strong>: <ul><li>使用MQ提供的<strong>事务消息</strong>或<strong>生产者确认机制 (Publisher Confirms)</strong>。</li><li><strong>Publisher Confirms</strong>: 发送消息后，生产者阻塞或异步等待MQ的确认回执。如果未收到确认（或收到失败确认），则进行重试。</li><li><strong>结合本地消息表 (Outbox Pattern)</strong>: 这是最可靠的方式。将业务操作和写“本地消息表”放在一个数据库事务里。一个独立的任务轮询这张表，将消息发送到MQ，成功后再更新表状态。</li></ul></li><li><strong>MQ自身可靠性</strong>: <ul><li><strong>持久化</strong>: 将消息配置为持久化模式。队列和消息都设置为durable。这样即使MQ服务重启，消息也不会丢失。</li><li><strong>集群/镜像</strong>: 部署MQ集群，使用镜像队列等机制，将消息副本存储在多个节点上，防止单点故障。</li></ul></li><li><strong>消费者端可靠性</strong>: <ul><li><strong>手动ACK</strong>: 如上一问所述，业务处理成功后才发送确认。</li><li><strong>幂等性处理</strong>: 防止重试导致数据错乱。</li></ul></li></ol><p><strong>融入 Redis 和 “分级分用户入库+WAL” 策略</strong>:</p><p>这是一个典型的<strong>高性能异步入库场景</strong>。例如，处理海量的用户行为日志或计费请求。直接写入数据库会很慢，所以引入了Redis和MQ来削峰填谷和异步处理。</p><ul><li><strong>分级</strong>: 可能指对不同优先级的消息进行分级处理。例如，VIP用户的请求走高优先级队列，普通用户走普通队列。</li><li><strong>分用户</strong>: 为了避免单个用户的异常数据影响整体，以及为了后续追踪和数据隔离，可能会按用户ID进行分片或路由到不同的队列/消费者。</li><li><strong>入库</strong>: 最终的目标是将数据持久化到数据库。</li></ul><p><strong>WAL (Write-Ahead Logging, 预写日志)</strong> 在这里的应用，是一种提升消费者端性能和可靠性的关键技术。</p><p><strong>流程可以是这样的</strong>:</p><ol><li><strong>接收与缓冲</strong>: 消费者从MQ获取批量消息。</li><li><strong>写入Redis</strong>: 将消息数据快速写入Redis，可以做一些初步的聚合或格式转换。Redis在这里起到了一个高速缓冲层的作用。</li><li><strong>写入WAL</strong>: 在将数据写入数据库<strong>之前</strong>，消费者先把这个“写数据库”的操作（例如，SQL语句或数据变更记录）以日志的形式，<strong>顺序写入</strong>一个本地的持久化文件（WAL文件）。这个写文件操作非常快。</li><li><strong>ACK消息</strong>: 一旦WAL写入成功，消费者就可以<strong>立即向MQ发送ACK</strong>，表示这批消息已经“安全”了。即使此时消费者进程崩溃，由于操作记录在WAL中，重启后可以读取WAL来恢复，不会丢失数据。</li><li><strong>异步批量入库</strong>: 一个独立的后台线程，负责读取WAL文件中的操作记录，然后以<strong>较高的批处理效率</strong>将数据批量写入最终的数据库（如MySQL, HBase等）。</li><li><strong>Checkpoint</strong>: 当WAL中的数据成功写入数据库后，会定期或定量地在WAL文件中做一个检查点（Checkpoint），表示这个点之前的数据已经持久化，可以安全删除了。</li></ol><p><strong>这种架构的优势</strong>:</p><ul><li><strong>高吞吐量</strong>: 消费者的核心逻辑只是飞快地写Redis和本地文件（WAL），然后就可以ACK了，消费速度极快。</li><li><strong>高可靠性</strong>: WAL保证了即使在异步入库的过程中发生故障，数据也不会丢失。这是借鉴了数据库本身的设计思想。</li><li><strong>数据库压力小</strong>: 最终对数据库的写入是异步的、批量的，大大降低了数据库的写压力。</li></ul><h3 id="_10-springboot3相较2有哪些新的注解" tabindex="-1"><a class="header-anchor" href="#_10-springboot3相较2有哪些新的注解"><span>10. Springboot3相较2有哪些新的注解?</span></a></h3><p>Spring Boot 3.0 是一个重要的主版本升级，它基于 Spring Framework 6，要求 Java 17 作为最低版本，并迁移到了 Jakarta EE 9/10。注解方面的变化虽然不是铺天盖地，但有一些值得关注的新增和变化：</p><ol><li><strong><code>@GraphQlController</code> 和相关注解</strong>: <ul><li>随着Spring for GraphQL的正式集成，引入了一系列注解来简化GraphQL应用的开发，如 <code>@QueryMapping</code>, <code>@MutationMapping</code>, <code>@SubscriptionMapping</code>, <code>@SchemaMapping</code> 等。这取代了之前需要手动配置<code>RuntimeWiring.Builder</code>的方式。</li></ul></li><li><strong><code>@HttpExchange</code></strong>: <ul><li>用于创建声明式的HTTP客户端接口，类似于Feign。你可以定义一个Java接口，并使用<code>@HttpExchange</code>（或更具体的<code>@GetExchange</code>, <code>@PostExchange</code>等）来注解方法，Spring会自动为你生成实现类来发起HTTP请求。</li></ul></li><li><strong>Observability (可观测性) 相关的注解和改进</strong>: <ul><li>Spring Boot 3全面拥抱了Micrometer Tracing，整合了Brave和OpenTelemetry等分布式追踪方案。虽然不全是“新注解”，但像<code>@Observed</code> (来自Micrometer)这样的注解变得更加核心和易用，可以方便地为方法添加metrics、logging和tracing。</li></ul></li><li><strong>AOT (Ahead-Of-Time) 相关的提示注解</strong>: <ul><li>为了支持GraalVM原生镜像（Native Image）编译，引入了<code>@RegisterReflectionForBinding</code>, <code>@Reflective</code> 等<code>RuntimeHints</code>相关的注解。开发者可以通过这些注解，向AOT编译器提供关于反射、序列化、动态代理等运行时行为的提示，确保原生镜像能够正确运行。</li></ul></li></ol><p><strong>更重要的是一些底层和依赖的变化，而非仅仅是注解</strong>:</p><ul><li><strong>Jakarta EE迁移</strong>: 所有之前使用<code>javax.*</code>包名的API都变成了<code>jakarta.*</code>。例如 <code>javax.servlet.http.HttpServletRequest</code> 变为 <code>jakarta.servlet.http.HttpServletRequest</code>。这导致了大量依赖库需要升级。</li><li><strong>配置文件处理变化</strong>: <code>spring.factories</code> 的服务加载机制被新的 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件所取代，虽然对普通用户影响不大，但对库开发者影响很大。</li></ul><h3 id="_11-了解过grpc吗" tabindex="-1"><a class="header-anchor" href="#_11-了解过grpc吗"><span>11. 了解过grpc吗?</span></a></h3><p>是的，非常了解。</p><p><strong>gRPC (gRPC Remote Procedure Calls)</strong> 是一个由Google开发的高性能、开源、通用的RPC（远程过程调用）框架。</p><p><strong>核心特点</strong>:</p><ol><li><strong>基于HTTP/2</strong>: <ul><li>HTTP/2提供了多路复用、头部压缩、服务端推送、二进制分帧等特性，使得gRPC在单个TCP连接上可以处理多个并发请求，大大降低了延迟，提升了网络利用率。</li></ul></li><li><strong>使用Protocol Buffers (Protobuf)</strong>: <ul><li>gRPC默认使用Protobuf作为其接口定义语言（IDL）和消息交换格式。</li><li><strong>IDL</strong>: 你在一个<code>.proto</code>文件中定义服务（Service）、方法（RPC）以及消息（Message）的结构。</li><li><strong>序列化</strong>: Protobuf是一种高效的二进制序列化协议，序列化后的数据体积小、解析速度快，相比JSON/XML有明显的性能优势。</li><li><strong>强类型与代码生成</strong>: 通过<code>.proto</code>文件，可以使用<code>protoc</code>编译器生成指定语言（Java, Go, Python, C++等）的客户端存根（stub）和服务端骨架代码，实现了强类型的接口约束，避免了联调时的很多低级错误。</li></ul></li><li><strong>支持多种通信模式</strong>: <ul><li><strong>Unary RPC</strong>: 传统的请求-响应模式，客户端发送一个请求，服务端返回一个响应。</li><li><strong>Server Streaming RPC</strong>: 客户端发送一个请求，服务端返回一个数据流，可以持续发送多个消息。</li><li><strong>Client Streaming RPC</strong>: 客户端发送一个数据流，服务端在接收完所有消息后返回一个响应。</li><li><strong>Bidirectional Streaming RPC</strong>: 客户端和服务端都可以独立地、异步地向对方发送数据流，可以实现全双工通信。</li></ul></li></ol><p><strong>优势</strong>:</p><ul><li><strong>高性能</strong>: HTTP/2 + Protobuf的组合带来了极低的延迟和高吞吐量。</li><li><strong>跨语言</strong>: 支持主流的编程语言，非常适合构建多语言环境下的微服务系统。</li><li><strong>服务定义清晰</strong>: <code>.proto</code>文件即是服务契约，是唯一的、权威的接口文档。</li><li><strong>功能强大</strong>: 支持流式通信、认证、负载均衡、超时、取消等高级功能。</li></ul><p><strong>适用场景</strong>:</p><ul><li><strong>微服务间的内部通信</strong>: 这是gRPC最主要的应用场景，尤其是在对性能要求高的系统中。</li><li><strong>移动客户端与后端通信</strong>: Protobuf的轻量和HTTP/2的高效非常适合移动网络环境。</li><li><strong>需要流式数据传输的场景</strong>: 如物联网数据上报、实时消息推送等。</li></ul><p>与RESTful API的对比:</p><table><thead><tr><th>特性</th><th>gRPC</th><th>RESTful API</th></tr></thead><tbody><tr><td>协议</td><td>HTTP/2</td><td>通常是 HTTP/1.1 (也可用 HTTP/2)</td></tr><tr><td>数据格式</td><td>Protobuf (二进制)</td><td>JSON (文本)</td></tr><tr><td>契约定义</td><td>.proto 文件 (强类型)</td><td>OpenAPI/Swagger (可选, 弱约束)</td></tr><tr><td>性能</td><td>高</td><td>相对较低</td></tr><tr><td>浏览器支持</td><td>需要代理 (gRPC-Web)</td><td>原生支持</td></tr><tr><td>易用性</td><td>学习曲线稍陡</td><td>简单直观</td></tr></tbody></table><h3 id="_12-了解过ddd吗" tabindex="-1"><a class="header-anchor" href="#_12-了解过ddd吗"><span>12. 了解过DDD吗?</span></a></h3><p>是的，DDD（Domain-Driven Design，领域驱动设计）是一种软件开发方法论，旨在通过将实现连接到不断发展的模型来应对复杂的需求。</p><p>核心思想:</p><p>DDD的核心思想是，在软件开发过程中，我们应该将主要的焦点放在业务领域（Domain）本身，而不是技术实现。我们应该与领域专家（Domain Expert）紧密合作，建立一个能够准确反映业务领域知识和流程的通用语言（Ubiquitous Language）和领域模型（Domain Model），并用这个模型来指导整个软件的设计和实现。</p><p><strong>关键概念</strong>:</p><p><strong>战略设计 (Strategic Design)</strong>: 关注于宏观层面，如何划分和组织复杂的业务领域。</p><ul><li><strong>领域 (Domain)</strong>: 业务问题发生的范围。</li><li><strong>子域 (Subdomain)</strong>: 将复杂的领域划分为更小的、可管理的部分。</li><li><strong>核心域 (Core Domain)</strong>: 业务最核心、最具竞争力的部分，需要投入最好的资源。</li><li><strong>支撑子域 (Supporting Subdomain)</strong>: 非核心，但为核心域提供支撑的业务部分。</li><li><strong>通用子域 (Generic Subdomain)</strong>: 非核心，且业界有成熟解决方案的部分（如权限、认证），通常可以直接使用或购买。</li><li><strong>通用语言 (Ubiquitous Language)</strong>: 在项目团队（开发、产品、测试、领域专家）中形成的一套共享的、无歧义的术语、概念和词汇表，用于描述领域模型。代码中的类名、方法名、变量名都应该直接使用通用语言。</li><li><strong>限界上下文 (Bounded Context)</strong>: 一个逻辑边界，通用语言和领域模型在这个边界内具有明确的、唯一的含义。每个限界上下文都对应一个微服务或一个独立的模块。</li><li><strong>上下文映射图 (Context Map)</strong>: 描述不同限界上下文之间的关系，如合作（Partnership）、共享内核（Shared Kernel）、客户-供应商（Customer-Supplier）、防腐层（Anti-Corruption Layer）等。</li></ul><p><strong>战术设计 (Tactical Design)</strong>: 关注于微观层面，如何在限界上下文内部设计出高质量的领域模型。</p><ul><li><strong>实体 (Entity)</strong>: 具有唯一标识（ID）并且其生命周期和状态是连续变化的领域对象。例如，一个“用户”或一张“订单”。</li><li><strong>值对象 (Value Object)</strong>: 没有唯一标识，通过其属性值来描述事物，通常是不可变的（Immutable）。例如，“地址”（由省、市、区组成）或“金额”（由数值和币种组成）。</li><li><strong>聚合 (Aggregate)</strong>: 一组相关领域对象的集群，作为数据修改和持久化的基本单元。 <ul><li><strong>聚合根 (Aggregate Root)</strong>: 是聚合的入口，是聚合中唯一一个可以被外部直接引用的实体。所有对聚合内部的修改都必须通过聚合根来完成，以保证业务规则的一致性。</li></ul></li><li><strong>工厂 (Factory)</strong>: 负责封装创建复杂对象（特别是聚合）的逻辑。</li><li><strong>仓库 (Repository)</strong>: 负责封装对象的持久化和查询逻辑，提供一个类似集合的接口来访问聚合根，隔离领域层和基础设施层。</li><li><strong>领域服务 (Domain Service)</strong>: 当某个操作不适合放在任何一个实体或值对象中时（例如，它需要协调多个聚合），可以将其封装在领域服务中。</li><li><strong>领域事件 (Domain Event)</strong>: 用于表示在领域中发生过的重要事情。例如，“订单已支付”、“用户已注册”。领域事件是实现最终一致性和系统解耦的关键。</li></ul><p><strong>DDD的价值</strong>:</p><ul><li>帮助团队应对复杂的业务场景。</li><li>建立清晰、一致的业务模型和代码实现。</li><li>促进开发人员与业务专家的有效沟通。</li><li>构建出灵活、可维护、易于演进的软件系统，特别适合微服务架构。</li></ul><h3 id="_13-了解过向量数据库吗" tabindex="-1"><a class="header-anchor" href="#_13-了解过向量数据库吗"><span>13. 了解过向量数据库吗?</span></a></h3><p>是的，向量数据库（Vector Database）是近年来随着AI和机器学习的兴起而变得非常流行的一种新型数据库。</p><p>核心功能:</p><p>专门用于存储、管理和查询高维向量数据的数据库。</p><p>背景:</p><p>在AI领域，文本、图片、音频、视频等非结构化数据，通常可以通过嵌入（Embedding）模型（如Word2Vec, BERT, CLIP等）转换成高维的数学向量（Vector）。这些向量能够捕捉到原始数据的语义信息。</p><ul><li><strong>语义相似性</strong>: 在向量空间中，两个向量的<strong>距离</strong>（如欧氏距离、余弦相似度）越近，代表它们对应的原始数据在语义上就越相似。</li></ul><p>传统数据库的困境:</p><p>传统的关系型数据库或NoSQL数据库不擅长处理这种高维向量的相似性搜索。如果要在上百万甚至上亿的向量中找到与给定向量最相似的Top-K个向量，使用传统数据库进行暴力计算，其复杂度和耗时是无法接受的。</p><p>向量数据库的解决方案:</p><p>向量数据库的核心技术是 <strong>近似最近邻搜索（Approximate Nearest Neighbor, ANN）</strong> 算法。</p><ul><li><strong>ANN算法</strong>: 它不追求100%精确地找到最近邻，而是在可接受的精度损失下，以极高的效率和速度找到与查询向量高度相似的结果。</li><li><strong>索引结构</strong>: ANN算法通过构建特殊的索引结构（如HNSW, IVF, LSH, Faiss等）来实现快速检索。这些索引将高维向量组织在特定的数据结构中，使得搜索时可以快速剪枝，避免全局扫描。</li></ul><p><strong>主要功能和特点</strong>:</p><ol><li><strong>高效的相似性搜索 (ANN Search)</strong>: 这是最核心的功能。</li><li><strong>海量向量存储</strong>: 能够管理数十亿甚至更多的向量数据。</li><li><strong>支持元数据 (Metadata) 存储和过滤</strong>: 可以在存储向量的同时，为其附加一些标量字段（如ID、类别、时间戳等）。查询时可以先通过元数据进行过滤（例如，只在“类别A”的商品中搜索），然后再进行向量相似性搜索。</li><li><strong>易用的API</strong>: 提供友好的SDK和API，方便开发者进行数据插入和查询。</li><li><strong>高可用和可扩展</strong>: 通常被设计为分布式系统，支持水平扩展和高可用。</li></ol><p><strong>应用场景</strong>:</p><ul><li><strong>以图搜图/视频搜索</strong>: 输入一张图片，找到相似的图片。</li><li><strong>语义文本搜索/智能问答</strong>: 输入一个问题，在海量文档中找到语义最相关的答案。这是大型语言模型（LLM）应用中RAG（Retrieval-Augmented Generation）架构的核心组件。</li><li><strong>推荐系统</strong>: 根据用户的行为向量，推荐相似的商品或内容。</li><li><strong>异常检测</strong>: 在向量空间中，离群的向量点可能代表异常数据。</li><li><strong>药物发现/分子匹配</strong>: 在化学领域，分子结构可以被表示为向量，用于寻找相似的分子。</li></ul><p><strong>主流的向量数据库产品</strong>:</p><ul><li><strong>开源</strong>: Milvus, Weaviate, Qdrant, Chroma</li><li><strong>云服务/商业版</strong>: Pinecone, Zilliz Cloud (Milvus的商业版), Redis (通过RediSearch模块), Elasticsearch (通过k-NN插件) 等也提供了向量搜索能力。</li></ul></blockquote><h2 id="欧斯特智能-二面" tabindex="-1"><a class="header-anchor" href="#欧斯特智能-二面"><span>欧斯特智能(二面)</span></a></h2><p><strong>2025.09.03</strong></p><ul><li>介绍一下你的网关项目</li><li>你的网关项目相比SpringCloud Gateway有什么优势?</li><li>介绍一下grpc</li><li>介绍一下你定义的后置处理器是怎么工作的</li><li>写一个批量插入的代码示例</li><li>Stream和for循环有什么区别?</li><li>Springboot2和3分别怎么实现自动装配的?</li><li>说一下ConditionOn注解</li><li>怎么实现一个bean在另一个bean之后加载呢?</li><li>yaml配置文件的两种读取方法</li><li>循环依赖怎么解决?</li><li>说一下AOP和它的几个概念</li><li>说一下Rocketmq的四种通知方式(广播路由什么的)</li><li>一些前端问题</li></ul><blockquote><h3 id="_1-介绍一下你的网关项目" tabindex="-1"><a class="header-anchor" href="#_1-介绍一下你的网关项目"><span>1. 介绍一下你的网关项目</span></a></h3><p>我的网关项目是一个基于 Netty 和 Spring Boot 构建的微服务网关，其核心设计思想是 <strong>责任链模式</strong> 和 <strong>分布式服务治理</strong> 。</p><p><strong>核心功能模块包括：</strong></p><ul><li><strong>网关核心模块 (<code>api-gateway-core</code>)</strong>: 作为请求处理的核心入口，基于 Netty 实现，通过责任链模式 对请求进行处理。处理链包括： <ul><li><strong>鉴权处理器 (<code>AuthorizationHandler</code>)</strong>: 基于 JWT 对请求进行鉴权。</li><li><strong>自定义处理器 (<code>PreExecutorHandler</code>, <code>PostExecutorHandler</code>)</strong>: 支持灵活的自定义熔断、限流、日志等操作。</li><li><strong>请求调用处理器 (<code>ExecutorHandler</code>)</strong>: 解析请求类型并发送请求（支持 HTTP 和 Dubbo RPC）。</li><li><strong>结果包装处理器 (<code>ResultHandler</code>)</strong>: 对返回结果进行统一的包装。</li></ul></li><li><strong>网关中心模块 (<code>api-gateway-center</code>)</strong>: <ul><li><strong>配置管理</strong>: 动态加载并刷新 Redis 和 Nginx 配置，支持负载均衡策略更新。</li><li><strong>服务注册与发现</strong>: 服务提供者通过 SDK 注册服务信息，Redis 存储服务元数据，并定时同步数据库信息到 Redis。</li><li><strong>心跳与续约</strong>: 服务启动时主动注册，后续定期发送心跳续约。</li></ul></li><li><strong>SDK 模块</strong>: <ul><li><strong>服务注册 SDK (<code>server-find-sdk</code>)</strong>: 自动加载配置，扫描自定义注解并上传接口信息。</li><li><strong>请求调用 SDK (<code>server-send-sdk</code>)</strong>: 提供便捷的请求调用方式，支持失败重试。</li></ul></li></ul><h3 id="_2-你的网关项目相比-springcloud-gateway-有什么优势" tabindex="-1"><a class="header-anchor" href="#_2-你的网关项目相比-springcloud-gateway-有什么优势"><span><strong>2. 你的网关项目相比 SpringCloud Gateway 有什么优势?</strong></span></a></h3><p>我的网关项目在设计上借鉴了 Spring Cloud Gateway 的思想，但在某些方面提供了更轻量级和更具定制化的解决方案：</p><ul><li><strong>高性能网络核心</strong>：直接使用 Netty 作为网络框架，提供了更底层的控制能力和更高的性能潜力。</li><li><strong>高度可扩展的责任链模式</strong>：通过自定义的前置和后置处理器，可以非常灵活地实现鉴权、限流、熔断、日志等功能，并且可以自由排序。</li><li><strong>双协议支持</strong>：原生支持 HTTP 和 Dubbo 两种协议的泛化调用，可以更好地适应异构系统。</li><li><strong>动态配置和服务发现</strong>：通过网关中心和 Redis 实现动态配置和服务发现，可以实时更新路由规则和负载均衡策略。</li><li><strong>轻量级</strong>：相比于 Spring Cloud Gateway，我的项目更加轻量级，核心模块的依赖更少，更易于理解和维护。</li></ul><h3 id="_3-介绍一下-grpc" tabindex="-1"><a class="header-anchor" href="#_3-介绍一下-grpc"><span><strong>3. 介绍一下 gRPC</strong></span></a></h3><p>gRPC (Google Remote Procedure Call) 是一个由 Google 开发的高性能、开源的通用 RPC (Remote Procedure Call) 框架。它可以在任何环境下运行，并且可以用任何语言编写。</p><p><strong>主要特点:</strong></p><ul><li><strong>基于 HTTP/2</strong>: gRPC 使用 HTTP/2 作为其传输协议，这带来了多路复用、头部压缩、服务器推送等特性，从而实现了更低的延迟和更高的吞吐量。</li><li><strong>协议缓冲区 (Protocol Buffers)</strong>: gRPC 默认使用 Protocol Buffers 作为其接口定义语言 (IDL) 和消息交换格式。Protocol Buffers 是一种轻量级、高效的二进制序列化格式，比 JSON 或 XML 更快、更小。</li><li><strong>多语言支持</strong>: gRPC 支持多种编程语言，包括 Java, C++, Python, Go, Ruby, C#, Node.js, Android Java, Objective-C 和 PHP。</li><li><strong>流式处理</strong>: gRPC 支持四种类型的流式处理： <ul><li>一元 RPC: 客户端发送一个请求，服务器返回一个响应。</li><li>服务器流式 RPC: 客户端发送一个请求，服务器返回一个流式的响应。</li><li>客户端流式 RPC: 客户端发送一个流式的请求，服务器返回一个响应。</li><li>双向流式 RPC: 客户端和服务器都可以发送一个流式的请求和响应。</li></ul></li></ul><h3 id="_4-介绍一下你定义的后置处理器是怎么工作的" tabindex="-1"><a class="header-anchor" href="#_4-介绍一下你定义的后置处理器是怎么工作的"><span><strong>4. 介绍一下你定义的后置处理器是怎么工作的</strong></span></a></h3><p>我定义的后置处理器是通过 <code>CustomPostHandler</code> 接口和 <code>PostExecutorHandler</code> 类实现的。</p><ul><li><strong><code>CustomPostHandler</code> 接口</strong>: 这是一个自定义的后置处理器接口，所有自定义的后置处理器都需要实现这个接口，并实现 <code>handle</code> 方法和 <code>getOrder</code> 方法。</li><li><strong><code>PostExecutorHandler</code> 类</strong>: 这个类是后置处理器的执行器，它会收集所有实现了 <code>CustomPostHandler</code> 接口的 Bean，并根据 <code>getOrder</code> 方法返回的顺序进行排序。然后，它会依次执行这些后置处理器的 <code>handle</code> 方法。如果某个处理器返回了一个非 <code>null</code> 的 <code>Result</code> 对象，那么处理链就会被终止，并且该 <code>Result</code> 对象会被直接返回给客户端。</li></ul><h3 id="_5-写一个批量插入的代码示例" tabindex="-1"><a class="header-anchor" href="#_5-写一个批量插入的代码示例"><span><strong>5. 写一个批量插入的代码示例</strong></span></a></h3><p>这是一个使用 MyBatis-Plus 进行批量插入的示例，在你的项目中已经引入了 MyBatis-Plus 依赖。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Service</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BatchInsertService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Resource</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> YourMapper</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> yourMapper</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Transactional</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> batchInsert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">YourEntity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">entityList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 每次批量插入的数量</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> batchSize</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> entityList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> batchSize) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> toIndex</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> batchSize, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">entityList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            yourMapper</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">insertBatchSomeColumn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">entityList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">subList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i, toIndex));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在 YourMapper.java (或者相应的 XML 文件) 中定义 insertBatchSomeColumn 方法</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> YourMapper</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BaseMapper</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">YourEntity</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Integer</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> insertBatchSomeColumn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">YourEntity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">entityList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在 YourMapper.xml 文件中</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">insert id</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;insertBatchSomeColumn&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    INSERT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> INTO</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> your_table</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (column1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> column2) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">VALUES</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">    &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">foreach collection</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;list&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> item</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;item&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> separator</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;,&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        (#{</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">item</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">field1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> #{</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">item</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">field2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">})</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">    &lt;/</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">foreach</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;/</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">insert</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-stream-和-for-循环有什么区别" tabindex="-1"><a class="header-anchor" href="#_6-stream-和-for-循环有什么区别"><span><strong>6. Stream 和 for 循环有什么区别?</strong></span></a></h3><p>Stream 和 for 循环都是用来遍历集合的，但它们之间存在一些重要的区别：</p><ul><li><strong>声明性 vs. 命令性</strong>: Stream 是声明性的，你只需要描述你想要做什么，而不需要关心如何做。而 for 循环是命令性的，你需要明确地指定每一步的操作。</li><li><strong>内部迭代 vs. 外部迭代</strong>: Stream 使用内部迭代，它会自动地为你处理迭代的过程。而 for 循环使用外部迭代，你需要手动地控制迭代的过程。</li><li><strong>链式操作</strong>: Stream 支持链式操作，你可以将多个操作连接在一起，形成一个流水线。这使得代码更加简洁、易读。</li><li><strong>并行处理</strong>: Stream 可以很容易地进行并行处理，只需要调用 <code>parallel()</code> 方法即可。这可以充分利用多核处理器的优势，提高处理效率。</li><li><strong>无状态</strong>: Stream 的操作通常是无状态的，它们不会修改原始的集合。这使得代码更加安全、易于调试。</li></ul><h3 id="_7-springboot-2-和-3-分别怎么实现自动装配的" tabindex="-1"><a class="header-anchor" href="#_7-springboot-2-和-3-分别怎么实现自动装配的"><span><strong>7. Springboot 2 和 3 分别怎么实现自动装配的?</strong></span></a></h3><ul><li><strong>Spring Boot 2</strong>: <ul><li>主要通过 <code>META-INF/spring.factories</code> 文件来实现自动装配。</li><li>在这个文件中，通过 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> key 来指定需要自动装配的配置类。</li><li>Spring Boot 在启动时会扫描所有 <code>spring.factories</code> 文件，并加载其中指定的配置类。</li></ul></li><li><strong>Spring Boot 3</strong>: <ul><li>从 Spring Boot 2.7 开始，推荐使用新的自动装配方式，并在 Spring Boot 3.0 中成为默认方式。</li><li>新的方式是，在 <code>META-INF/spring/</code> 目录下创建一个名为 <code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 的文件。</li><li>在这个文件中，每一行列出一个自动配置类的全限定名。</li><li>这种方式比 <code>spring.factories</code> 更高效，因为 Spring Boot 可以直接读取这个文件，而不需要解析 <code>spring.factories</code> 的格式。</li></ul></li></ul><h3 id="_8-说一下-conditionon-注解" tabindex="-1"><a class="header-anchor" href="#_8-说一下-conditionon-注解"><span><strong>8. 说一下 ConditionOn 注解</strong></span></a></h3><p><code>@ConditionalOn</code> 是 Spring Boot 提供的一系列条件注解，它们可以根据不同的条件来决定是否创建一个 Bean。这使得我们可以更加灵活地配置我们的应用程序。</p><p>一些常用的 <code>@ConditionalOn</code> 注解包括：</p><ul><li><code>@ConditionalOnBean</code>: 当容器中存在指定的 Bean 时，才会创建当前的 Bean。</li><li><code>@ConditionalOnClass</code>: 当类路径下存在指定的类时，才会创建当前的 Bean。</li><li><code>@ConditionalOnExpression</code>: 当指定的 SpEL 表达式返回 <code>true</code> 时，才会创建当前的 Bean。</li><li><code>@ConditionalOnMissingBean</code>: 当容器中不存在指定的 Bean 时，才会创建当前的 Bean。</li><li><code>@ConditionalOnProperty</code>: 当指定的属性存在并且具有指定的值时，才会创建当前的 Bean。</li><li><code>@ConditionalOnResource</code>: 当类路径下存在指定的资源时，才会创建当前的 Bean。</li></ul><h3 id="_9-怎么实现一个-bean-在另一个-bean-之后加载呢" tabindex="-1"><a class="header-anchor" href="#_9-怎么实现一个-bean-在另一个-bean-之后加载呢"><span><strong>9. 怎么实现一个 bean 在另一个 bean 之后加载呢?</strong></span></a></h3><p>在 Spring 中，我们可以使用 <code>@DependsOn</code> 注解来指定一个 Bean 的加载顺序。</p><p>Java</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>@Component</span></span>
<span class="line"><span>public class BeanA {</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@Component</span></span>
<span class="line"><span>@DependsOn(&quot;beanA&quot;)</span></span>
<span class="line"><span>public class BeanB {</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>BeanB</code> 会在 <code>BeanA</code> 加载之后再加载。</p><h3 id="_10-yaml-配置文件的两种读取方法" tabindex="-1"><a class="header-anchor" href="#_10-yaml-配置文件的两种读取方法"><span><strong>10. yaml 配置文件的两种读取方法</strong></span></a></h3><p>在 Spring Boot 中，我们可以使用 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 注解来读取 <code>application.yml</code> 配置文件中的属性。</p><ul><li><strong><code>@ConfigurationProperties</code></strong>: <ul><li>这个注解可以将配置文件中的一组属性映射到一个 Java 对象中。</li><li>它支持类型安全的配置，并且可以很好地与 JSR-303 验证注解配合使用。</li><li>在你的项目中，<code>GlobalConfiguration.java</code> 就是一个很好的例子。</li></ul></li><li><strong><code>@Value</code></strong>: <ul><li>这个注解可以用来读取单个的配置属性。</li><li>它支持 SpEL 表达式，可以进行更加灵活的配置。</li></ul></li></ul><h3 id="_11-循环依赖怎么解决" tabindex="-1"><a class="header-anchor" href="#_11-循环依赖怎么解决"><span><strong>11. 循环依赖怎么解决?</strong></span></a></h3><p>在 Spring 中，循环依赖是指两个或多个 Bean 相互依赖，形成一个闭环。Spring 默认可以解决 singleton-scoped bean 之间的循环依赖，但是对于 prototype-scoped bean 和构造函数注入的循环依赖，Spring 是无法解决的。</p><p><strong>解决方法:</strong></p><ul><li><strong>使用 <code>@Lazy</code> 注解</strong>: <code>@Lazy</code> 注解可以延迟一个 Bean 的初始化，直到它第一次被使用。这可以打破循环依赖。</li><li><strong>使用 <code>setter</code> 注入</strong>: 将构造函数注入改为 <code>setter</code> 注入。</li><li><strong>使用 <code>@PostConstruct</code> 注解</strong>: 可以在一个 Bean 的构造函数执行完毕之后，再进行一些初始化操作。</li><li><strong>重构代码</strong>: 重新设计你的代码，避免循环依赖的出现。</li></ul><h3 id="_12-说一下-aop-和它的几个概念" tabindex="-1"><a class="header-anchor" href="#_12-说一下-aop-和它的几个概念"><span><strong>12. 说一下 AOP 和它的几个概念</strong></span></a></h3><p>AOP (Aspect-Oriented Programming) 即面向切面编程，是一种编程范式，它允许我们通过分离横切关注点来增加程序的模块化。</p><p><strong>核心概念:</strong></p><ul><li><strong>切面 (Aspect)</strong>: 一个关注点的模块化，这个关注点可能会横切多个对象。</li><li><strong>连接点 (Join Point)</strong>: 程序执行过程中的一个点，例如一个方法的执行或者一个异常的处理。</li><li><strong>通知 (Advice)</strong>: 在切面的某个特定的连接点上执行的动作。</li><li><strong>切点 (Pointcut)</strong>: 匹配连接点的断言。</li><li><strong>引入 (Introduction)</strong>: 在不修改类代码的前提下，为类添加新的方法和属性。</li><li><strong>目标对象 (Target Object)</strong>: 被一个或者多个切面所通知的对象。</li><li><strong>AOP 代理 (AOP Proxy)</strong>: AOP 框架创建的对象，用来实现切面契约。</li><li><strong>织入 (Weaving)</strong>: 把切面连接到其他的应用程序类型或者对象上，来创建一个被通知的对象。</li></ul><h3 id="_13-说一下-rocketmq-的四种通知方式" tabindex="-1"><a class="header-anchor" href="#_13-说一下-rocketmq-的四种通知方式"><span><strong>13. 说一下 RocketMQ 的四种通知方式</strong></span></a></h3><p>RocketMQ 提供了四种发送消息的方式：</p><ul><li><strong>同步发送 (Sync)</strong>: 客户端发送一条消息，然后等待服务器的响应。</li><li><strong>异步发送 (Async)</strong>: 客户端发送一条消息，然后立即返回，不等待服务器的响应。当服务器处理完消息之后，会通过回调函数来通知客户端。</li><li><strong>单向发送 (Oneway)</strong>: 客户端发送一条消息，然后立即返回，不等待服务器的响应，也没有回调函数。</li><li><strong>顺序消息 (Ordered Message)</strong>: RocketMQ 可以保证消息按照发送的顺序被消费。</li></ul></blockquote><h2 id="智农天地-北京" tabindex="-1"><a class="header-anchor" href="#智农天地-北京"><span>智农天地(北京)</span></a></h2><p><strong>2025.09.04</strong></p><ul><li>做一个自我介绍</li><li>线程和进程有什么区别</li><li>说一下你编写代码中异步的体现</li><li>前端你有什么了解?</li><li>介绍一下你简历中这个票务平台的ai这一块内容</li><li>你对大模型还有什么其他应用吗?</li><li>说一下git的常用命令</li><li>linux的常用命令有什么</li><li>介绍一下向量数据库</li><li>如果实习的话学校这边OK吗?</li></ul><h2 id="智农天地-二面" tabindex="-1"><a class="header-anchor" href="#智农天地-二面"><span>智农天地(二面)</span></a></h2><p><strong>2025.09.04</strong></p><ul><li>做一个自我介绍</li><li>说一下你项目中ai是怎么用的</li><li>可以实习多久?</li><li>有没有什么实习要求?(你问我干嘛?)</li><li>工资给你开多少吧?(黑人问号)</li><li>多久可以有明确的答复?</li></ul><h2 id="美团-测开" tabindex="-1"><a class="header-anchor" href="#美团-测开"><span>美团(测开)</span></a></h2><p><strong>2025.09.05</strong></p><ul><li>介绍一下你的网关项目和核心组件</li><li>你说这个项目是根据美团的sherperd网关改写的,说一下你做了哪些改动</li><li>你在做这个项目过程中遇到了哪些困难?</li><li>你第二个购票系统有哪些项目亮点?</li><li>介绍一下AOP是什么</li><li>你是怎么保证热点数据的一致性的?(缓存一致性问题)</li><li>你是怎么做到分库分表?为什么要分库分表?</li><li>介绍一下你的AI项目和它的核心功能</li><li>说一说什么是MCP,你是怎么用的?</li><li>对于AI你还了解了其他的一些概念吗?(我说的向量数据库)</li><li>你是哪个高中的?(当时问的我一脸懵,后来才知道面试官也是长治人,太巧了哈哈哈哈)</li></ul><blockquote><p>手撕: 反转链表(写代码+说思路+另一种解法)</p><p>反问: 我们平常的工作是大概是什么？</p><p>​ 我们平常的工作中可以接触到业务代码吗？</p><p>​ 您介意把这个面试过程放到我的博客上吗?</p></blockquote></div><!----><!----><!----></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/1973034392/api-gateway-codelong/edit/main/src/interviews/index.md" aria-label="编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">最近更新</span><time class="vp-meta-info" datetime="2025-09-07T13:51:42.000Z" data-allow-mismatch>2025/9/7 13:51</time></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 1973034392@qq.com">1973034392</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><!----><div class="vp-copyright">Copyright © 2025 CodeLong </div></footer></div><!--]--><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-CMkao8yc.js" defer></script>
  </body>
</html>
