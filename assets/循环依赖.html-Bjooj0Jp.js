import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as s,o as t}from"./app-C5tnU83h.js";const a={};function o(l,e){return t(),i("div",null,e[0]||(e[0]=[s(`<h1 id="什么是循环依赖" tabindex="-1"><a class="header-anchor" href="#什么是循环依赖"><span>什么是循环依赖？</span></a></h1><p>循环依赖，顾名思义，就是两个或多个Bean之间相互依赖，形成一个闭环。最简单的形式是两个Bean互相依赖：</p><ul><li><strong>Bean A</strong> 依赖 <strong>Bean B</strong>。</li><li><strong>Bean B</strong> 又反过来依赖 <strong>Bean A</strong>。</li></ul><p>用代码表示就是：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BeanA</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BeanB</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> beanB</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BeanB</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BeanA</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> beanA</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当Spring容器启动并尝试创建这两个Bean时，就会遇到一个难题：</p><ol><li>要创建<code>BeanA</code>，必须先注入<code>BeanB</code>。</li><li>要获取<code>BeanB</code>，必须先创建<code>BeanB</code>。</li><li>要创建<code>BeanB</code>，又必须先注入<code>BeanA</code>。</li><li>这样就形成了一个“先有鸡还是先有蛋”的死循环。</li></ol><h2 id="spring如何解决循环依赖" tabindex="-1"><a class="header-anchor" href="#spring如何解决循环依赖"><span>Spring如何解决循环依赖？</span></a></h2><p>很多人会惊讶地发现，上面那个例子在Spring中居然可以正常运行！这是因为Spring设计了一套精巧的机制来解决<strong>单例（Singleton）作用域下，基于setter或字段注入</strong>的循环依赖问题。</p><p>这个机制的核心是<strong>三级缓存（Three-Level Cache）</strong>。</p><p>你可以把这三级缓存想象成三个不同状态的Bean“加工车间”：</p><ol><li><strong>一级缓存 (<code>singletonObjects</code>)：成品车间</strong><ul><li><strong>作用</strong>：存放已经<strong>完全初始化好</strong>的Bean实例。这些Bean已经经历了完整的生命周期，可以直接使用。</li><li><strong>类型</strong>：<code>Map&lt;String, Object&gt;</code></li></ul></li><li><strong>二级缓存 (<code>earlySingletonObjects</code>)：半成品车间</strong><ul><li><strong>作用</strong>：存放<strong>早期暴露</strong>的Bean实例。这些Bean已经被实例化，但可能尚未完成属性注入和初始化。它存在的意义是，如果一个Bean需要被AOP代理，那么其他Bean获取到的早期引用就应该是代理后的对象，而不是原始对象。</li><li><strong>类型</strong>：<code>Map&lt;String, Object&gt;</code></li></ul></li><li><strong>三级缓存 (<code>singletonFactories</code>)：原材料车间</strong><ul><li><strong>作用</strong>：存放用于创建早期Bean实例的<strong>工厂（ObjectFactory）</strong>。当一个Bean被实例化但尚未初始化时，Spring会创建一个工厂并放入三级缓存。这个工厂的<code>getObject()</code>方法被调用时，才会真正创建并返回一个“早期引用”的Bean。如果需要AOP，代理的创建就在这个工厂里完成。</li><li><strong>类型</strong>：<code>Map&lt;String, ObjectFactory&lt;?&gt;&gt;</code></li></ul></li></ol><h3 id="解决流程-a、b循环依赖为例" tabindex="-1"><a class="header-anchor" href="#解决流程-a、b循环依赖为例"><span>解决流程（A、B循环依赖为例）：</span></a></h3><p>让我们一步步跟踪Spring如何利用这三级缓存来打破循环：</p><ol><li><strong>创建BeanA</strong>： <ul><li>容器尝试从一级缓存获取<code>BeanA</code>，没找到。</li><li>容器开始创建<code>BeanA</code>，并将其标记为“正在创建中”。</li><li><strong>实例化<code>BeanA</code></strong>：通过构造函数创建一个<code>BeanA</code>的原始对象（此时<code>beanB</code>属性为<code>null</code>）。</li><li><strong>暴露早期引用</strong>：Spring并<strong>不直接</strong>将这个原始对象放入二级缓存，而是创建一个<code>ObjectFactory</code>（可以理解为一个lambda表达式 <code>() -&gt; getEarlyBeanReference(...)</code>），并以<code>&quot;beanA&quot;</code>为键存入<strong>三级缓存 (<code>singletonFactories</code>)</strong>。这个工厂的作用是，如果需要，它可以返回<code>BeanA</code>的早期引用（可能是原始对象，也可能是代理对象）。</li></ul></li><li><strong>注入BeanB到BeanA</strong>： <ul><li>Spring开始为<code>BeanA</code>填充属性，发现它需要<code>BeanB</code>。</li><li>容器尝试获取<code>BeanB</code>。</li></ul></li><li><strong>创建BeanB</strong>（这个过程与创建<code>BeanA</code>类似）： <ul><li>容器从一级缓存获取<code>BeanB</code>，没找到。</li><li>开始创建<code>BeanB</code>，标记为“正在创建中”。</li><li><strong>实例化<code>BeanB</code></strong>，创建一个原始对象（此时<code>beanA</code>属性为<code>null</code>）。</li><li>同样，为<code>BeanB</code>创建一个<code>ObjectFactory</code>并存入<strong>三级缓存</strong>。</li></ul></li><li><strong>注入BeanA到BeanB（关键一步）</strong>： <ul><li>Spring为<code>BeanB</code>填充属性，发现它需要<code>BeanA</code>。</li><li>容器尝试获取<code>BeanA</code>。</li><li><strong>检查缓存</strong>： <ul><li>首先在一级缓存（成品）中查找<code>beanA</code>，没找到。</li><li>然后检查<code>beanA</code>是否“正在创建中”，发现是的！</li><li>于是在二级缓存（半成品）中查找<code>beanA</code>，还是没找到。</li><li>最后，在**三级缓存（原材料）**中查找<code>beanA</code>的工厂，<strong>找到了！</strong></li></ul></li></ul></li><li><strong>打破循环</strong>： <ul><li>Spring从三级缓存中获取到<code>beanA</code>的<code>ObjectFactory</code>。</li><li>调用该工厂的<code>getObject()</code>方法，生成一个<code>BeanA</code>的<strong>早期引用</strong>（如果需要AOP，此时会创建代理）。</li><li>这个早期引用被放入<strong>二级缓存 (<code>earlySingletonObjects</code>)</strong>，并从三级缓存中移除对应的工厂。</li><li><code>BeanB</code>成功获取到了<code>BeanA</code>的早期引用，并完成了自己的属性注入。</li></ul></li><li><strong>完成BeanB的创建</strong>： <ul><li><code>BeanB</code>继续执行其后续的初始化流程（如<code>@PostConstruct</code>等）。</li><li>一个<strong>完全初始化</strong>的<code>BeanB</code>诞生了！</li><li>这个完整的<code>BeanB</code>被放入<strong>一级缓存 (<code>singletonObjects</code>)</strong>。</li></ul></li><li><strong>返回并完成BeanA的创建</strong>： <ul><li>现在，<code>BeanA</code>终于等到了它所依赖的<code>BeanB</code>（从一级缓存中获取）。</li><li><code>BeanA</code>完成了属性注入。</li><li><code>BeanA</code>继续执行其后续初始化流程。</li><li>一个<strong>完全初始化</strong>的<code>BeanA</code>也诞生了！</li><li>这个完整的<code>BeanA</code>被放入<strong>一级缓存</strong>（替换掉之前可能存在的早期引用）。</li></ul></li></ol><p>至此，循环依赖被成功解决。核心思想就是<strong>提前暴露一个未完成初始化的Bean的引用</strong>。</p><h2 id="spring无法解决的循环依赖" tabindex="-1"><a class="header-anchor" href="#spring无法解决的循环依赖"><span>Spring无法解决的循环依赖</span></a></h2><p>并非所有循环依赖都能被解决。以下两种情况是Spring无能为力的：</p><ol><li><strong>构造器注入（Constructor Injection）的循环依赖</strong><ul><li><strong>原因</strong>：当使用构造器注入时，对象的创建和依赖的注入是<strong>原子操作</strong>。必须在调用构造函数时就提供所有依赖。这意味着在<code>new BeanA(beanB)</code>时，<code>beanB</code>必须已经是一个完整的实例。在循环依赖的场景下，这显然无法做到，因为<code>new BeanB(beanA)</code>同样需要一个完整的<code>beanA</code>。对象无法被实例化，三级缓存机制也无从谈起。</li><li><strong>结果</strong>：Spring会直接抛出<code>BeanCurrentlyInCreationException</code>异常。</li></ul></li><li><strong>原型作用域（Prototype Scope）的循环依赖</strong><ul><li><strong>原因</strong>：Spring容器<strong>不缓存</strong>原型Bean。每次请求都会创建一个全新的实例，并且Spring不会管理其完整的生命周期（特别是销毁阶段）。因此，无法通过缓存来提前暴露引用，从而打破循环。</li><li><strong>结果</strong>：同样会抛出<code>BeanCurrentlyInCreationException</code>。</li></ul></li></ol><h2 id="如何处理和避免循环依赖" tabindex="-1"><a class="header-anchor" href="#如何处理和避免循环依赖"><span>如何处理和避免循环依赖？</span></a></h2><p>虽然Spring能够处理某些循环依赖，但这通常被认为是<strong>代码设计不良的信号（Code Smell）</strong>。它表明你的类职责划分不清，耦合度过高。</p><p><strong>最佳实践是避免它，而不是依赖Spring去解决它。</strong></p><ol><li><p><strong>重新设计和重构（最佳方案）</strong></p><ul><li>审视你的类设计。A和B是否真的需要直接相互引用？</li><li><strong>提取新类</strong>：将两个Bean共享的逻辑提取到一个新的第三个类C中，让A和B都依赖C。</li><li><strong>使用接口</strong>：面向接口编程，降低耦合度，有时也能帮助理清依赖关系。</li></ul></li><li><p><strong>使用 <code>@Lazy</code> 注解</strong></p><ul><li><p>在注入点使用<code>@Lazy</code>注解可以打破循环。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Component</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BeanA</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Lazy</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 关键点</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BeanB</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> beanB</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>原理</strong>：Spring在注入<code>beanB</code>时，不会立即去获取<code>BeanB</code>的实例，而是会创建一个<code>BeanB</code>的<strong>代理对象</strong>注入给<code>BeanA</code>。只有当<code>BeanA</code>第一次实际调用<code>beanB</code>的方法时，这个代理对象才会真正去容器中获取<code>BeanB</code>的实例来执行方法。这相当于推迟了依赖的获取，从而打破了创建时的循环。</p></li></ul></li><li><p><strong>使用 Setter/Field 注入</strong></p><ul><li>如前所述，确保你的循环依赖是基于setter或字段注入的，而不是构造器注入。</li></ul></li><li><p><strong>实现 <code>ApplicationContextAware</code> 或使用 <code>@PostConstruct</code></strong></p><ul><li>这是一种更手动的解决方案。你可以不通过<code>@Autowired</code>注入，而是让Bean实现<code>ApplicationContextAware</code>接口，在容器设置好<code>ApplicationContext</code>后，手动调用<code>applicationContext.getBean()</code>来获取依赖。或者在<code>@PostConstruct</code>标记的方法中手动获取。这种方法破坏了IoC的原则，不推荐使用。</li></ul></li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><table><thead><tr><th>依赖注入方式</th><th>作用域</th><th>是否能解决</th><th>原因</th></tr></thead><tbody><tr><td><strong>Setter/Field注入</strong></td><td><strong>Singleton</strong></td><td>✅ <strong>能</strong></td><td>通过三级缓存和提前暴露早期引用。</td></tr><tr><td><strong>Constructor注入</strong></td><td>Singleton</td><td>❌ <strong>不能</strong></td><td>无法实例化对象，依赖需要在构造时就绪。</td></tr><tr><td>任何方式</td><td><strong>Prototype</strong></td><td>❌ <strong>不能</strong></td><td>不缓存Bean，无法提前暴露引用。</td></tr></tbody></table><p>希望这个详细的解释能帮助你彻底理解Spring中的循环依赖问题！</p>`,26)]))}const c=n(a,[["render",o]]),p=JSON.parse('{"path":"/8gu/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html","title":"什么是循环依赖？","lang":"zh-CN","frontmatter":{"description":"什么是循环依赖？ 循环依赖，顾名思义，就是两个或多个Bean之间相互依赖，形成一个闭环。最简单的形式是两个Bean互相依赖： Bean A 依赖 Bean B。 Bean B 又反过来依赖 Bean A。 用代码表示就是： 当Spring容器启动并尝试创建这两个Bean时，就会遇到一个难题： 要创建BeanA，必须先注入BeanB。 要获取BeanB，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"什么是循环依赖？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-14T03:48:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"什么是循环依赖？"}],["meta",{"property":"og:description","content":"什么是循环依赖？ 循环依赖，顾名思义，就是两个或多个Bean之间相互依赖，形成一个闭环。最简单的形式是两个Bean互相依赖： Bean A 依赖 Bean B。 Bean B 又反过来依赖 Bean A。 用代码表示就是： 当Spring容器启动并尝试创建这两个Bean时，就会遇到一个难题： 要创建BeanA，必须先注入BeanB。 要获取BeanB，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-14T03:48:22.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-14T03:48:22.000Z"}]]},"git":{"createdTime":1755143302000,"updatedTime":1755143302000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":1,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":6.75,"words":2026},"filePathRelative":"8gu/循环依赖.md","autoDesc":true}');export{c as comp,p as data};
