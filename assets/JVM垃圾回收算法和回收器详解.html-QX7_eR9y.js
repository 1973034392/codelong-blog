import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as o,o as s}from"./app-CgCeWHAB.js";const a={};function e(l,t){return s(),n("div",null,t[0]||(t[0]=[o('<h1 id="jvm垃圾回收算法与回收器详解" tabindex="-1"><a class="header-anchor" href="#jvm垃圾回收算法与回收器详解"><span>JVM垃圾回收算法与回收器详解</span></a></h1><p>在Java虚拟机（JVM）中，垃圾回收（Garbage Collection, GC）是一项至关重要的自动内存管理机制。它的核心任务是识别并回收不再被程序使用的对象所占用的内存。理解其背后的算法和不同的回收器实现，对于进行JVM调优和构建高性能Java应用至关重要。</p><h2 id="一、-核心垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#一、-核心垃圾回收算法"><span>一、 核心垃圾回收算法</span></a></h2><p>GC算法是垃圾回收器实现其功能的理论基础。在进行回收前，首先需要解决一个问题：<strong>如何判断对象是“垃圾”？</strong> 目前主流的方法是<strong>可达性分析（Reachability Analysis）</strong>。该算法将一系列称为“GC Roots”的对象作为起点（如虚拟机栈中引用的对象、静态属性引用的对象等），从这些节点开始向下搜索，凡是能够被搜索到的对象都被认为是“存活”的，反之则为“垃圾”。</p><p>确定了垃圾之后，就轮到具体的回收算法登场了。</p><h3 id="_1-标记-清除-mark-sweep-算法" tabindex="-1"><a class="header-anchor" href="#_1-标记-清除-mark-sweep-算法"><span>1. 标记-清除（Mark-Sweep）算法</span></a></h3><p>这是最基础的回收算法，分为两个阶段：</p><ul><li><strong>标记（Mark）</strong>：遍历所有GC Roots，标记所有可达的（存活的）对象。</li><li><strong>清除（Sweep）</strong>：遍历整个堆，回收所有未被标记的对象所占用的空间。</li><li><strong>优点</strong>：实现简单，不需要移动对象。</li><li><strong>缺点</strong>： <ul><li><strong>效率问题</strong>：标记和清除两个过程的效率都不算高。</li><li><strong>空间碎片化</strong>：清除后会产生大量不连续的内存碎片。当需要分配一个较大的对象时，可能会因为找不到足够大的连续空间而不得不提前触发又一次GC。</li></ul></li></ul><h3 id="_2-标记-复制-mark-copy-算法" tabindex="-1"><a class="header-anchor" href="#_2-标记-复制-mark-copy-算法"><span>2. 标记-复制（Mark-Copy）算法</span></a></h3><p>为了解决碎片化问题，复制算法应运而生。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</p><ul><li><strong>过程</strong>：当这一块内存用完时，就将还存活的对象<strong>复制</strong>到另一块上面，然后再把已使用过的内存空间一次性清理掉。</li><li><strong>优点</strong>： <ul><li><strong>无内存碎片</strong>：每次回收后，内存都是连续的。</li><li><strong>实现简单，运行高效</strong>：尤其是在存活对象很少的情况下，复制操作的成本很低。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>空间浪费</strong>：可用内存缩小为原来的一半，代价较高。</li></ul></li></ul><h3 id="_3-标记-整理-mark-compact-算法" tabindex="-1"><a class="header-anchor" href="#_3-标记-整理-mark-compact-算法"><span>3. 标记-整理（Mark-Compact）算法</span></a></h3><p>该算法结合了“标记-清除”和“标记-复制”的优点，旨在解决前者的碎片化问题和后者的空间浪费问题。</p><ul><li><strong>过程</strong>： <ul><li><strong>标记（Mark）</strong>：过程与“标记-清除”算法一样。</li><li><strong>整理（Compact）</strong>：不是直接清理未标记对象，而是将所有存活的对象都向内存空间的一端移动，然后直接清理掉端边界以外的内存。</li></ul></li><li><strong>优点</strong>： <ul><li><strong>无内存碎片</strong>：解决了碎片化问题。</li><li><strong>空间利用率高</strong>：没有像复制算法那样的空间浪费。</li></ul></li><li><strong>缺点</strong>： <ul><li><strong>效率较低</strong>：移动对象是一个相对耗时的操作，需要更新所有指向这些对象的引用。</li></ul></li></ul><h3 id="_4-分代收集-generational-collection-算法" tabindex="-1"><a class="header-anchor" href="#_4-分代收集-generational-collection-算法"><span>4. 分代收集（Generational Collection）算法</span></a></h3><p>这是当前商业虚拟机普遍采用的核心思想，它并非一种具体的算法，而是一种<strong>策略</strong>。该策略基于一个重要的观察：<strong>绝大多数对象都是“朝生夕死”的</strong>。</p><ul><li><strong>核心思想</strong>：根据对象存活周期的不同将内存划分为几个区域，主要是<strong>新生代（Young Generation）**和**老年代（Old Generation）</strong>。 <ul><li><strong>新生代</strong>：存放生命周期短的对象。每次GC时都有大量对象被回收，只有少量存活。因此，新生代通常采用<strong>标记-复制算法</strong>，只需付出少量存活对象的复制成本就可以完成收集。新生代内部又细分为一个Eden区和两个Survivor区（From/To）。</li><li><strong>老年代</strong>：存放生命周期长或者经历过多次新生代GC后依然存活的对象。老年代对象存活率高，没有额外空间对它进行分配担保，因此必须使用<strong>标记-清除</strong>或<strong>标记-整理</strong>算法进行回收。</li></ul></li></ul><h2 id="二、-主流垃圾回收器" tabindex="-1"><a class="header-anchor" href="#二、-主流垃圾回收器"><span>二、 主流垃圾回收器</span></a></h2><p>垃圾回收器是GC算法的具体实现。它们在单线程/多线程、并发/并行、以及目标（吞吐量优先/停顿时间优先）等方面有所不同。</p><h3 id="_1-serial-serial-old" tabindex="-1"><a class="header-anchor" href="#_1-serial-serial-old"><span>1. Serial / Serial Old</span></a></h3><ul><li><strong>特点</strong>：<strong>单线程</strong>工作的垃圾回收器。“Serial”体现在它进行垃圾回收时，必须暂停所有其他的工作线程（这个过程称为“Stop-The-World”, STW）。</li><li><strong>算法</strong>：新生代使用“标记-复制”，老年代使用“标记-整理”。</li><li><strong>适用场景</strong>：主要用于<strong>客户端模式</strong>下的虚拟机，或者在硬件配置较低（如单核CPU）的环境中。对于交互不强的后台计算任务也是一个选择。</li></ul><h3 id="_2-parallel-scavenge-parallel-old" tabindex="-1"><a class="header-anchor" href="#_2-parallel-scavenge-parallel-old"><span>2. Parallel Scavenge / Parallel Old</span></a></h3><ul><li><strong>特点</strong>：Serial回收器的<strong>多线程版本</strong>。在GC期间，它会使用多个线程并行地进行垃圾回收，从而缩短STW的时间。</li><li><strong>关注点</strong>：<strong>高吞吐量（Throughput）</strong>。吞吐量 = 用户代码运行时间 / (用户代码运行时间 + GC时间)。它致力于让单位时间内完成尽可能多的用户任务。</li><li><strong>算法</strong>：新生代使用“标记-复制”，老年代使用“标记-整理”。</li><li><strong>适用场景</strong>：在<strong>后台计算</strong>、数据处理等不需要太多交互，且能容忍一定停顿时间的场景。这是<strong>JDK 8及之前版本的默认回收器</strong>。</li></ul><h3 id="_3-cms-concurrent-mark-sweep" tabindex="-1"><a class="header-anchor" href="#_3-cms-concurrent-mark-sweep"><span>3. CMS (Concurrent Mark Sweep)</span></a></h3><ul><li><strong>特点</strong>：一款以获取<strong>最短回收停顿时间</strong>为目标的回收器。它在GC的大部分阶段（如并发标记、并发清除）都允许用户线程和GC线程<strong>并发执行</strong>，从而显著降低STW时间。</li><li><strong>关注点</strong>：<strong>低延迟（Low Latency）</strong>。</li><li><strong>算法</strong>：基于“<strong>标记-清除</strong>”算法实现。</li><li><strong>缺点</strong>： <ol><li><strong>对CPU资源敏感</strong>：并发阶段会占用一部分CPU，导致用户程序变慢。</li><li><strong>产生“浮动垃圾”</strong>：在并发清理阶段，用户线程新产生的垃圾无法被本次GC处理，只能留到下一次。</li><li><strong>内存碎片</strong>：基于“标记-清除”算法，会产生大量碎片，可能导致Full GC。</li></ol></li><li><strong>状态</strong>：在 <strong>JDK 9 中被标记为废弃</strong>，在 <strong>JDK 14 中被移除</strong>。</li></ul><h3 id="_4-g1-garbage-first" tabindex="-1"><a class="header-anchor" href="#_4-g1-garbage-first"><span>4. G1 (Garbage-First)</span></a></h3><ul><li><strong>特点</strong>：一款面向服务端应用的、开创性的垃圾回收器。它将整个Java堆划分为多个大小相等的独立区域（Region），并跟踪这些Region里垃圾的价值大小，在后台维护一个优先列表，每次根据<strong>可预测的停顿时间</strong>，优先回收价值最大的Region。</li><li><strong>关注点</strong>：在<strong>高吞吐量</strong>和<strong>低延迟</strong>之间取得平衡，并提供<strong>可预测的停顿时间模型</strong>。</li><li><strong>算法</strong>：从整体来看是基于“<strong>标记-整理</strong>”算法，从局部（两个Region之间）来看是基于“<strong>标记-复制</strong>”算法。这意味着它不会产生内存碎片。</li><li><strong>适用场景</strong>：大内存（6GB以上）的多核服务器，要求兼顾吞吐量和延迟。<strong>自JDK 9起成为默认的垃圾回收器</strong>。</li></ul><h3 id="_5-zgc-the-z-garbage-collector-超低延迟回收器" tabindex="-1"><a class="header-anchor" href="#_5-zgc-the-z-garbage-collector-超低延迟回收器"><span>5. ZGC (The Z Garbage Collector) - 超低延迟回收器</span></a></h3><p>ZGC 是一款革命性的垃圾回收器，其设计目标只有一个：<strong>实现可扩展的、极低延迟的垃圾回收</strong>。它致力于将 STW（Stop-The-World）停顿时间控制在<strong>毫秒甚至亚毫秒级别</strong>，并且这个停顿时间不会随着堆内存或存活对象大小的增加而增长。</p><h4 id="zgc-的核心设计与关键技术" tabindex="-1"><a class="header-anchor" href="#zgc-的核心设计与关键技术"><span>ZGC 的核心设计与关键技术</span></a></h4><ul><li><strong>基于 Region 的堆内存布局 (ZPages)</strong>：与 G1 类似，ZGC 也将堆划分为多个区域（ZPage），但 ZPage 的大小是动态的（分为小、中、大三类），管理更灵活。</li><li><strong>着色指针 (Colored Pointers)</strong>：这是 ZGC 最具颠覆性的核心技术。它将对象的标记信息直接存储在 64 位的指针中，而不是对象头里。这使得 GC 在并发处理时能快速判断对象状态，而无需访问对象本身。</li><li><strong>读屏障 (Load Barrier)</strong>：为了配合着色指针，JIT 编译器会在从堆中加载对象引用的地方注入一小段代码（读屏障）。当应用线程访问对象时，读屏障会检查指针的“颜色”，如果发现对象已被移动，它会负责修正指针到新地址（这个过程也叫“自愈”），从而实现并发的对象转移。</li><li><strong>多重映射 (Multi-Mapping)</strong>：ZGC 利用虚拟内存技术，将同一块物理内存映射到三个不同的虚拟地址空间，分别对应指针的不同状态。这使得读屏障可以高效地判断指针状态，而无需执行复杂的逻辑。</li></ul><h4 id="zgc-的垃圾回收周期" tabindex="-1"><a class="header-anchor" href="#zgc-的垃圾回收周期"><span>ZGC 的垃圾回收周期</span></a></h4><p>ZGC 的一次完整 GC 周期绝大部分工作都是并发执行的，仅包含短暂的 STW。</p><ol><li><strong>初始标记 (Pause Mark Start) - STW</strong>：标记 GC Roots 直接引用的对象，速度极快。</li><li><strong>并发标记 (Concurrent Mark)</strong>：并发遍历对象图，找出所有存活对象。</li><li><strong>再标记 (Pause Mark End) - STW</strong>：处理并发标记期间发生变化的对象。</li><li><strong>并发重定位/转移 (Concurrent Relocate)</strong>：并发地将存活对象复制到新的 Region，消除碎片。</li></ol><h4 id="演进与总结" tabindex="-1"><a class="header-anchor" href="#演进与总结"><span>演进与总结</span></a></h4><ul><li><strong>分代 ZGC (Generational ZGC)</strong>：从 JDK 21 开始，ZGC 引入了分代机制，可以更高效地回收生命周期短的对象，进一步降低了 GC 开销和 CPU 占用。</li><li><strong>优点</strong>：极低的停顿时间、高可扩展性（支持 TB 级堆）、无内存碎片。</li><li><strong>缺点</strong>：相对消耗更多的 CPU 资源，且仅支持 64 位平台。</li></ul><h3 id="_6-shenandoah" tabindex="-1"><a class="header-anchor" href="#_6-shenandoah"><span>6. Shenandoah</span></a></h3><p>Shenandoah 是另一款与 ZGC 目标相似（追求极低延迟）的垃圾回收器，由 Red Hat 主导开发。它也采用了并发标记和并发整理技术，但其实现细节（如通过转发指针而非着色指针）与 ZGC 不同。它同样是一款优秀的低延迟回收器。</p><h2 id="三、-总结与对比" tabindex="-1"><a class="header-anchor" href="#三、-总结与对比"><span>三、 总结与对比</span></a></h2><table><thead><tr><th>回收器名称</th><th>工作线程</th><th>核心关注点</th><th>主要算法</th><th>STW时间</th><th>适用场景</th><th>JDK版本信息</th></tr></thead><tbody><tr><td><strong>Serial</strong></td><td>单线程</td><td>响应速度</td><td>标记-复制 / 标记-整理</td><td>长</td><td>客户端模式，单核CPU</td><td>所有版本</td></tr><tr><td><strong>Parallel Scavenge</strong></td><td>多线程</td><td><strong>高吞吐量</strong></td><td>标记-复制 / 标记-整理</td><td>中等</td><td>后台计算，数据处理</td><td><strong>JDK 8及之前默认</strong></td></tr><tr><td><strong>CMS</strong></td><td>并发</td><td><strong>低延迟</strong></td><td><strong>标记-清除</strong></td><td>短</td><td>对响应时间有要求的服务</td><td>JDK 9废弃, 14移除</td></tr><tr><td><strong>G1</strong></td><td>并发/并行</td><td><strong>可预测的停顿时间</strong></td><td>标记-整理 / 标记-复制</td><td>可控</td><td>大内存服务端应用</td><td><strong>JDK 9及之后默认</strong></td></tr><tr><td><strong>ZGC / Shenandoah</strong></td><td>并发</td><td><strong>极低延迟</strong></td><td>复杂的并发算法</td><td>极短 (亚毫秒)</td><td>超大内存、超低延迟要求的服务</td><td>JDK 11+ 引入，持续演进</td></tr></tbody></table><p>总的来说，JVM垃圾回收器的发展历程，是从最初简单的“能用就行”（Serial），到关注“多干活”（Parallel），再到追求“快响应”（CMS），最终演进到“既要干得好，又要响应快且稳”（G1、ZGC）的趋势。选择哪款回收器，完全取决于你的应用特性、业务需求以及硬件配置。</p>',41)]))}const d=r(a,[["render",e]]),h=JSON.parse('{"path":"/8gu/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%92%8C%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.html","title":"JVM垃圾回收算法与回收器详解","lang":"zh-CN","frontmatter":{"description":"JVM垃圾回收算法与回收器详解 在Java虚拟机（JVM）中，垃圾回收（Garbage Collection, GC）是一项至关重要的自动内存管理机制。它的核心任务是识别并回收不再被程序使用的对象所占用的内存。理解其背后的算法和不同的回收器实现，对于进行JVM调优和构建高性能Java应用至关重要。 一、 核心垃圾回收算法 GC算法是垃圾回收器实现其功能...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM垃圾回收算法与回收器详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-14T03:48:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%92%8C%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"JVM垃圾回收算法与回收器详解"}],["meta",{"property":"og:description","content":"JVM垃圾回收算法与回收器详解 在Java虚拟机（JVM）中，垃圾回收（Garbage Collection, GC）是一项至关重要的自动内存管理机制。它的核心任务是识别并回收不再被程序使用的对象所占用的内存。理解其背后的算法和不同的回收器实现，对于进行JVM调优和构建高性能Java应用至关重要。 一、 核心垃圾回收算法 GC算法是垃圾回收器实现其功能..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-14T03:48:22.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-14T03:48:22.000Z"}]]},"git":{"createdTime":1755143302000,"updatedTime":1755143302000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":1,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":9.56,"words":2867},"filePathRelative":"8gu/JVM垃圾回收算法和回收器详解.md","autoDesc":true}');export{d as comp,h as data};
