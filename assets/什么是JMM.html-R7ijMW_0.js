import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as o,b as r,r as s,o as p}from"./app-BL6t7olL.js";const i={};function c(l,e){const t=s("Mermaid");return p(),n("div",null,[e[0]||(e[0]=o('<h1 id="什么是jmm" tabindex="-1"><a class="header-anchor" href="#什么是jmm"><span>什么是JMM</span></a></h1><p>简单来说，JMM不是一个真实存在的物理区域，而是一种<strong>规范或一组规则</strong>。它定义了在多线程环境下，Java程序中的变量（特指共享变量）如何被存储在内存中，以及线程之间如何通过内存进行通信。它的最终目标是屏蔽各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果，从而保证并发编程的正确性。</p><h3 id="为什么需要jmm" tabindex="-1"><a class="header-anchor" href="#为什么需要jmm"><span>为什么需要JMM？</span></a></h3><p>在现代计算机中，为了提升处理速度，CPU通常不会直接和主内存（RAM）打交道，而是在中间加上了多层高速缓存（CPU Cache）。</p><p>当一个线程执行时，它会把需要用到的变量从主内存中复制一份到自己的工作内存（Working Memory，这可以理解为CPU高速缓存的抽象）。线程对变量的所有操作（读取、赋值等）都是在自己的工作内存中进行的。操作完成后，再在某个时间点将修改后的变量值写回主内存。</p><p>这就带来了一个问题：<strong>多线程并发时，数据一致性无法保证。</strong></p>',6)),r(t,{code:"eJxLL0osyFAIceFSAILi0iQIX+nJjt1P21qfrp2hoOGbmJmn4Juam19UqakEVgYCjtFPWzc+2bX6af+Ml+39Com2BrFgudS8FC40s57v2v98RbchQm9KZlFqcklmfp6CTxBcMNww+un2pU/2zoHYaxiroKtrV/Ni/e6n/dNAxtcoOBtWv1i38Pm66QqJ2tq1YOmnbTOfti4FShvWAA3A7wAjQg4wQnGAERYHGOF3gBGqAxwhKpb0Pu3YBgmmGoUQw2hocECCC6saI6gao1iIQSGGEFVzVjybP+HJjlXPpm97OX3L86adINtnz6tRcIQoMyKoDBIwJZU5qUCb0zJzcqyU0yzTdIpLivKzU62UjY2NoWzd8syUkgwro4IKJC1Ad0D0JCURr8eIWD1cAJ0b/Ic="}),e[1]||(e[1]=o('<p>由于每个线程都有自己的工作内存，并且写回主内存的时机不确定，就可能导致以下三个核心问题：</p><ol><li><strong>可见性 (Visibility)</strong>：一个线程修改了共享变量的值，其他线程无法立即看到这个修改。</li><li><strong>原子性 (Atomicity)</strong>：一个或多个操作，要么全部执行且执行过程不会被任何因素打断，要么就都不执行。在多线程环境下，像 <code>i++</code> 这样的操作就不是原子的（它包含读取、增加、写入三步）。</li><li><strong>有序性 (Ordering)</strong>：为了提高性能，编译器和处理器可能会对指令进行重排序。在单线程下，这通常没问题，但在多线程下，重排序可能会导致意想不到的后果。</li></ol><p>JMM就是为了解决以上三个问题而生的。</p><h3 id="jmm如何保证并发安全" tabindex="-1"><a class="header-anchor" href="#jmm如何保证并发安全"><span>JMM如何保证并发安全？</span></a></h3><p>JMM通过定义一系列的内存操作规则和同步机制来解决这些问题，其中最核心的就是<strong>Happens-Before原则</strong>和Java提供的同步关键字。</p><h4 id="happens-before-原则" tabindex="-1"><a class="header-anchor" href="#happens-before-原则"><span>Happens-Before 原则</span></a></h4><p>这是JMM中最重要的一个概念。它定义了两个操作之间的偏序关系。如果操作A &quot;happens-before&quot; 操作B，那么A操作的结果对B操作是可见的，并且A操作的执行顺序在B操作之前。</p><p>JMM定义了以下几条天然的Happens-Before规则：</p><ul><li><strong>程序次序规则</strong>：在一个线程内，按照代码书写的顺序，前面的操作 happens-before 后面的操作。</li><li><strong>监视器锁规则</strong>：对一个锁的解锁（unlock）操作 happens-before 于后续对这个锁的加锁（lock）操作。</li><li><strong>volatile变量规则</strong>：对一个 <code>volatile</code> 变量的写操作 happens-before 于后续对这个变量的读操作。</li><li><strong>线程启动规则</strong>：线程对象的 <code>start()</code> 方法 happens-before 此线程的任何一个动作。</li><li><strong>线程终止规则</strong>：线程中的所有操作都 happens-before 对此线程的终止检测。</li><li><strong>线程中断规则</strong>：对线程 <code>interrupt()</code> 方法的调用 happens-before 于被中断线程的代码检测到中断事件的发生。</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li></ul><h4 id="java提供的关键字" tabindex="-1"><a class="header-anchor" href="#java提供的关键字"><span>Java提供的关键字</span></a></h4><p>基于Happens-Before原则，Java提供了关键字来让程序员可以显式地控制同步：</p><ul><li><code>volatile</code>: 这是Java提供的最轻量级的同步机制。它可以保证变量的<strong>可见性</strong>（一个线程修改后，其他线程立即可见）和一定程度的<strong>有序性</strong>（禁止指令重排序）。但它<strong>不能</strong>保证原子性。</li><li><code>synchronized</code>: 这是一个更重量级的同步机制。它可以同时保证<strong>可见性</strong>、<strong>原子性</strong>和<strong>有序性</strong>。它通过锁的机制，确保同一时间只有一个线程能访问被 <code>synchronized</code> 保护的代码块或方法。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>可以将JMM理解为Java并发编程的<strong>底层基石</strong>。它通过定义一套抽象的内存模型和一系列规则（尤其是Happens-Before原则），解决了由CPU缓存、编译器优化等导致的可见性、原子性和有序性问题，并在此基础上提供了<code>volatile</code>、<code>synchronized</code>等工具，让开发者能够编写出正确、可靠的多线程程序。</p>',14))])}const g=a(i,[["render",c]]),h=JSON.parse('{"path":"/8gu/%E4%BB%80%E4%B9%88%E6%98%AFJMM.html","title":"什么是JMM","lang":"zh-CN","frontmatter":{"description":"什么是JMM 简单来说，JMM不是一个真实存在的物理区域，而是一种规范或一组规则。它定义了在多线程环境下，Java程序中的变量（特指共享变量）如何被存储在内存中，以及线程之间如何通过内存进行通信。它的最终目标是屏蔽各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果，从而保证并发编程的正确性。 为什么需要JMM？ 在现...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"什么是JMM\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-14T03:48:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/%E4%BB%80%E4%B9%88%E6%98%AFJMM.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"什么是JMM"}],["meta",{"property":"og:description","content":"什么是JMM 简单来说，JMM不是一个真实存在的物理区域，而是一种规范或一组规则。它定义了在多线程环境下，Java程序中的变量（特指共享变量）如何被存储在内存中，以及线程之间如何通过内存进行通信。它的最终目标是屏蔽各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果，从而保证并发编程的正确性。 为什么需要JMM？ 在现..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-14T03:48:22.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-14T03:48:22.000Z"}]]},"git":{"createdTime":1755143302000,"updatedTime":1755143302000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":1,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":4.32,"words":1296},"filePathRelative":"8gu/什么是JMM.md","autoDesc":true}');export{g as comp,h as data};
