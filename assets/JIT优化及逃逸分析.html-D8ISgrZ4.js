import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as l}from"./app-LG9Yomh2.js";const t={};function e(h,s){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="java-jit-编译与逃逸分析" tabindex="-1"><a class="header-anchor" href="#java-jit-编译与逃逸分析"><span>Java JIT 编译与逃逸分析</span></a></h1><p>Java 程序并非直接在硬件上运行，而是在 Java 虚拟机 (JVM) 这个抽象层上执行。为了弥合解释执行带来的性能差距，JVM 引入了 <strong>JIT (Just-In-Time) 编译器</strong> 和一系列先进的优化技术，其中 <strong>逃逸分析</strong> 就是一个关键环节。理解它们能帮助我们写出更高性能的代码。</p><h2 id="一、-jit-just-in-time-编译器" tabindex="-1"><a class="header-anchor" href="#一、-jit-just-in-time-编译器"><span>一、 JIT (Just-In-Time) 编译器</span></a></h2><p>传统的 Java 执行流程是：<code>.java</code> 文件被 <code>javac</code> 编译成平台无关的 <code>.class</code> 字节码文件，然后 JVM 通过<strong>解释器 (Interpreter)</strong> 逐行解释执行字节码。解释执行的好处是启动快，无需等待编译。但缺点是，对于频繁执行的“热点代码”(HotSpot Code)，每次都解释执行会浪费大量性能。</p><p>JIT 编译器就是为了解决这个问题而生的。</p><h3 id="_1-jit-是什么" tabindex="-1"><a class="header-anchor" href="#_1-jit-是什么"><span>1. JIT 是什么？</span></a></h3><p>JIT 会在程序<strong>运行时</strong>，识别出那些被频繁执行的“热点代码”（例如，多次调用的方法、循环体），并将这些字节码<strong>编译成本地机器码 (Native Code)</strong>。这个过程就像给你的程序“开小灶”，让最繁忙的部分直接在 CPU 上以最高效的方式运行。</p><ul><li><strong>解释器 (Interpreter)</strong>: 负责启动时和非热点代码的执行。启动快，但执行效率低。</li><li><strong>JIT 编译器 (Compiler)</strong>: 负责将热点代码编译为本地机器码。启动慢（需要分析和编译），但执行效率极高。</li></ul><p>JVM 将两者结合，实现了启动速度和执行性能的平衡。这种模式被称为<strong>混合模式 (Mixed Mode)</strong>。</p><h3 id="_2-分层编译-tiered-compilation" tabindex="-1"><a class="header-anchor" href="#_2-分层编译-tiered-compilation"><span>2. 分层编译 (Tiered Compilation)</span></a></h3><p>现代 JVM (HotSpot) 通常采用分层编译策略，主要包含两个 JIT 编译器：</p><ul><li><strong>C1 编译器 (Client Compiler)</strong>: 一个轻量级的编译器，编译速度快，但优化程度较低。它会快速地将热点代码编译成本地代码，提升程序前期的性能。</li><li><strong>C2 编译器 (Server Compiler)</strong>: 一个重量级的编译器，编译速度慢，但会进行深度、复杂的优化，生成的代码质量非常高。</li></ul><p>分层编译的工作流程大致如下：</p><ol><li><strong>第0层</strong>: 解释执行。</li><li><strong>第1-3层</strong>: C1 编译器介入，进行不同程度的优化编译。</li><li><strong>第4层</strong>: C2 编译器介入，进行最大程度的优化，生成最优的本地代码。</li></ol><p>JVM 会根据代码的“热度”动态地决定使用哪个层级的编译，以达到最佳的综合性能。</p><h2 id="二、-逃逸分析-escape-analysis" tabindex="-1"><a class="header-anchor" href="#二、-逃逸分析-escape-analysis"><span>二、 逃逸分析 (Escape Analysis)</span></a></h2><p>逃逸分析是 JIT 编译器（主要是 C2）在进行深度优化时使用的一种非常重要的分析技术。它本身不是一种优化手段，而是一种<strong>分析手段</strong>，其分析结果为其他优化（如栈上分配、锁消除）提供了依据。</p><h3 id="_1-逃逸-是什么" tabindex="-1"><a class="header-anchor" href="#_1-逃逸-是什么"><span>1. “逃逸” 是什么？</span></a></h3><p>逃逸分析的基本思想是：<strong>分析一个对象的作用域，判断它是否会“逃逸”出创建它的方法或线程。</strong></p><ul><li><strong>不逃逸 (NoEscape)</strong>: 对象的生命周期完全局限在方法内部。它被创建，在方法内使用，并且随着方法的结束而消亡，没有被外部引用。</li><li><strong>方法逃逸 (ArgEscape)</strong>: 对象被作为参数传递给了其他方法，或者被赋值给了外部变量，但没有被其他线程访问。</li><li><strong>全局逃逸 (GlobalEscape)</strong>: 对象的作用域超出了方法，甚至可能被其他线程访问（例如，赋值给了一个静态变量、实例变量，或者作为方法返回值）。</li></ul><h3 id="_2-基于逃逸分析的优化" tabindex="-1"><a class="header-anchor" href="#_2-基于逃逸分析的优化"><span>2. 基于逃逸分析的优化</span></a></h3><p>当 JIT 编译器通过逃逸分析确定一个对象是<strong>不逃逸</strong>的，它就可以进行以下激进的优化：</p><h4 id="a-栈上分配-stack-allocation" tabindex="-1"><a class="header-anchor" href="#a-栈上分配-stack-allocation"><span>a. 栈上分配 (Stack Allocation)</span></a></h4><p><strong>原理</strong>: 我们知道，Java 中的对象通常是在<strong>堆 (Heap)</strong> 上分配的。堆是所有线程共享的，需要垃圾回收器 (GC) 来管理内存。如果一个对象被证明不会逃逸出当前方法，那么 JVM 就可以将其直接在当前线程的<strong>栈 (Stack)</strong> 上分配。</p><p><strong>好处</strong>:</p><ol><li><strong>减轻 GC 压力</strong>: 栈上分配的对象会随着方法栈帧的弹出而自动销毁，无需 GC介入，从而降低了 GC 的频率和负担。</li><li><strong>提升分配速度</strong>: 栈上分配比堆上分配更快。</li></ol><p><strong>示例</strong>:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// JIT 可能会对 User 对象进行栈上分配</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> createUser</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    User</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> user </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> User</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 1. 分配 User 对象</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    user</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Gemini&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 2. 使用对象</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 方法结束，user 对象的作用域也结束了，没有返回，没有泄露给外部</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// JIT 无法进行栈上分配，因为 user 对象作为返回值逃逸了</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> User</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> createUserAndReturn</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    User</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> user </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> User</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    user</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Gemini&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> user</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 对象逃逸出方法</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="b-锁消除-lock-elision" tabindex="-1"><a class="header-anchor" href="#b-锁消除-lock-elision"><span>b. 锁消除 (Lock Elision)</span></a></h4><p><strong>原理</strong>: 如果一个对象被证明不会逃逸出当前线程，那么对这个对象的所有同步锁（<code>synchronized</code>）都是没有意义的，因为不可能有其他线程与它产生竞争。JIT 编译器就可以安全地消除这些不必要的锁。</p><p><strong>好处</strong>: 避免了加锁和解锁带来的性能开销。</p><p><strong>示例</strong>: <code>StringBuffer</code> 的 <code>append</code> 方法是线程安全的（使用了 <code>synchronized</code>）。但在下面的代码中，<code>sb</code> 对象完全是方法内的局部变量，不会被其他线程访问。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> createString</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    StringBuffer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sb </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> StringBuffer</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 逃逸分析会发现 sb 对象只在当前线程使用</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // JIT 会消除 sb.append() 内部的 synchronized 锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        sb</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">append</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> sb</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="c-标量替换-scalar-replacement" tabindex="-1"><a class="header-anchor" href="#c-标量替换-scalar-replacement"><span>c. 标量替换 (Scalar Replacement)</span></a></h4><p><strong>原理</strong>: “标量”是指无法再分解的原始数据类型（如 <code>int</code>, <code>long</code>, <code>reference</code> 等）。如果一个对象被证明不逃逸，并且可以被分解成多个标量，那么 JIT 可能不会创建这个对象实例，而是直接创建并使用它的成员变量（这些标量）。</p><p><strong>好处</strong>: 连对象本身都不用创建了，直接在栈上或者寄存器中操作成员变量，是最高效的优化。</p><p><strong>示例</strong>:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Point</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> calculate</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Point</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> p </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Point</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // p 不会逃逸</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">y</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 经过标量替换后，JIT 可能会将代码优化成类似下面的样子：</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // int x_scalar = 1;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // int y_scalar = 2;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // int result = x_scalar + y_scalar;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // Point 对象 p 从未真正被分配</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、-如何观察和控制" tabindex="-1"><a class="header-anchor" href="#三、-如何观察和控制"><span>三、 如何观察和控制</span></a></h2><p>通常我们不需要手动干预这些优化，JVM 已经做得足够好。但如果需要进行性能分析或调试，可以使用以下 JVM 参数：</p><ul><li><code>-XX:+DoEscapeAnalysis</code> (默认开启): 显式开启逃逸分析。</li><li><code>-XX:-DoEscapeAnalysis</code>: 关闭逃逸分析。</li><li><code>-XX:+PrintCompilation</code>: 打印出 JIT 编译的详细信息。</li><li><code>-XX:+PrintInlining</code>: 打印方法内联信息。</li><li><code>-XX:+EliminateLocks</code>: 开启锁消除（默认开启）。</li><li><code>-XX:+PrintGCDetails</code>: 查看 GC 详情，可以间接观察栈上分配是否减少了 GC 压力。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><strong>JIT 编译器</strong>是 Java 高性能的基石，它通过将热点字节码编译为本地机器码来提升执行速度。而<strong>逃逸分析</strong>是 JIT 编译器中的一项关键分析技术，它通过判断对象的作用域，为<strong>栈上分配</strong>、<strong>锁消除</strong>和<strong>标量替换</strong>等深度优化提供了可能，极大地减少了堆内存分配和 GC 的压力，从而让 Java 程序跑得更快。</p>`,43)]))}const r=i(t,[["render",e]]),d=JSON.parse('{"path":"/8gu/JIT%E4%BC%98%E5%8C%96%E5%8F%8A%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90.html","title":"Java JIT 编译与逃逸分析","lang":"zh-CN","frontmatter":{"description":"Java JIT 编译与逃逸分析 Java 程序并非直接在硬件上运行，而是在 Java 虚拟机 (JVM) 这个抽象层上执行。为了弥合解释执行带来的性能差距，JVM 引入了 JIT (Just-In-Time) 编译器 和一系列先进的优化技术，其中 逃逸分析 就是一个关键环节。理解它们能帮助我们写出更高性能的代码。 一、 JIT (Just-In-Ti...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java JIT 编译与逃逸分析\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-14T03:48:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/JIT%E4%BC%98%E5%8C%96%E5%8F%8A%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"Java JIT 编译与逃逸分析"}],["meta",{"property":"og:description","content":"Java JIT 编译与逃逸分析 Java 程序并非直接在硬件上运行，而是在 Java 虚拟机 (JVM) 这个抽象层上执行。为了弥合解释执行带来的性能差距，JVM 引入了 JIT (Just-In-Time) 编译器 和一系列先进的优化技术，其中 逃逸分析 就是一个关键环节。理解它们能帮助我们写出更高性能的代码。 一、 JIT (Just-In-Ti..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-14T03:48:22.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-14T03:48:22.000Z"}]]},"git":{"createdTime":1755143302000,"updatedTime":1755143302000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":1,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":6.26,"words":1877},"filePathRelative":"8gu/JIT优化及逃逸分析.md","autoDesc":true}');export{r as comp,d as data};
