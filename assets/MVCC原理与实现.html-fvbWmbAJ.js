import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as t,o as a}from"./app-Bui1sgfn.js";const n={};function r(c,e){return a(),o("div",null,e[0]||(e[0]=[t('<h1 id="多版本并发控制-mvcc-深度解析-架构、实现与影响" tabindex="-1"><a class="header-anchor" href="#多版本并发控制-mvcc-深度解析-架构、实现与影响"><span>多版本并发控制（MVCC）深度解析：架构、实现与影响</span></a></h1><h2 id="第一部分-多版本并发控制-mvcc-导论" tabindex="-1"><a class="header-anchor" href="#第一部分-多版本并发控制-mvcc-导论"><span>第一部分：多版本并发控制（MVCC）导论</span></a></h2><h3 id="_1-1-mvcc的定义" tabindex="-1"><a class="header-anchor" href="#_1-1-mvcc的定义"><span>1.1 MVCC的定义</span></a></h3><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是一种先进的、非锁定的并发控制方法，被现代数据库管理系统（DBMS）广泛采用，以支持对数据库的并发访问 。其核心目标是解决在多用户环境下，当一个用户正在读取数据而另一用户同时在写入数据时可能产生的数据不一致性问题 。如果没有有效的并发控制，读取者可能会看到被部分写入或处于不一致状态的数据，从而破坏数据库的完整性。</p><p>传统的并发控制方法，如读写锁，通过强制读取者等待写入者完成操作来保证隔离性，但这在高并发场景下会造成严重的性能瓶颈和锁竞争 。MVCC通过一种截然不同的策略解决了这个问题。</p><h3 id="_1-2-mvcc的基本承诺" tabindex="-1"><a class="header-anchor" href="#_1-2-mvcc的基本承诺"><span>1.2 MVCC的基本承诺</span></a></h3><p>MVCC机制的核心承诺是：<strong>读取者不阻塞写入者，写入者亦不阻塞读取者</strong> 。为了实现这一目标，MVCC为每一个连接到数据库的用户提供了一个特定时间点的数据“快照”（snapshot）。当一个写入者需要更新数据时，它不会直接覆盖原始数据，而是创建一个该数据项的新版本。这样，数据库中便同时存在了同一逻辑数据的多个物理版本 。每个事务能看到哪个版本，取决于该事务的快照时间点以及数据库实现的隔离级别。这种设计使得读取和写入操作可以并行进行，互不干扰，从而极大地减少了锁争用，提升了多用户环境下的数据库性能 。</p><p>这种机制的实现，代表了数据库并发控制理念的一次重大转变。传统的锁机制是一种<em>悲观</em>策略，它假定冲突是常态，因此在访问数据前必须先获取锁，以防止潜在的冲突发生 。而MVCC则体现了一种</p><p><em>乐观</em>思想，它假定冲突是小概率事件，允许事务自由地读取数据，将冲突的检测与解决推迟到写入时处理 。通过为每个读操作提供一个一致性的数据版本，MVCC避免了预先加锁的开销，从而在根本上改变了并发访问的模型。</p><h3 id="_1-3-mvcc对性能的重新定义" tabindex="-1"><a class="header-anchor" href="#_1-3-mvcc对性能的重新定义"><span>1.3 MVCC对性能的重新定义</span></a></h3><p>MVCC的引入，也重新定义了数据库性能的衡量标准。性能不再仅仅是单个事务的执行速度，而更多地体现为系统在面临高并发负载时的<em>可伸缩性</em>和<em>可预测性</em> 。其主要性能目标是在高争用情况下也能可预见地保持高效率。理想情况下，通过一个同步点所需的开销应该是一个常数，无论有多少线程试图同时通过 。对于现代的高度并发应用，如Web服务、SaaS平台和实时分析仪表盘，MVCC提供的稳定吞吐量和低延迟，使其不仅是一种优化，更是一种架构上的必需。性能的关注点从“单个事务在隔离环境下的执行速度有多快？”转变为“当用户数量增至N时，系统吞吐量能维持在何种水平？”。</p><h3 id="_1-4-本报告的范围与结构" tabindex="-1"><a class="header-anchor" href="#_1-4-本报告的范围与结构"><span>1.4 本报告的范围与结构</span></a></h3><p>本报告旨在对MVCC进行一次全面而深入的剖析。报告将从MVCC的核心理论原则出发，详细阐述其版本控制和事务快照机制。随后，将MVCC与传统的基于锁的并发控制进行对比分析。报告的核心部分将以业界主流的关系型数据库MySQL（特指InnoDB存储引擎）作为案例，深入剖析其MVCC实现细节，包括底层数据结构、可见性判断算法以及相关的系统维护机制。最后，报告将总结MVCC在实际应用中的影响和挑战。</p><h2 id="第二部分-mvcc的核心原则-版本控制与快照" tabindex="-1"><a class="header-anchor" href="#第二部分-mvcc的核心原则-版本控制与快照"><span>第二部分：MVCC的核心原则：版本控制与快照</span></a></h2><h3 id="_2-1-数据版本控制-多版本-的基石" tabindex="-1"><a class="header-anchor" href="#_2-1-数据版本控制-多版本-的基石"><span>2.1 数据版本控制：“多版本”的基石</span></a></h3><p>MVCC的核心在于，当数据被修改时，系统不会在原位置上进行覆盖式更新（in-place update）。相反，它会创建一个该逻辑数据项的新的<em>物理版本</em> 。这一原则是整个MVCC机制的基石，它使得同一份逻辑数据的多个历史状态得以共存。每次更新操作都会产生一个新版本，而旧版本则被保留下来，以供那些在更新发生前就已经开始的事务读取。</p><h3 id="_2-2-版本链-连接历史的纽带" tabindex="-1"><a class="header-anchor" href="#_2-2-版本链-连接历史的纽带"><span>2.2 版本链：连接历史的纽带</span></a></h3><p>为了管理这些并存的版本，DBMS通常会在每行数据中维护一个指针，该指针指向其前一个版本，从而形成一个记录历史状态的链表，即“版本链”（version chain）。这个链条通常存储在一个专门的区域，例如在InnoDB中被称为“撤销日志”（Undo Log）或“回滚段”（rollback segment）。当一个事务需要读取某个特定时间点的数据时，它可以通过遍历这个版本链来追溯并重建出当时的数据状态。数据库索引通常指向版本链的“头部”，即最新的数据版本。</p><h3 id="_2-3-事务快照-一个一致性的现实视图" tabindex="-1"><a class="header-anchor" href="#_2-3-事务快照-一个一致性的现实视图"><span>2.3 事务快照：一个一致性的现实视图</span></a></h3><p>事务快照是MVCC的另一个核心概念。当一个事务开始时（或者根据隔离级别的不同，在每个语句开始时），DBMS会为其提供一个一致性的、特定时间点的数据库视图 。这个快照定义了在该事务的生命周期内，哪些数据版本是“可见”的，从而确保了事务的隔离性，使其免受其他并发事务所做修改的干扰 。需要强调的是，生成快照并非通过物理复制整个数据库来实现，而是通过一种更为高效的逻辑机制，即利用事务ID或时间戳来过滤版本链，动态地判断每个数据版本的可见性 。</p><h3 id="_2-4-虚拟数据库-的幻象及其代价" tabindex="-1"><a class="header-anchor" href="#_2-4-虚拟数据库-的幻象及其代价"><span>2.4 “虚拟数据库”的幻象及其代价</span></a></h3><p>事务快照为每个事务创造了一个强大的幻象：它似乎在操作一个私有的、静态的数据库副本。然而，这个幻象是在每次读取时动态构建的。当一个事务需要读取一个被频繁更新的数据行的旧版本时，数据库必须沿着版本链回溯，应用undo记录来重建历史状态 。这个过程，特别是对于一个运行时间很长的事务（即拥有一个很“旧”的读视图），可能会变得非常昂贵。如果其需要访问的数据自快照创建以来已被修改了成百上千次，那么版本链就会非常长，数据库引擎需要消耗大量的CPU和I/O资源来遍历这个链条。这揭示了MVCC一个内在的性能权衡：为写入操作提供高并发性的同时，可能会以牺牲高事务性（OLTP）环境中长时间运行的分析型查询的读取性能为代价。</p><h3 id="_2-5-垃圾回收-并发特性而非纯粹的维护任务" tabindex="-1"><a class="header-anchor" href="#_2-5-垃圾回收-并发特性而非纯粹的维护任务"><span>2.5 垃圾回收：并发特性而非纯粹的维护任务</span></a></h3><p>由此引申出一个更深层次的理解：在MVCC中，移除过时数据版本的垃圾回收（Garbage Collection）过程，例如InnoDB的<code>Purge</code>，其意义远不止是回收磁盘空间。它是一项至关重要的性能调优机制。通过修剪冗长的版本链，垃圾回收直接减少了后续事务重建快照时所需的工作量，从而维持了系统整体的读取性能 。如果垃圾回收效率低下，版本链会持续增长，导致所有读操作的性能随时间推移而下降，即便磁盘空间尚且充足。因此，垃圾回收的效率和频率与数据库维持高并发读取性能的能力紧密相关，它应被视为MVCC并发控制模型的一个有机组成部分，而非一个独立的后台维护任务。</p><h2 id="第三部分-范式转移-mvcc与传统锁机制的对比" tabindex="-1"><a class="header-anchor" href="#第三部分-范式转移-mvcc与传统锁机制的对比"><span>第三部分：范式转移：MVCC与传统锁机制的对比</span></a></h2><h3 id="_3-1-核心二分法-版本控制与阻塞" tabindex="-1"><a class="header-anchor" href="#_3-1-核心二分法-版本控制与阻塞"><span>3.1 核心二分法：版本控制与阻塞</span></a></h3><p>MVCC与传统锁机制代表了两种截然不同的并发控制哲学。基于锁的系统采用一种阻塞模型，通过共享锁和排他锁来防止冲突访问，当锁不兼容时，后来的事务必须等待前者释放锁 。而MVCC则采用版本控制模型，允许并发访问，将写-写冲突的检测推迟到事务提交时处理，而读-写冲突则通过版本可见性规则从根本上被消除 。</p><h3 id="_3-2-性能与并发性" tabindex="-1"><a class="header-anchor" href="#_3-2-性能与并发性"><span>3.2 性能与并发性</span></a></h3><p>在读多写少或读写混合的工作负载下，MVCC的性能优势尤为明显。由于消除了读写阻塞，系统可以支持更高的并发度，并且性能表现更加稳定和可预测 。相比之下，锁机制在低并发环境下表现良好，但随着并发度和数据争用的增加，锁等待时间会急剧上升，导致性能瓶颈 。</p><h3 id="_3-3-死锁问题" tabindex="-1"><a class="header-anchor" href="#_3-3-死锁问题"><span>3.3 死锁问题</span></a></h3><p>MVCC极大地降低了死锁的发生概率。在传统锁机制中，常见的死锁场景是两个事务互相等待对方持有的锁（例如，事务A持有X的读锁，请求Y的写锁；事务B持有Y的读锁，请求X的写锁）。由于在MVCC中，读操作通常不加锁，这种经典的读-写死锁循环被彻底打破。死锁仍然可能在写-写冲突的场景中发生，但其频率远低于锁模型 。</p><h3 id="_3-4-开销与复杂性" tabindex="-1"><a class="header-anchor" href="#_3-4-开销与复杂性"><span>3.4 开销与复杂性</span></a></h3><p>两种模型各有其开销。MVCC引入了额外的存储开销，因为它需要保存数据的多个版本；同时，它也带来了垃圾回收的计算开销 。锁机制的存储开销较低，因为它只保存最新版本的数据，但它将复杂性转移到了应用层面，开发者需要处理锁等待超时、死锁检测和事务重试等逻辑。</p><p>下表总结了MVCC与传统锁机制在关键方面的对比。</p><table><thead><tr><th>特性</th><th>多版本并发控制 (MVCC)</th><th>基于锁的并发控制</th></tr></thead><tbody><tr><td><strong>核心机制</strong></td><td>版本控制与事务快照</td><td>共享锁与排他锁</td></tr><tr><td><strong>读写阻塞</strong></td><td>读取者不阻塞写入者，反之亦然</td><td>读取者可能阻塞写入者，反之亦然</td></tr><tr><td><strong>并发性能</strong></td><td>在混合负载和高并发下表现优异</td><td>随锁争用加剧，性能下降明显</td></tr><tr><td><strong>死锁</strong></td><td>罕见，主要限于写-写冲突</td><td>较为常见，可能由读-写和写-写循环引起</td></tr><tr><td><strong>存储开销</strong></td><td>较高，需存储多个数据版本</td><td>较低，仅存储最新数据版本</td></tr><tr><td><strong>清理开销</strong></td><td>需要后台垃圾回收（如<code>Purge</code>）</td><td>开销极小，仅需释放锁</td></tr><tr><td><strong>读取一致性</strong></td><td>提供精确的时间点快照视图</td><td>取决于锁的粒度、持续时间和隔离级别</td></tr></tbody></table><p>导出到 Google 表格</p><h2 id="第四部分-案例研究-mysql-innodb存储引擎的mvcc实现" tabindex="-1"><a class="header-anchor" href="#第四部分-案例研究-mysql-innodb存储引擎的mvcc实现"><span>第四部分：案例研究：MySQL InnoDB存储引擎的MVCC实现</span></a></h2><p>InnoDB是MySQL的默认事务性存储引擎，其MVCC实现精巧而复杂，是理解MVCC在实际系统中如何运作的绝佳范例。</p><h3 id="_4-1-innodb行结构-隐藏的基石" tabindex="-1"><a class="header-anchor" href="#_4-1-innodb行结构-隐藏的基石"><span>4.1 InnoDB行结构：隐藏的基石</span></a></h3><p>InnoDB中每一行的物理存储结构都为MVCC提供了基础。除了用户定义的列之外，每一行还包含了几个隐藏的系统列，其中对MVCC至关重要的有两个：</p><ul><li><code>DB_TRX_ID</code>：一个6字节的字段，记录了最后一次插入或更新该行的事务的ID 。</li><li><code>DB_ROLL_PTR</code>：一个7字节的字段，称为“回滚指针”，指向写入到回滚段（rollback segment）中的一条undo日志记录 。</li></ul><p>这两个字段共同构成了InnoDB实现版本控制的物理基础。</p><h3 id="_4-2-undo日志与版本链" tabindex="-1"><a class="header-anchor" href="#_4-2-undo日志与版本链"><span>4.2 Undo日志与版本链</span></a></h3><p>当一个事务更新一行数据时，InnoDB并不会立即丢弃旧的数据。相反，它会执行以下操作：</p><ol><li>将旧版本的数据（包括主键和被修改列的原始值）写入一条undo日志记录中。</li><li>更新数据行，将新数据写入，并将该行的<code>DB_TRX_ID</code>设置为当前事务的ID。</li><li>将该行的<code>DB_ROLL_PTR</code>指向刚刚创建的那条undo日志记录 。</li></ol><p>这条undo日志记录自身也包含一个指向上一个undo日志记录的指针，如此串联，形成了一个该行数据的历史版本链 。通过</p><p><code>DB_ROLL_PTR</code>，InnoDB可以从当前版本开始，沿着版本链一路回溯，重建出任意历史版本的数据。值得注意的是，undo日志分为插入（insert）和更新（update）两种类型，它们的生命周期不同：插入undo日志在事务提交后即可被丢弃，而更新undo日志则必须保留，直到没有任何活跃的事务快照需要它来构建旧版本的数据 。</p><h3 id="_4-3-read-view-定义事务的现实" tabindex="-1"><a class="header-anchor" href="#_4-3-read-view-定义事务的现实"><span>4.3 Read View：定义事务的现实</span></a></h3><p><code>ReadView</code>是InnoDB实现事务快照的核心数据结构 。当一个事务首次执行一致性读（consistent read）操作时，InnoDB会为其创建一个</p><p><code>ReadView</code>对象。这个对象捕获了创建时刻的数据库事务状态，并定义了该事务的可见性规则。<code>ReadView</code>主要包含以下几个关键成员：</p><ul><li><code>m_ids</code>：一个在创建<code>ReadView</code>时，数据库中所有活跃（已开始但未提交）的读写事务ID的有序列表。</li><li><code>up_limit_id</code>：<code>m_ids</code>列表中的最小事务ID。任何小于此ID的事务，都必然已经提交，因此其所做的修改对当前快照是可见的。</li><li><code>low_limit_id</code>：系统下一个将要分配的事务ID。任何大于或等于此ID的事务，都是在快照创建之后才开始的“未来”事务，其所做的修改对当前快照是不可见的。</li><li><code>creator_trx_id</code>：创建此<code>ReadView</code>的事务自身的ID。</li></ul><p>这几个成员共同定义了一个事务ID的可见性区间，为后续的可见性判断提供了依据 。</p><h3 id="_4-4-可见性检查算法" tabindex="-1"><a class="header-anchor" href="#_4-4-可见性检查算法"><span>4.4 可见性检查算法</span></a></h3><p>当一个事务尝试读取一行数据时，InnoDB会执行一个精确的算法，利用<code>ReadView</code>来判断该行的当前版本是否可见。这个过程可以分解为以下步骤：</p><ol><li>读取数据行的<code>DB_TRX_ID</code>，记为<code>row_trx_id</code>。</li><li><strong>可见性判断</strong>： <ul><li><strong>检查是否为自身修改</strong>：如果<code>row_trx_id</code>等于<code>creator_trx_id</code>，说明该版本是当前事务自己修改的，因此可见。</li><li><strong>检查是否为过去已提交的事务</strong>：如果<code>row_trx_id</code>小于<code>up_limit_id</code>，说明修改该行的事务在当前快照创建之前就已经提交，因此可见。</li><li><strong>检查是否为未来事务</strong>：如果<code>row_trx_id</code>大于或等于<code>low_limit_id</code>，说明修改该行的事务在当前快照创建之后才开始，因此不可见。</li><li><strong>检查是否为快照创建时的活跃事务</strong>：如果<code>up_limit_id &lt;= row_trx_id &lt; low_limit_id</code>，则需要在<code>m_ids</code>列表中进行二分查找。如果<code>row_trx_id</code>存在于<code>m_ids</code>中，说明在快照创建时，修改该行的事务尚未提交，因此不可见。反之，如果不在列表中，则说明该事务在快照创建前已经提交，因此可见。</li></ul></li><li><strong>版本回溯</strong>：如果根据上述规则判断当前版本不可见，InnoDB会通过该行的<code>DB_ROLL_PTR</code>找到对应的undo日志记录，从中恢复出前一个版本的数据，然后对前一个版本的<code>DB_TRX_ID</code>重复执行步骤2的可见性判断。这个过程会沿着版本链不断进行，直到找到一个可见的版本，或者版本链结束（意味着该行是在快照创建后插入的，对当前事务不可见）。</li></ol><p>下表将InnoDB的<code>ReadView</code>可见性检查逻辑进行了归纳。</p><table><thead><tr><th>条件</th><th>是否可见？</th><th>理由</th></tr></thead><tbody><tr><td><code>row.DB_TRX_ID &lt; view.up_limit_id</code></td><td><strong>是</strong></td><td>事务在快照创建前已提交。</td></tr><tr><td><code>row.DB_TRX_ID &gt;= view.low_limit_id</code></td><td><strong>否</strong></td><td>事务在快照创建后才开始（“未来”事务）。</td></tr><tr><td><code>row.DB_TRX_ID</code> 存在于 <code>view.m_ids</code></td><td><strong>否</strong></td><td>事务在快照创建时处于活跃状态（未提交）。</td></tr><tr><td><code>row.DB_TRX_ID == view.creator_trx_id</code></td><td><strong>是</strong></td><td>更改由当前事务自身产生。</td></tr><tr><td>(默认情况) <code>row.DB_TRX_ID</code> 不在 <code>view.m_ids</code></td><td><strong>是</strong></td><td>事务在最老的活跃事务开始后、快照创建前提交。</td></tr></tbody></table><p>导出到 Google 表格</p><h3 id="_4-5-读取类型-快照读与当前读" tabindex="-1"><a class="header-anchor" href="#_4-5-读取类型-快照读与当前读"><span>4.5 读取类型：快照读与当前读</span></a></h3><p>InnoDB中的读操作分为两种截然不同的类型，理解它们的区别对于编写正确的并发程序至关重要。</p><ul><li><p><strong>一致性非锁定读（快照读）</strong>：这是标准的<code>SELECT</code>语句的默认行为。它利用<code>ReadView</code>和MVCC机制来读取数据的一个历史快照，整个过程不加任何锁，因此不会阻塞其他事务的写入操作 。快照的创建时机取决于事务隔离级别：在</p><p><code>REPEATABLE READ</code>级别下，快照在事务的第一个读操作时创建，并贯穿整个事务；在<code>READ COMMITTED</code>级别下，每个<code>SELECT</code>语句都会创建一个新的快照 。</p></li><li><p><strong>锁定读（当前读）</strong>：这类操作会绕过MVCC的快照机制，去读取数据库中<em>最新已提交</em>的版本，并对其加锁。典型的锁定读语句包括<code>SELECT... FOR UPDATE</code>和<code>SELECT... FOR SHARE</code>，以及所有的<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>操作。<code>FOR UPDATE</code>会加上排他锁（X锁），而<code>FOR SHARE</code>会加上共享锁（S锁）。这种读取方式用于事务需要修改其所读取数据的场景，以防止“丢失更新”等并发问题 。</p></li></ul><p>这种读取的二元性可能导致一种“精神分裂”的事务状态。尤其是在<code>REPEATABLE READ</code>隔离级别下，一个事务内部可以同时感知到两个不同的数据库状态。一个普通的<code>SELECT</code>语句看到的是事务开始时的快照，而一个<code>SELECT... FOR UPDATE</code>看到的却是最新的数据。如果应用程序逻辑未能正确处理这两个来自不同时间线的数据，就可能引发难以察觉的逻辑错误 。这揭示了InnoDB MVCC模型的一个深层复杂性：它为了灵活性，允许开发者混合使用不同的读取模式，但这牺牲了事务内数据视图的单一性保证。</p><h3 id="_4-6-系统维护-purge线程与history-list" tabindex="-1"><a class="header-anchor" href="#_4-6-系统维护-purge线程与history-list"><span>4.6 系统维护：Purge线程与History List</span></a></h3><p>InnoDB的垃圾回收由一个或多个后台的“Purge线程”负责。当一个事务提交后，其产生的、不再被任何活跃<code>ReadView</code>需要的undo日志记录会被添加到一个全局的“历史列表”（History List）中。Purge线程会定期扫描这个列表，执行两个核心任务：</p><ol><li><strong>物理删除</strong>：找到那些被标记为删除的行，并将其从表和索引中物理移除。</li><li><strong>回收空间</strong>：释放undo日志页，使其可以被新的事务重用 。</li></ol><p>如果系统中存在长时间运行的事务，它会持有一个很旧的<code>ReadView</code>，这会阻止Purge线程清理该<code>ReadView</code>之后产生的undo日志，导致History List长度持续增长，undo表空间膨胀，并最终影响整个系统的性能。</p><p>此外，InnoDB的一项关键性能优化在于，它不会为纯只读事务分配事务ID 。这并非一个微不足道的细节。在一个读多写少的系统中，这意味着大量的只读查询不会进入任何写事务创建的</p><p><code>ReadView</code>的<code>m_ids</code>列表中。这极大地减小了<code>m_ids</code>列表的规模，使得<code>ReadView</code>的创建和可见性检查（特别是其中的二分查找步骤）能够保持高效。这个微观层面的优化，对整个并发控制系统的宏观可伸缩性产生了深远且积极的影响。</p><h2 id="第五部分-mvcc与事务隔离级别" tabindex="-1"><a class="header-anchor" href="#第五部分-mvcc与事务隔离级别"><span>第五部分：MVCC与事务隔离级别</span></a></h2><p>MVCC是实现SQL标准中定义的事务隔离级别的底层技术基础 。隔离级别本质上可以被看作是MVCC引擎的“配置”，它规定了事务快照的创建和重用策略。</p><h3 id="_5-1-read-committed" tabindex="-1"><a class="header-anchor" href="#_5-1-read-committed"><span>5.1 READ COMMITTED</span></a></h3><p>在此隔离级别下，事务中的<em>每一条语句</em>开始执行时，都会创建一个新的快照 。这意味着，一个事务可以看到在它执行期间，由其他事务提交的更改。这种策略可以防止“脏读”（读取未提交的数据），但允许“不可重复读”（在同一事务中两次读取同一行数据，得到不同结果）。</p><h3 id="_5-2-repeatable-read" tabindex="-1"><a class="header-anchor" href="#_5-2-repeatable-read"><span>5.2 REPEATABLE READ</span></a></h3><p>在此隔离级别下（InnoDB的默认级别），快照在事务的<em>第一个读操作</em>时创建，并且这个快照会被该事务内的<em>所有</em>后续读操作重用 。这保证了在整个事务期间，对同一数据的多次读取结果总是一致的，从而防止了“不可重复读”。</p><h3 id="_5-3-snapshot-isolation" tabindex="-1"><a class="header-anchor" href="#_5-3-snapshot-isolation"><span>5.3 SNAPSHOT ISOLATION</span></a></h3><p>需要明确的是，InnoDB的<code>REPEATABLE READ</code>级别，实际上实现的是一种被称为“快照隔离”（Snapshot Isolation）的级别。快照隔离虽然能防止不可重复读和“幻读”（phantom read）的大部分情况，但它允许一种被称为“写偏斜”（write skew）的异常现象发生，而真正的<code>SERIALIZABLE</code>隔离级别则能防止所有并发异常。</p><p>将隔离级别理解为快照管理策略，极大地简化了开发者对并发行为的认知。选择一个隔离级别，就等同于选择了一种快照的生命周期管理模式，其对数据可见性的影响是直接且可预测的。</p><h2 id="第六部分-实践意义与结论" tabindex="-1"><a class="header-anchor" href="#第六部分-实践意义与结论"><span>第六部分：实践意义与结论</span></a></h2><h3 id="_6-1-长时间运行事务的挑战" tabindex="-1"><a class="header-anchor" href="#_6-1-长时间运行事务的挑战"><span>6.1 长时间运行事务的挑战</span></a></h3><p>在MVCC系统中，长时间运行的事务是一个严峻的挑战。在InnoDB中，一个长时间活跃的事务会持有一个很旧的快照。这个旧快照会阻止垃圾回收机制清理其后产生的所有历史数据版本，导致undo空间持续膨胀，并最终拖累整个系统的读取性能 。因此，在应用设计中，应尽力避免或拆分长时间运行的事务。</p><h3 id="_6-2-架构权衡总结" tabindex="-1"><a class="header-anchor" href="#_6-2-架构权衡总结"><span>6.2 架构权衡总结</span></a></h3><p>MVCC的实现充满了架构上的权衡：</p><ul><li><strong>并发性 vs. 开销</strong>：通过牺牲存储空间和引入垃圾回收的计算开销，换取了极高的读写并发性。</li><li><strong>实现复杂性 vs. 应用简单性</strong>：MVCC将并发控制的复杂性封装在数据库内核中，极大地简化了应用程序的开发，开发者无需再为复杂的锁管理和死锁处理而烦恼。</li></ul><h3 id="_6-3-最终结论-mvcc的统治地位" tabindex="-1"><a class="header-anchor" href="#_6-3-最终结论-mvcc的统治地位"><span>6.3 最终结论：MVCC的统治地位</span></a></h3><p>尽管MVCC在实现上更为复杂，并引入了额外的存储和维护开销，但它在处理高并发工作负载时所展现出的卓越性能和可伸缩性，使其成为了现代通用关系型数据库的事实标准。对于绝大多数需要同时处理大量读写请求的现代应用而言，MVCC所带来的好处远远超过了其固有的成本。它不仅是一种技术实现，更是一种驱动数据库向更高并发、更高性能演进的关键设计哲学。</p>',85)]))}const p=d(n,[["render",r]]),h=JSON.parse('{"path":"/8gu/MVCC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0.html","title":"多版本并发控制（MVCC）深度解析：架构、实现与影响","lang":"zh-CN","frontmatter":{"description":"多版本并发控制（MVCC）深度解析：架构、实现与影响 第一部分：多版本并发控制（MVCC）导论 1.1 MVCC的定义 多版本并发控制（Multi-Version Concurrency Control, MVCC）是一种先进的、非锁定的并发控制方法，被现代数据库管理系统（DBMS）广泛采用，以支持对数据库的并发访问 。其核心目标是解决在多用户环境下，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"多版本并发控制（MVCC）深度解析：架构、实现与影响\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-14T03:48:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/MVCC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"多版本并发控制（MVCC）深度解析：架构、实现与影响"}],["meta",{"property":"og:description","content":"多版本并发控制（MVCC）深度解析：架构、实现与影响 第一部分：多版本并发控制（MVCC）导论 1.1 MVCC的定义 多版本并发控制（Multi-Version Concurrency Control, MVCC）是一种先进的、非锁定的并发控制方法，被现代数据库管理系统（DBMS）广泛采用，以支持对数据库的并发访问 。其核心目标是解决在多用户环境下，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-14T03:48:22.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-14T03:48:22.000Z"}]]},"git":{"createdTime":1755143302000,"updatedTime":1755143302000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":1,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":19.97,"words":5991},"filePathRelative":"8gu/MVCC原理与实现.md","autoDesc":true}');export{p as comp,h as data};
