import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as o,b as a,r as i,o as r}from"./app-BzyIoBsd.js";const d={};function c(l,e){const t=i("Mermaid");return r(),s("div",null,[e[0]||(e[0]=o('<h1 id="api-网关高可用-ha-与中心无状态化方案设计" tabindex="-1"><a class="header-anchor" href="#api-网关高可用-ha-与中心无状态化方案设计"><span>API 网关高可用 (HA) 与中心无状态化方案设计</span></a></h1><h2 id="redis-存储信息概览" tabindex="-1"><a class="header-anchor" href="#redis-存储信息概览"><span>Redis 存储信息概览</span></a></h2><p>本节旨在梳理 Redis 在本方案实施前后的数据存储变化。</p><h3 id="方案实施前-当前" tabindex="-1"><a class="header-anchor" href="#方案实施前-当前"><span>方案实施前 (当前)</span></a></h3><p>在当前架构中，Redis 主要承载了服务发现、接口缓存、心跳维持和消息通知等功能：</p><ol><li><strong>接口信息 (Interface Info)</strong>： <ul><li>由 <code>api-gateway-core</code> 缓存接口和方法定义。</li><li><strong>示例 Key</strong>: <code>api:gateway:interface</code> (Hash)</li></ul></li><li><strong>网关核心服务心跳信息 (Gateway Core Heartbeat)</strong>： <ul><li>由 <code>api-gateway-center</code> 写入和管理，用于服务发现。</li><li><strong>示例 Key</strong>: <code>api:gateway:core:group:host:port</code> (String)</li></ul></li><li><strong>下游服务心跳信息 (Downstream Service Heartbeat)</strong>： <ul><li>由 <code>server-find-sdk</code> 写入和管理，用于下游业务服务的存活证明。</li><li><strong>示例 Key</strong>: <code>api:gateway:heartbeat:group:host:port</code> (String)</li></ul></li><li><strong>分布式限流数据 (Rate Limiting Data)</strong>： <ul><li>由 <code>api-gateway-core</code> 的 <code>DistributedRateLimiter</code> 使用，存储限流相关的计数器和时间戳。</li></ul></li><li><strong>Pub/Sub 通道 (Pub/Sub Channels)</strong>： <ul><li>用于实例间的消息广播，如 <code>&quot;service-launched&quot;</code> (缓存刷新) 和 <code>&quot;heartBeat&quot;</code> (心跳通知)。</li></ul></li></ol><h3 id="方案实施后-新增" tabindex="-1"><a class="header-anchor" href="#方案实施后-新增"><span>方案实施后 (新增)</span></a></h3><p>在实施本高可用与无状态方案后，我们将在 Redis 中新增以下关键信息，以支撑新架构：</p><ol><li><strong>Nginx <code>upstream</code> 实例列表 (网关中心状态)</strong>： <ul><li><strong>用途</strong>：替代 <code>api-gateway-center</code> 的内存状态，存储所有 <code>api-gateway-core</code> 实例的列表。网关中心将从此读取数据来生成 Nginx 配置。</li><li><strong>示例 Key</strong>: <code>nginx:gateway:instances</code> (Hash)</li><li><strong>实现</strong>：实现<strong>第二部分：网关中心无状态方案</strong>。</li></ul></li><li><strong>Nginx 物理节点健康状态 (Nginx 监控)</strong>： <ul><li><strong>用途</strong>：存储 Nginx 主备物理机的健康状态（<code>&quot;UP&quot;</code> / <code>&quot;DOWN&quot;</code>），用于监控告警和配置推送降级。</li><li><strong>示例 Key</strong>: <code>nginx:gateway:health_status:192.168.1.100</code> (String)</li><li><strong>实现</strong>：实现<strong>第三部分：客户端感知的健康监控机制</strong>。</li></ul></li></ol><h2 id="方案正文" tabindex="-1"><a class="header-anchor" href="#方案正文"><span>方案正文</span></a></h2><p>本文档旨在设计一套健壮的 API 网关架构，解决两大核心问题：</p><ol><li><strong>Nginx 单点故障 (SPOF)</strong>：作为流量入口的 Nginx 存在单点故障风险。</li><li><strong>网关中心有状态</strong>：<code>api-gateway-center</code> (网关中心) 在内存中维护状态，导致其难以横向扩展和实现高可用。</li></ol><p>本方案将通过引入 <strong>Keepalived</strong>、<strong>Redis</strong> 以及<strong>客户端感知的健康监控机制</strong>，构建一个高可用、无状态且具备快速感知能力的网关系统。</p><h2 id="第一部分-nginx-高可用方案-keepalived" tabindex="-1"><a class="header-anchor" href="#第一部分-nginx-高可用方案-keepalived"><span>第一部分：Nginx 高可用方案 (Keepalived)</span></a></h2><p>本方案采用业界标准的 Keepalived + VIP (虚拟 IP) 模式作为 Nginx 层高可用的核心基础。</p><h3 id="_1-1-核心设计" tabindex="-1"><a class="header-anchor" href="#_1-1-核心设计"><span>1.1. 核心设计</span></a></h3><ol><li><strong>部署模型</strong>：部署至少两台 Nginx 服务器（例如 <code>192.168.1.100</code> 作为主节点，<code>192.168.1.101</code> 作为备节点）。每台服务器上均安装 Nginx 和 Keepalived。</li><li><strong>虚拟 IP (VIP)</strong>：Keepalived 集群将共用一个虚拟 IP（例如 <code>192.168.1.200</code>）。这个 VIP 是客户端（<code>server-send-sdk</code>）访问网关的<strong>唯一入口</strong>。</li><li><strong>自动故障转移</strong>： <ul><li>Keepalived 会通过健康检查脚本（如检查 Nginx 进程或探测 <code>/healthz</code> 接口）持续监控<strong>本机</strong> Nginx 的健康状况。</li><li>正常情况下，VIP 绑定在主节点（Master）上。</li><li>当主节点的 Nginx 发生故障，Keepalived 检测到异常，会自动将 VIP 漂移（切换）到健康的备节点（Backup）上。</li><li>这个切换过程对客户端完全透明，实现了秒级的自动故障恢复。</li></ul></li></ol><h3 id="_1-2-架构图" tabindex="-1"><a class="header-anchor" href="#_1-2-架构图"><span>1.2. 架构图</span></a></h3>',18)),a(t,{code:"eJyVU21L21AU/u6vuMQvEXaDaWHMMoRlDaNUS+mkDMoYWXJbQ0sNSXwDP7iNujnmS2FjL+0Xh7CCW7shrAVR/4w3Mf/Ce5ObprVS9XwI956c5znneXJSMhVjESwkJwAJa/l1cOdw+6fzoesedTj/BY3nyXSBc5o7+OMB3qt7m29oBvAWMleQCS1U1aCllae4lz6CXCeucWZKenUNeEff8F7H/dzyGlvu2SHg86lsAogzMUF8+EgQhdj09FTUVNNNpNr6UhXM5frJiJKN870FRMDPK5aNzAEwjcyzVObFq/kC637ROwF81EykzYKBw0jLcvbJXCovJykqjZChVPQVpAHebdSd3V/AJ7qOYm0AhHSo37j5N6jmSGZ2iLMPow6F57HSYoCXFLW8bNwoTQql4cP3w9LEMdII6n7SpNulSeOlDZoAHkMBzm7kc7kswOfvLrvHG6NMN6yQe1rHteOL3h8Cisx4KmcW5FyBUwwdlhQbrSrrUEVVsgxEWfvA3d9ytjed5vawvj49XWMq7rLTdf69BWQfA2nsm0Y1AjHgS8370XS+/g+KOUBkhA75hf4jGChwbLdFfhWvtuOetkdpRwrdRg/vfxotl5gT9noF+cMU9UolMVmcKT6wbHOpjBKT8XicneGqrtmLiZixNgBirQKcqt4ZF242AxbV+wElBkQIjQdeAYo6dzc="}),e[1]||(e[1]=o('<h3 id="_1-3-关键原则" tabindex="-1"><a class="header-anchor" href="#_1-3-关键原则"><span>1.3. 关键原则</span></a></h3><ul><li><strong>客户端透明</strong>：<code>server-send-sdk</code> <strong>只配置 VIP 地址</strong>。它不需要知道，也不应该关心后端 Nginx 的物理 IP 和主备状态。</li><li><strong>配置一致性</strong>：<code>api-gateway-center</code> <strong>必须</strong>向 Nginx 集群中的<strong>所有</strong>节点（无论主备）推送完全一致的 Nginx 配置文件，以确保任何节点在接管 VIP 时都持有最新的路由规则。</li></ul><h2 id="第二部分-网关中心无状态方案-redis" tabindex="-1"><a class="header-anchor" href="#第二部分-网关中心无状态方案-redis"><span>第二部分：网关中心无状态方案 (Redis)</span></a></h2><p>本方案通过将网关中心的状态数据外部化，实现网关中心自身的无状态和高可用。</p><h3 id="_2-1-核心问题" tabindex="-1"><a class="header-anchor" href="#_2-1-核心问题"><span>2.1. 核心问题</span></a></h3><p>当前 <code>api-gateway-center</code> 是“有状态”的，因为它在<strong>内存</strong>中维护 Nginx 的 <code>upstream</code> 列表（即网关核心服务的实例列表）。这导致：</p><ol><li><strong>单点故障</strong>：如果唯一的网关中心实例宕机，服务注册和 Nginx 配置刷新将完全停止。</li><li><strong>无法扩展</strong>：如果启动多个网关中心实例，它们的内存状态不互通，会导致 Nginx 配置被不同实例错误地频繁覆盖，造成配置混乱。</li></ol><h3 id="_2-2-解决方案" tabindex="-1"><a class="header-anchor" href="#_2-2-解决方案"><span>2.2. 解决方案</span></a></h3><p>将所有需要共享的“状态”数据从内存迁移到 <strong>Redis</strong> 中。</p><ul><li><strong>状态数据</strong>：核心是指 Nginx <code>upstream</code> 块中所需的服务实例列表（例如 <code>upstream gateway_backend { ... }</code>）。</li><li><strong>实现</strong>：<code>api-gateway-center</code> 在启动时和运行时，从 Redis（例如一个 Hash 结构，Key 为 <code>nginx:gateway:instances</code>）中读取 <code>upstream</code> 列表。当服务注册或下线时，网关中心<strong>只操作 Redis</strong> 中的数据。</li><li><strong>好处</strong>：所有网关中心实例都读写 Redis 中的同一份数据，实现了状态共享。网关中心可以部署多个实例，通过负载均衡器对外提供服务，实现自身的高可用和横向扩展。</li></ul><h3 id="_2-3-架构图" tabindex="-1"><a class="header-anchor" href="#_2-3-架构图"><span>2.3. 架构图</span></a></h3>',11)),a(t,{code:"eJxLL0osyFAIceFSAAIfp2ilF1vmv9i79+nc9hcLFz6duUJBw8dJIS2/SME5Na8ktUhTKRasEkwUlyZBtCs93zvxaevmJzvWPt3f/HJ22/N9SxQ0nk1f8Lxr27OGRk0lsGoQcHb1C3ENijeMVkosyNRNTyxJLU+s1E0GG61rCDUbSaERVoVGUIWpeSnYHPO0deOTXashdj9dO+Np0wqEA4JcXTyDo5WCUlMyixU0ILIKpQXFJUWpibkKTzumv1i4QkfBLz0zr0LhaePSp7u2Q8x5vrYT5nUUW4GBo6trB/cXFjEjhGKYKgUboHzNi/W79Z+2zYSYXwNxGbIyIzzKID4uqcxJBdmWlpmTY6WcZpmiA/RHfnaqlbKxsTGUrVuemVKSYWVUUIGkB2wITFtyMrHa4O6H6ExOTiNRpxGxOgFuh+fx"}),e[2]||(e[2]=o('<h2 id="第三部分-客户端感知的健康监控机制" tabindex="-1"><a class="header-anchor" href="#第三部分-客户端感知的健康监控机制"><span>第三部分：客户端感知的健康监控机制</span></a></h2><p>本方案在 Keepalived 的自动故障转移基础上，增加一套由网关中心和 SDK 共同参与的、基于 Redis 的<strong>应用层健康监控机制</strong>。</p><p><strong>注意</strong>：此机制<strong>不负责</strong> Nginx 的主备切换（这是 Keepalived 的工作），它主要用于<strong>状态监控、告警和配置推送降级</strong>。</p><h3 id="_3-1-监控数据结构" tabindex="-1"><a class="header-anchor" href="#_3-1-监控数据结构"><span>3.1. 监控数据结构</span></a></h3><p>我们在 Redis 中为每个 Nginx 物理节点维护一个健康状态：</p><ul><li><strong>Key</strong>: <code>nginx:gateway:health_status:192.168.1.100</code></li><li><strong>Value</strong>: <code>&quot;UP&quot;</code> (健康) / <code>&quot;DOWN&quot;</code> (失效)</li></ul><h3 id="_3-2-探活机制-客户端触发-sdk-上报" tabindex="-1"><a class="header-anchor" href="#_3-2-探活机制-客户端触发-sdk-上报"><span>3.2. 探活机制：客户端触发 (SDK 上报)</span></a></h3><p>这是你提议的核心机制，用于快速响应真实客户端遇到的问题。</p><ol><li><strong>SDK 感知失败</strong>：<code>server-send-sdk</code> 在向 VIP 发送请求时，如果连续遇到网络层失败（例如 <code>Connection refused</code> 或 <code>Request timeout</code>）达到一定阈值（例如 3 次）。</li><li><strong>SDK 异步上报</strong>：SDK <strong>异步</strong>地（避免阻塞业务线程）向 <code>api-gateway-center</code> 发送一个“疑似故障”的通知。</li><li><strong>中心立即探活</strong>：网关中心收到通知后，<strong>立即触发</strong>一次对所有 Nginx 物理节点（<code>192.168.1.100</code> 和 <code>192.168.1.101</code>）的健康检查（例如通过 HTTP 请求 <code>/healthz</code> 接口）。</li><li><strong>标记状态</strong>：如果发现某个节点（如 <code>192.168.1.100</code>）探活失败，网关中心立即更新 Redis 中的状态： <code>SET nginx:gateway:health_status:192.168.1.100 &quot;DOWN&quot;</code></li></ol><h3 id="_3-3-探活机制-中心主动轮询-定时任务" tabindex="-1"><a class="header-anchor" href="#_3-3-探活机制-中心主动轮询-定时任务"><span>3.3. 探活机制：中心主动轮询（定时任务）</span></a></h3><p>为了确保监控的完整性并实现自动恢复，网关中心还必须有主动探活能力。</p><ol><li><strong>主动轮询</strong>：<code>api-gateway-center</code> 启动一个定时任务（例如每分钟执行一次），轮询<strong>所有</strong> Nginx 物理节点的 <code>/healthz</code> 接口。</li><li><strong>更新状态</strong>：根据探活结果实时更新 Redis 中的 <code>&quot;UP&quot;</code> / <code>&quot;DOWN&quot;</code> 状态。</li></ol><h3 id="_3-4-自动恢复机制" tabindex="-1"><a class="header-anchor" href="#_3-4-自动恢复机制"><span>3.4. 自动恢复机制</span></a></h3><p>当一个节点被标记为 <code>&quot;DOWN&quot;</code> 后，上述的<strong>主动轮询任务</strong>（3.3 节）将扮演“恢复探活”的角色：</p><ul><li>定时任务会<strong>持续</strong>尝试探活 <code>&quot;DOWN&quot;</code> 状态的节点。</li><li>一旦该节点（例如 <code>192.168.1.100</code>）的 <code>/healthz</code> 接口恢复访问，定时任务会立即将其在 Redis 中的状态改回 <code>&quot;UP&quot;</code>： <code>SET nginx:gateway:health_status:192.168.1.100 &quot;UP&quot;</code></li></ul><h3 id="_3-5-监控机制的应用" tabindex="-1"><a class="header-anchor" href="#_3-5-监控机制的应用"><span>3.5. 监控机制的应用</span></a></h3><p>这个存储在 Redis 中的 <code>&quot;UP&quot;</code>/<code>&quot;DOWN&quot;</code> 状态有两个关键作用：</p><ol><li><strong>监控与告警</strong>： <ul><li><code>api-gateway-front</code> (管理后台) 可以实时从 Redis 读取这些状态，在界面上清晰展示每个 Nginx 节点的真实健康状况。</li><li>当状态变为 <code>&quot;DOWN&quot;</code> 时，可触发自动告警（短信、钉钉等），通知运维人员介入。</li></ul></li><li><strong>配置推送降级</strong>： <ul><li>当网关中心需要刷新 Nginx 配置时（例如有新服务注册），它会查询 Redis 中的健康状态。</li><li>对于状态为 <code>&quot;DOWN&quot;</code> 的 Nginx 节点，网关中心可以<strong>跳过</strong>对该节点的 SSH 配置推送，避免因 SSH 连接超时而阻塞整个配置刷新流程。</li></ul></li></ol>',18))])}const h=n(d,[["render",c]]),u=JSON.parse('{"path":"/projects/gateway/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/API%20%E7%BD%91%E5%85%B3%E9%AB%98%E5%8F%AF%E7%94%A8%20(HA)%20%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%97%A0%E7%8A%B6%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1.html","title":"API 网关高可用 (HA) 与中心无状态化方案设计","lang":"zh-CN","frontmatter":{"description":"API 网关高可用 (HA) 与中心无状态化方案设计 Redis 存储信息概览 本节旨在梳理 Redis 在本方案实施前后的数据存储变化。 方案实施前 (当前) 在当前架构中，Redis 主要承载了服务发现、接口缓存、心跳维持和消息通知等功能： 接口信息 (Interface Info)： 由 api-gateway-core 缓存接口和方法定义。 示...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"API 网关高可用 (HA) 与中心无状态化方案设计\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-15T12:29:49.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/projects/gateway/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/API%20%E7%BD%91%E5%85%B3%E9%AB%98%E5%8F%AF%E7%94%A8%20(HA)%20%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%97%A0%E7%8A%B6%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"API 网关高可用 (HA) 与中心无状态化方案设计"}],["meta",{"property":"og:description","content":"API 网关高可用 (HA) 与中心无状态化方案设计 Redis 存储信息概览 本节旨在梳理 Redis 在本方案实施前后的数据存储变化。 方案实施前 (当前) 在当前架构中，Redis 主要承载了服务发现、接口缓存、心跳维持和消息通知等功能： 接口信息 (Interface Info)： 由 api-gateway-core 缓存接口和方法定义。 示..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-15T12:29:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-15T12:29:49.000Z"}]]},"git":{"createdTime":1763209789000,"updatedTime":1763209789000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":1,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":7.6,"words":2279},"filePathRelative":"projects/gateway/系统架构设计/API 网关高可用 (HA) 与中心无状态化方案设计.md","autoDesc":true}');export{h as comp,u as data};
