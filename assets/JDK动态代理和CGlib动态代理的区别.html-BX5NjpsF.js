import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as r,o as n}from"./app-DwX47ipL.js";const a={};function d(i,t){return n(),o("div",null,t[0]||(t[0]=[r('<h1 id="jdk动态代理与cglib动态代理的核心区别" tabindex="-1"><a class="header-anchor" href="#jdk动态代理与cglib动态代理的核心区别"><span>JDK动态代理与CGLib动态代理的核心区别</span></a></h1><p>在Java开发中，动态代理是一种非常重要的技术，它允许程序在运行时动态地创建代理对象，从而在不修改源代码的情况下增强方法、实现AOP（面向切面编程）等。最主流的两种动态代理实现方式是JDK官方提供的动态代理和第三方库CGLib。</p><p>它们两者在实现原理、使用限制和性能上都有着显著的区别。</p><h2 id="核心区别速览" tabindex="-1"><a class="header-anchor" href="#核心区别速览"><span>核心区别速览</span></a></h2><table><thead><tr><th>特性</th><th>JDK 动态代理</th><th>CGLib 动态代理</th></tr></thead><tbody><tr><td><strong>实现原理</strong></td><td>利用Java的 <strong>反射机制</strong>，创建一个实现共同接口的代理类。</td><td>利用 <strong>ASM字节码增强</strong> 技术，创建一个被代理类的子类。</td></tr><tr><td><strong>代理对象要求</strong></td><td>被代理的类 <strong>必须实现至少一个接口</strong>。</td><td>被代理的类 <strong>无需实现接口</strong>，但不能是<code>final</code>修-饰的类。</td></tr><tr><td><strong>代理范围</strong></td><td>只能代理接口中定义的方法。</td><td>可以代理类中所有非<code>final</code>的<code>public</code>和<code>protected</code>方法。</td></tr><tr><td><strong>代理类型</strong></td><td>生成的代理类与被代理类实现相同的接口，是兄弟关系。</td><td>生成的代理类是 <strong>被代理类的子类</strong>，是父子关系。</td></tr><tr><td><strong>性能</strong></td><td>在现代高版本JDK（8及以后）中，性能与CGLib相当，甚至在代理创建速度上更快。</td><td>早期版本中执行效率更高，但代理创建过程较慢。</td></tr><tr><td><strong>依赖</strong></td><td>JDK自带，无需引入任何第三方库。</td><td>需要引入第三方<code>cglib</code>库。</td></tr></tbody></table><h2 id="详细解析" tabindex="-1"><a class="header-anchor" href="#详细解析"><span>详细解析</span></a></h2><h3 id="_1-实现原理" tabindex="-1"><a class="header-anchor" href="#_1-实现原理"><span>1. 实现原理</span></a></h3><ul><li><strong>JDK 动态代理</strong> 它的核心是 <code>java.lang.reflect.Proxy</code> 类和 <code>java.lang.reflect.InvocationHandler</code> 接口。当你调用 <code>Proxy.newProxyInstance()</code> 方法时，JDK会在内存中动态地构建一个<code>$Proxy0</code>之类的代理类。这个代理类会实现你指定的目标接口，并将所有的方法调用都委托给一个<code>InvocationHandler</code>实例的<code>invoke</code>方法来处理。你可以在<code>invoke</code>方法中加入自定义的逻辑（如日志、事务等），然后再通过反射调用目标对象的原始方法。</li><li><strong>CGLib (Code Generation Library)</strong> CGLib的原理则更为深入。它通过一个名为ASM的字节码操作框架，在运行时动态地修改目标类的字节码，并生成一个继承自该类的子类作为代理。当调用代理对象的方法时，会被<code>MethodInterceptor</code>（方法拦截器）拦截，你可以在拦截器中实现增强逻辑，并通过<code>MethodProxy</code>调用父类（即原始目标类）的同名方法。</li></ul><h3 id="_2-核心限制与差异" tabindex="-1"><a class="header-anchor" href="#_2-核心限制与差异"><span>2. 核心限制与差异</span></a></h3><ul><li><strong>接口依赖</strong>：这是两者最根本的区别。JDK动态代理强制要求目标类必须实现接口，它只能为接口创建代理。而CGLib则可以为普通的类创建代理，因为它采用的是继承的方式。</li><li><strong>final关键字</strong>：由于CGLib是通过继承来创建代理的，所以它无法代理<code>final</code>类（因为<code>final</code>类不能被继承）。同理，类中被<code>final</code>修饰的方法也无法被代理（因为<code>final</code>方法不能被子类重写）。JDK动态代理则没有这个限制，因为它是基于接口实现的。</li></ul><h3 id="_3-性能演进" tabindex="-1"><a class="header-anchor" href="#_3-性能演进"><span>3. 性能演进</span></a></h3><p>在早期的Java版本中（如JDK 6或7），CGLib的执行性能通常优于JDK动态代理。这是因为CGLib直接操作字节码，而JDK代理则依赖于反射，反射调用在当时相对较慢。</p><p>然而，从 <strong>JDK 8</strong> 开始，Java虚拟机对反射调用进行了大量的优化（如方法内联、JIT编译优化等），使得JDK动态代理的性能得到了极大的提升。在现代的Java应用中，两者的执行性能差距已经微乎其微。在某些场景下，特别是代理对象的创建速度上，JDK动态代理甚至会比CGLib更快。</p><h3 id="_4-在spring-aop中的应用" tabindex="-1"><a class="header-anchor" href="#_4-在spring-aop中的应用"><span>4. 在Spring AOP中的应用</span></a></h3><p>Spring框架的AOP功能完美地体现了这两种代理的选择策略：</p><ul><li><strong>默认策略</strong>：如果目标Bean <strong>实现了接口</strong>，Spring AOP会默认使用 <strong>JDK动态代理</strong>。</li><li><strong>备用策略</strong>：如果目标Bean <strong>没有实现任何接口</strong>，Spring AOP则会使用 <strong>CGLib</strong> 来创建代理。</li><li><strong>强制使用CGLib</strong>：你也可以通过配置（例如，在Spring Boot中设置 <code>spring.aop.proxy-target-class=true</code>）来强制Spring AOP对所有Bean（无论是否实现接口）都使用CGLib代理。这样做可以避免因代理类型不同而引发的一些问题（例如，在类内部调用另一个被AOP增强的方法时，可能导致增强失效）。</li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>总的来说，选择哪种代理方式主要取决于你的目标对象设计：</p><ul><li>如果你的应用是面向接口编程的，那么 <strong>JDK动态代理</strong> 是一个简单、高效且无需额外依赖的选择。</li><li>如果需要代理一个没有实现接口的普通类，或者需要代理类中的特定方法（而非接口中的方法），那么 <strong>CGLib</strong> 是你唯一的选择。</li></ul><p>在现代框架如Spring Boot中，由于其更强的通用性，CGLib的使用变得越来越普遍。</p>',20)]))}const p=e(a,[["render",d]]),g=JSON.parse('{"path":"/8gu/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGlib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"JDK动态代理与CGLib动态代理的核心区别","lang":"zh-CN","frontmatter":{"description":"JDK动态代理与CGLib动态代理的核心区别 在Java开发中，动态代理是一种非常重要的技术，它允许程序在运行时动态地创建代理对象，从而在不修改源代码的情况下增强方法、实现AOP（面向切面编程）等。最主流的两种动态代理实现方式是JDK官方提供的动态代理和第三方库CGLib。 它们两者在实现原理、使用限制和性能上都有着显著的区别。 核心区别速览 详细解析...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JDK动态代理与CGLib动态代理的核心区别\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-14T03:48:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGlib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"JDK动态代理与CGLib动态代理的核心区别"}],["meta",{"property":"og:description","content":"JDK动态代理与CGLib动态代理的核心区别 在Java开发中，动态代理是一种非常重要的技术，它允许程序在运行时动态地创建代理对象，从而在不修改源代码的情况下增强方法、实现AOP（面向切面编程）等。最主流的两种动态代理实现方式是JDK官方提供的动态代理和第三方库CGLib。 它们两者在实现原理、使用限制和性能上都有着显著的区别。 核心区别速览 详细解析..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-14T03:48:22.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-14T03:48:22.000Z"}]]},"git":{"createdTime":1755143302000,"updatedTime":1755143302000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":1,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":4.36,"words":1309},"filePathRelative":"8gu/JDK动态代理和CGlib动态代理的区别.md","autoDesc":true}');export{p as comp,g as data};
