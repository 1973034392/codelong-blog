import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,a as c,o as a}from"./app-K9aAqEZ1.js";const n={};function t(r,e){return a(),d("div",null,e[0]||(e[0]=[c('<h1 id="hashmap与concurrenthashmap深度解析-架构、演进与性能的跨jdk版本剖析" tabindex="-1"><a class="header-anchor" href="#hashmap与concurrenthashmap深度解析-架构、演进与性能的跨jdk版本剖析"><span>HashMap与ConcurrentHashMap深度解析：架构、演进与性能的跨JDK版本剖析</span></a></h1><h2 id="第一部分-hashmap的剖析" tabindex="-1"><a class="header-anchor" href="#第一部分-hashmap的剖析"><span>第一部分 HashMap的剖析</span></a></h2><p>本部分将专注于剖析非并发环境下的<code>HashMap</code>，它不仅是Java中使用最广泛的Map实现，其核心的数据结构与算法也是理解<code>ConcurrentHashMap</code>演进的基石。我们将深入探讨其从简单的链表结构到引入复杂平衡树的转变，以及其内部精巧的哈希与扩容机制。</p><h3 id="_1-1-核心数据结构-从链式冲突到树化平衡-jep-180" tabindex="-1"><a class="header-anchor" href="#_1-1-核心数据结构-从链式冲突到树化平衡-jep-180"><span>1.1 核心数据结构：从链式冲突到树化平衡 (JEP 180)</span></a></h3><p><code>HashMap</code>的性能与可靠性，在很大程度上取决于其如何高效地组织数据和解决哈希冲突。其数据结构的演进，是其发展史上最重要的一笔。</p><h4 id="数组与链表的结合" tabindex="-1"><a class="header-anchor" href="#数组与链表的结合"><span>数组与链表的结合</span></a></h4><p><code>HashMap</code>的经典实现基于一个众所周知的概念——哈希表。其核心是一个数组，通常被称为“桶数组”（bucket array）。每一个数组元素（桶）都是一个指针，指向一个用于存储实际键值对（Entry或Node）的数据结构 。当调用</p><p><code>put(key, value)</code>方法时，<code>HashMap</code>会根据<code>key</code>的哈希值计算出其在桶数组中的索引位置。</p><p>在理想情况下，如果哈希函数能够将所有键均匀地分布到不同的桶中，那么每个桶最多只包含一个元素。这样，无论是插入、查找还是删除，操作的时间复杂度都能达到常数级别，即O(1) 。然而，在现实世界中，不同的键可能会计算出相同的数组索引，这种现象被称为“哈希冲突”（hash collision）。</p><p>为了处理哈希冲突，早期的<code>HashMap</code>（JDK 8之前）在每个桶后面都链接了一个简单的单向链表 。当多个键映射到同一个桶时，它们会被依次添加到这个链表中。当需要查找一个键时，程序首先定位到对应的桶，然后遍历该桶的链表，通过调用键的</p><p><code>equals()</code>方法来找到目标节点。</p><p>这种“数组+链表”的结构在大多数情况下表现优异。然而，它存在一个致命的弱点：当哈希冲突变得严重时，其性能会急剧下降。</p><h4 id="jdk-1-8-引入红黑树" tabindex="-1"><a class="header-anchor" href="#jdk-1-8-引入红黑树"><span>JDK 1.8：引入红黑树</span></a></h4><p><strong>问题陈述：</strong> 在某些极端情况下，大量的键可能会被映射到同一个桶中。这可能是由于<code>hashCode()</code>方法实现不佳，导致哈希值分布不均；也可能源于恶意的“哈希洪水”（hash-flooding）攻击。此时，特定桶中的链表会变得异常长，导致对该桶的<code>get()</code>或<code>put()</code>操作的性能从平均的$O(1)$退化为最坏情况下的$O(n)$，其中n是链表中的节点数量 。在这种场景下，高效的哈希表实际上变成了一个低效的链表，这不仅是性能问题，更是一个潜在的安全漏洞。</p><p><strong>解决方案 (JEP 180)：</strong> 为了解决这一问题，JDK 8根据JEP 180的提议，对<code>HashMap</code>的底层数据结构进行了一项革命性的优化 。当某个桶中的链表长度达到一个特定的阈值——</p><p><code>TREEIFY_THRESHOLD</code>（其值为8）时，这个链表将被转换为一个自平衡的二叉搜索树，具体实现为红黑树（Red-Black Tree） 。</p><p><strong>转换机制：</strong></p><ol><li><strong>树化（Treeify）：</strong> 链表到红黑树的转换并非无条件触发。除了链表长度需达到<code>TREEIFY_THRESHOLD</code>之外，还要求当前的桶数组容量必须大于等于<code>MIN_TREEIFY_CAPACITY</code>（其值为64）。如果数组容量过小，<code>HashMap</code>会优先选择对整个哈希表进行扩容（resize），因为扩容更有可能通过重新分配桶来解决哈希冲突问题 。</li><li><strong>性能提升：</strong> 这一结构上的转变，将哈希冲突严重时的查找时间复杂度从线性的$O(n)$优化到了对数级别的$O(log n)$，极大地提升了<code>HashMap</code>在最坏情况下的性能和稳定性 。</li><li><strong>反树化（Untreeify）：</strong> 相反，如果在后续的删除操作或扩容操作中，某个桶中的树节点数量减少到<code>UNTREEIFY_THRESHOLD</code>（其值为6）以下，这棵红黑树会被重新转换回链表结构，以节省内存并简化操作 。</li><li><strong>键的要求：</strong> 为了能够被存储在红黑树中并进行有效的比较和排序，作为键的对象必须实现<code>Comparable</code>接口 。</li></ol><p>这一设计的引入，其意义远超一次简单的性能调优。它本质上是一次对<code>HashMap</code>可靠性与安全性的加固。在互联网应用中，服务常常需要处理来自外部的、不可信的数据。例如，Web服务器可能会使用<code>HashMap</code>来存储HTTP请求的参数。攻击者可以精心构造大量具有相同哈希值的参数键，向服务器发起请求。在JDK 8之前，这种“哈希洪水”攻击能轻易地使服务器的<code>HashMap</code>陷入$O(n)$的低效模式，持续消耗CPU资源，最终导致拒绝服务（Denial-of-Service）。通过将最坏情况下的复杂度从$O(n)$降低到$O(log n)$，JDK 8的<code>HashMap</code>变得对这类攻击具有了更强的抵抗力，从而将一次性能优化升格为对整个Java平台至关重要的安全修复。</p><h3 id="_1-2-哈希与索引" tabindex="-1"><a class="header-anchor" href="#_1-2-哈希与索引"><span>1.2 哈希与索引</span></a></h3><p><code>HashMap</code>如何将一个任意的键对象映射到有限的数组索引上，是其核心效率的体现。这个过程涉及一套精心设计的、旨在兼顾效率与分布性的算法。</p><h4 id="hash-方法-哈希函数的智慧" tabindex="-1"><a class="header-anchor" href="#hash-方法-哈希函数的智慧"><span><code>hash()</code>方法：哈希函数的智慧</span></a></h4><p>整个过程的第一步，是获取键对象自身的<code>hashCode()</code>返回值 。然而，</p><p><code>HashMap</code>并不会直接使用这个值。无论是JDK 1.7还是1.8，都会对原始哈希码应用一个补充的“扰动函数”（supplemental hash function）。在JDK 1.8中，这个函数的实现极为简洁：<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 。</p><p><strong>设计缘由：</strong> 这一步至关重要。<code>&gt;&gt;&gt; 16</code>是一个无符号右移16位的操作，它将原始哈希值的高16位移动到低16位的位置。然后，通过与原始哈希值进行异或（<code>^</code>）运算，实现了高位信息与低位信息的混合。这样做的目的是为了增加哈希码低位的随机性，确保即使原始哈希码只在高位存在差异，最终计算出的扰动哈希码在低位也能体现出这种差异。这一设计与接下来的索引策略紧密相关。</p><h4 id="索引策略-高效的位运算" tabindex="-1"><a class="header-anchor" href="#索引策略-高效的位运算"><span>索引策略：高效的位运算</span></a></h4><p>在得到经过扰动的哈希码后，确定其在桶数组中索引位置的最后一步是 <code>(n - 1) &amp; hash</code>，其中<code>n</code>是桶数组的容量（<code>capacity</code>）。</p><p><strong>关键约束：</strong> 这里的位与（<code>&amp;</code>）运算是一种效率极高的操作，它被用来替代相对昂贵的模（<code>%</code>）运算。然而，<code>hash &amp; (n - 1)</code>能够等价于<code>hash % n</code>的前提是，容量<code>n</code>必须是2的整数次幂。这正是<code>HashMap</code>的容量总是保持为2的n次方的原因 。</p><p><strong>扰动与索引的联动：</strong> 现在，我们可以清晰地看到扰动函数与索引策略之间的精妙配合。<code>HashMap</code>为了追求极致的索引计算效率，选择了位运算，但这引入了“容量必须是2的幂”的约束。这个约束又带来了新的问题：如果容量<code>n</code>较小（例如，默认的16），那么<code>n - 1</code>的二进制表示就是<code>1111</code>。此时，<code>&amp;</code>运算将完全忽略哈希码中除了最低4位之外的所有高位信息。如果许多键的<code>hashCode()</code>实现恰好在低4位容易产生冲突，而在高位才有区分度，那么哈希表的分布将变得非常糟糕。</p><p>扰动函数 <code>(h &gt;&gt;&gt; 16)</code> 正是为了解决这个问题而生。它将哈希码高16位的信息“注入”到低16位中，使得最终参与<code>&amp;</code>运算的哈希码的低位部分也包含了高位部分的信息。这极大地改善了键在小容量哈希表中的分布均匀性，从而保证了<code>HashMap</code>在各种情况下都能维持接近$O(1)$的平均性能。这套设计是计算机科学中典型的通过一系列精巧的权衡与优化来达到整体最优效果的范例。</p><h3 id="_1-3-扩容机制-resize" tabindex="-1"><a class="header-anchor" href="#_1-3-扩容机制-resize"><span>1.3 扩容机制 (<code>resize()</code>)</span></a></h3><p>当<code>HashMap</code>中的条目数量增长到一定程度时，哈希冲突的概率会随之增加，性能会开始下降。为了维持高效的性能，<code>HashMap</code>需要进行扩容（rehash）。</p><p><strong>扩容的触发时机：</strong> 扩容操作在<code>HashMap</code>中的条目数量（<code>size</code>）超过其“阈值”（<code>threshold</code>）时被触发。该阈值由 <code>capacity * loadFactor</code> 计算得出。<code>HashMap</code>的默认负载因子（<code>loadFactor</code>）为0.75，这意味着当哈希表的填充率达到75%时，就会进行扩容 。扩容时，容量通常会翻倍 。</p><h4 id="jdk-1-7的扩容-头插法的隐患" tabindex="-1"><a class="header-anchor" href="#jdk-1-7的扩容-头插法的隐患"><span>JDK 1.7的扩容：头插法的隐患</span></a></h4><p>在JDK 1.7的实现中，扩容过程需要创建一个新的、容量更大的数组，然后遍历旧数组中的每一个桶，将桶中链表上的所有元素重新计算哈希索引，并放入新数组的相应位置。关键在于，这些元素被插入到新桶链表的<strong>头部</strong>。</p><p><strong>致命缺陷：</strong> 尽管<code>HashMap</code>本身被设计为非线程安全的，但在某些并发场景下（例如，开发者不恰当地在多线程环境中使用未经同步的<code>HashMap</code>），这种头插法扩容机制会引发一个灾难性的问题。如果两个线程同时检测到需要扩容并各自开始执行<code>resize()</code>操作，它们之间的竞争条件（race condition）可能导致在新的链表中形成一个<strong>循环</strong>。具体来说，一个线程可能颠倒了链表中某些节点的<code>next</code>指针顺序，而另一个线程在此基础上继续操作，最终可能导致一个节点的<code>next</code>指针指向了它在链表中的前一个节点。一旦循环链表形成，后续对该桶的<code>get()</code>操作将陷入无限循环，导致CPU占用率飙升至100%，使应用程序完全瘫痪 。这是Java历史上一个非常著名的并发bug。</p><h4 id="jdk-1-8的扩容-尾插法的安全与高效" tabindex="-1"><a class="header-anchor" href="#jdk-1-8的扩容-尾插法的安全与高效"><span>JDK 1.8的扩容：尾插法的安全与高效</span></a></h4><p>JDK 1.8彻底重构了扩容逻辑，从根本上解决了上述问题。在新版本的<code>resize()</code>方法中，元素在从旧表迁移到新表时，会保持它们在链表中的相对顺序，并通过<strong>尾插法</strong>将它们添加到新桶的链表中。</p><p><strong>优雅的优化：</strong> 更进一步，JDK 1.8的工程师们发现了一个极为高效的元素重分配算法。由于新容量总是旧容量的两倍（<code>newCapacity = oldCapacity * 2</code>），一个桶中的所有节点在扩容后，只可能被分配到两个位置：要么留在新表的<strong>原索引位置</strong>，要么移动到**“原索引 + 旧容量”**（<code>oldIndex + oldCapacity</code>）这个新位置。</p><p>一个节点究竟是留在原地还是移动到新位置，完全取决于其哈希值的某一个特定比特位。具体来说，是哈希值中与<code>oldCapacity</code>对应的那个比特位是0还是1。这使得<code>HashMap</code>在扩容时，不再需要为每个节点重新计算完整的哈希索引。它只需遍历一次旧桶的链表，根据这个关键比特位，将链表高效地拆分成两个子链表（一个“低位”链表和一个“高位”链表），然后分别将这两个子链表挂载到新表的两个对应位置上即可。</p><p><strong>安全性的提升：</strong> 这种通过尾插法保持节点相对顺序的策略，从根本上消除了导致循环链表的竞争条件。虽然<code>HashMap</code>依然不是线程安全的，但它移除了在并发扩容时可能发生的最具破坏性的故障模式。</p><p>JDK 1.8的扩容机制重构，是一个工程设计的杰出典范。它同时实现了两个目标：修复了一个严重的多线程安全漏洞，并显著提升了扩容操作本身的性能。这个解决方案既安全、稳健，又比其前身更加高效。</p><h2 id="第二部分-并发优化-java-util-concurrent-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#第二部分-并发优化-java-util-concurrent-concurrenthashmap"><span>第二部分 并发优化：java.util.concurrent.ConcurrentHashMap</span></a></h2><p>如果说<code>HashMap</code>的演进是数据结构优化的教科书，那么<code>ConcurrentHashMap</code>的演进则是一部现代并发编程思想的史诗。它展示了Java平台如何从粗粒度的锁机制，一步步走向精细化、低冲突的现代并发模型。其在JDK 1.7和JDK 1.8之间的架构差异，是理解Java并发容器演进的关键。</p><h3 id="_2-1-jdk-1-7时代-分段锁的智慧-segment" tabindex="-1"><a class="header-anchor" href="#_2-1-jdk-1-7时代-分段锁的智慧-segment"><span>2.1 JDK 1.7时代：分段锁的智慧 (<code>Segment</code>)</span></a></h3><p>在JDK 1.8之前，<code>ConcurrentHashMap</code>通过一种名为“分段锁”（Segmented Locking）的独创性设计，实现了在当时看来非常出色的并发性能。</p><h4 id="核心架构-一张由多张表组成的地图" tabindex="-1"><a class="header-anchor" href="#核心架构-一张由多张表组成的地图"><span>核心架构：一张由多张表组成的地图</span></a></h4><p>JDK 1.7版本的<code>ConcurrentHashMap</code>在内部并非一个单一的哈希表，而是由一个<code>Segment</code>对象数组构成 。可以将其理解为“一张由多张小地图组成的全国地图”。每个</p><p><code>Segment</code>本身就是一个独立的、线程安全的哈希表，它继承自<code>ReentrantLock</code>，并包含自己的<code>HashEntry</code>数组和链表结构 。</p><h4 id="并发控制模型" tabindex="-1"><a class="header-anchor" href="#并发控制模型"><span>并发控制模型</span></a></h4><ol><li><p><strong>并发级别（Concurrency Level）：</strong> <code>Segment</code>数组的大小由构造函数中的<code>concurrencyLevel</code>参数决定，默认值为16 。这个值一旦在</p><p><code>ConcurrentHashMap</code>创建时确定，就无法再更改。</p></li><li><p><strong>分而治之的锁：</strong> 所有的写操作（如<code>put</code>, <code>remove</code>）以及其他需要修改数据结构的操作，都只会锁定其键所对应的那个<code>Segment</code>。这意味着，在默认配置下，最多可以有16个线程同时对<code>ConcurrentHashMap</code>进行写操作，只要它们操作的键恰好被哈希到不同的<code>Segment</code>中 。这种设计极大地提高了并发写入的吞吐量，远胜于对整个Map加锁的</p><p><code>Hashtable</code>或<code>Collections.synchronizedMap</code>。</p></li><li><p><strong>无锁的读操作：</strong> 读操作（<code>get</code>）在绝大多数情况下是<strong>非阻塞</strong>的，它不需要获取任何锁。<code>get</code>操作能够看到最新写入数据的可见性，是由Java内存模型（JMM）对<code>volatile</code>关键字的语义保证的。<code>Segment</code>内部的<code>HashEntry</code>数组被声明为<code>volatile</code>，对<code>volatile</code>变量的读写操作具有特殊的内存屏障效应，确保了一个线程对<code>Segment</code>的修改对其他线程立即可见 。</p></li></ol><h4 id="核心操作详解" tabindex="-1"><a class="header-anchor" href="#核心操作详解"><span>核心操作详解</span></a></h4><ul><li><p><strong><code>put</code>操作：</strong> 当执行<code>put</code>操作时，<code>ConcurrentHashMap</code>首先会根据键的哈希值计算出它应该属于哪个<code>Segment</code>。然后，它会尝试获取该<code>Segment</code>的<code>ReentrantLock</code>。一旦成功获取锁，就在这个<code>Segment</code>的内部哈希表中执行类似于<code>HashMap</code>的插入操作。操作完成后，释放锁 。</p></li><li><p><strong><code>size</code>操作：</strong> 计算整个<code>ConcurrentHashMap</code>的大小是一个代价高昂的操作。为了得到一个精确的计数值，理论上需要锁定所有的<code>Segment</code>以防止在计数过程中发生变化。为了优化，<code>size()</code>方法的实现相当复杂：它会首先在不加锁的情况下，多次尝试对所有<code>Segment</code>的计数值求和。如果在求和期间，Map的总修改次数（一个全局计数器）没有发生变化，那么就认为这个结果是准确的。如果发生了变化，说明在计数的同时有写操作发生，此时<code>size()</code>方法会退化为锁定所有<code>Segment</code>再求和的慢速路径 。因此，在并发环境下，</p><p><code>size()</code>的返回值很多时候只是一个估计值。</p></li><li><p><strong>扩容操作：</strong> <code>ConcurrentHashMap</code>的扩容只发生在<code>Segment</code>内部。当某个<code>Segment</code>内部的元素过多，需要扩容时，只有该<code>Segment</code>会被锁定。它会创建自己新的、更大的内部<code>HashEntry</code>数组，并重新哈希自己的元素。顶层的<code>Segment</code>数组本身的大小是固定不变的 。</p></li></ul><p>分段锁的设计在当时是一种非常出色且务实的工程折衷方案。它通过将锁的空间分割成多个部分，成功地打破了<code>Hashtable</code>的全局锁瓶颈，实现了真正意义上的并发。然而，这个设计也存在其固有的局限性。首先，并发度是固定的，一旦在创建时选定，就无法动态调整以适应变化的负载或更多的CPU核心。其次，锁的粒度仍然相对较粗，一个<code>Segment</code>的锁会保护其内部的所有桶，当多个线程的键不幸哈希到同一个<code>Segment</code>时，它们依然会产生锁竞争，即便这些键本应落在不同的桶里。最后，像<code>size()</code>这样的全局操作的复杂性和高昂代价，也暴露了这种分段架构在维护全局一致性方面的困难。因此，尽管分段锁在当时是革命性的，但它只是通往更精细并发控制道路上的一个重要里程碑，为JDK 1.8的彻底重构铺平了道路。</p><h3 id="_2-2-jdk-1-8及以后-向细粒度并发的范式转移" tabindex="-1"><a class="header-anchor" href="#_2-2-jdk-1-8及以后-向细粒度并发的范式转移"><span>2.2 JDK 1.8及以后：向细粒度并发的范式转移</span></a></h3><p>JDK 1.8对<code>ConcurrentHashMap</code>的实现进行了一次彻底的重写，废弃了沿用已久的分段锁架构，引入了一套基于现代硬件特性和JVM优化的、更为精细和高效的并发控制模型。</p><h4 id="废除segments-统一天下" tabindex="-1"><a class="header-anchor" href="#废除segments-统一天下"><span>废除Segments，统一天下</span></a></h4><p><code>Segment</code>结构被完全移除。JDK 1.8及以后版本的<code>ConcurrentHashMap</code>回归到单一的、统一的节点数组（<code>Node</code>），其整体数据结构在外观上与现代<code>HashMap</code>非常相似，同样也引入了红黑树来优化哈希冲突严重的桶 。</p><h4 id="新的并发模型-cas-synchronized" tabindex="-1"><a class="header-anchor" href="#新的并发模型-cas-synchronized"><span>新的并发模型：<code>CAS</code> + <code>synchronized</code></span></a></h4><p>锁策略从分段级别下沉到了<strong>桶级别</strong>，实现了前所未有的细粒度。它不再依赖<code>ReentrantLock</code>，而是巧妙地结合了无锁的**CAS（Compare-And-Swap）**操作和轻量级的<code>synchronized</code>关键字。</p><p><strong><code>put</code>操作的并发艺术：</strong> <code>put</code>方法的实现逻辑是现代并发编程的杰作，它遵循一种“乐观-升级”的策略：</p><ol><li><strong>乐观的无锁尝试：</strong> 当一个键值对需要被放入一个当前为空（<code>null</code>）的桶时，线程会尝试使用一个无锁的<strong>CAS</strong>操作，直接将新创建的节点原子性地设置为该桶的头节点。这是最常见、最高效的路径，完全避免了加锁的开销 。</li><li><strong>CAS失败与重试：</strong> 如果CAS操作失败，意味着在同一时刻，有另一个线程捷足先登，已经占据了这个位置。此时，当前线程会进入一个自旋循环，重新读取桶的状态并尝试下一步操作。</li><li><strong>按需加锁：</strong> 如果目标桶已经不为空（即存在哈希冲突），线程则会进入加锁路径。但它锁定的不是一个巨大的<code>Segment</code>，而是该桶链表或红黑树的<strong>头节点</strong>。通过对头节点对象执行<code>synchronized</code>块，实现了对单个桶的锁定。这使得其他所有线程可以完全不受影响地并发操作所有其他的桶 。</li><li><strong>锁内操作：</strong> 一旦获取了桶级别的锁，后续的操作就和<code>HashMap</code>类似：遍历链表或红黑树，如果键已存在则更新值，如果不存在则在链表尾部或树中插入新节点。</li></ol><p>这种从悲观的粗粒度锁定（先锁住一大片区域再说）到乐观的、按需的、细粒度的锁定的哲学转变，是JDK 1.8 <code>ConcurrentHashMap</code>性能飞跃的根本原因。它充分利用了现代CPU提供的硬件级原子指令（CAS），并仅在真正发生数据竞争时才退回到锁机制，且将锁的影响范围降到了最低。<code>synchronized</code>关键字在现代JVM中经过了锁膨胀、锁消除等深度优化，其性能开销已经变得非常低，足以支持这种为成千上万个桶头节点按需加锁的模式。</p><h4 id="可伸缩的计数-longadder的应用" tabindex="-1"><a class="header-anchor" href="#可伸缩的计数-longadder的应用"><span>可伸缩的计数：<code>LongAdder</code>的应用</span></a></h4><p>为了解决JDK 1.7中<code>size()</code>方法性能低下的问题，新实现引入了<code>java.util.concurrent.atomic.LongAdder</code>。<code>LongAdder</code>是一个专为高并发更新而设计的原子累加器。它的内部维护了一组（而非单个）计数单元。当多个线程同时对其进行增加操作时，系统会通过哈希等方式将线程分散到不同的计数单元上进行更新，从而极大地减少了热点竞争。当需要获取总数时，再将所有内部单元的值相加。这种“分而治之”的计数方式提供了极高的伸缩性，使得<code>size()</code>（以及更推荐的<code>mappingCount()</code>）方法的性能在高并发下远超旧版实现，尽管其结果仍然是近似值 。</p><h4 id="协同式并发扩容" tabindex="-1"><a class="header-anchor" href="#协同式并发扩容"><span>协同式并发扩容</span></a></h4><p>扩容机制是<code>ConcurrentHashMap</code>在JDK 1.8中最复杂、也最精妙的部分。它实现了一种完全并发的、允许多线程协作完成的扩容模式。</p><ol><li><strong>扩容启动：</strong> 当需要扩容时，第一个检测到的线程会负责启动这个过程。它会创建一个新的、容量更大的<code>nextTable</code>，并开始数据迁移工作。</li><li><strong>前进节点（ForwardingNode）：</strong> 在迁移过程中，当一个旧表中的桶被处理完毕后，该桶的头节点会被替换成一个特殊的**<code>ForwardingNode</code>**。这个节点本身不存储数据，它的作用像一个路标，告诉后来的线程：“这个桶的数据已经迁移到新表了，请去新表操作” 。</li><li><strong>协同工作：</strong> 其他线程在执行<code>put</code>等操作时，如果发现自己要操作的桶的头节点是一个<code>ForwardingNode</code>，它就知道当前正在进行扩容。此时，该线程并不会阻塞等待，而是会<strong>主动加入到扩容工作中</strong>，帮助迁移其他尚未处理的桶。</li><li><strong>任务分配：</strong> 系统通过一个原子更新的<code>transferIndex</code>变量来协调和分配任务。每个参与扩容的线程都会“认领”一段连续的旧表桶区间进行迁移，从而实现了扩容工作在多个线程间的并行化处理 。</li></ol><p>这种“化竞争为协作”的设计思想，将被动等待的线程转变为生产力，极大地缩短了扩容过程的耗时，减少了其对应用吞吐量的影响。它代表了并发数据结构设计的顶尖水平。</p><h3 id="_2-3-jdk-8之后的时代-稳定与完善" tabindex="-1"><a class="header-anchor" href="#_2-3-jdk-8之后的时代-稳定与完善"><span>2.3 JDK 8之后的时代：稳定与完善</span></a></h3><p>JDK 8为<code>HashMap</code>和<code>ConcurrentHashMap</code>所奠定的核心架构被证明是极为成功和健壮的。对JDK 11、JDK 17及以后版本的深入研究表明，再未发生过同等级别的架构革命 。</p><p><code>ConcurrentHashMap</code>中为保持向后兼容性而保留的<code>concurrencyLevel</code>构造函数参数，在现代实现中实际上已被忽略，不再影响内部行为 。</p><p>后续JDK版本的演进主要集中在以下几个方面：</p><ul><li><strong>错误修复与边缘案例处理：</strong> 针对复杂并发场景下可能出现的细微bug进行修复 。</li><li><strong>性能微调：</strong> 在现有架构框架内进行局部的代码优化和性能调整。</li><li><strong>功能增强：</strong> 增加新的、能充分利用其并发特性的批量操作方法，例如支持并行处理的<code>forEach</code>、<code>search</code>和<code>reduce</code>等 。</li></ul><p>尽管一些微基准测试可能会显示不同JDK版本间存在微小的性能差异，但整体的性能特征和可伸缩性曲线与JDK 8的设计保持一致 。</p><p>这种架构上的长期稳定，标志着JDK 8的设计已经非常有效地解决了其前身的核心问题。它们在性能、并发性和可靠性之间达到了一个理想的平衡点，被认为是该领域内一个相对“已解决”的问题。Java平台工程师的重心也因此从重写这些基础组件，转向了在其上构建更丰富的生态系统和功能。这为广大的Java开发者提供了一个稳定、可靠且性能可预测的坚实基础。</p><h2 id="第三部分-对比分析与实践指南" tabindex="-1"><a class="header-anchor" href="#第三部分-对比分析与实践指南"><span>第三部分 对比分析与实践指南</span></a></h2><p>在深入剖析了<code>HashMap</code>与<code>ConcurrentHashMap</code>各自的内部实现和演进历程之后，本部分将进行直接的横向对比，并为开发者在实际项目中如何选择和使用它们提供清晰、可行的指导。</p><h3 id="_3-1-架构对决-concurrenthashmap-jdk-1-7-vs-jdk-1-8" tabindex="-1"><a class="header-anchor" href="#_3-1-架构对决-concurrenthashmap-jdk-1-7-vs-jdk-1-8"><span>3.1 架构对决：ConcurrentHashMap JDK 1.7 vs. JDK 1.8+</span></a></h3><p>为了直观地展示<code>ConcurrentHashMap</code>在JDK 1.7和JDK 1.8之间发生的深刻变革，下表对两个版本在关键架构特性上进行了总结。对于需要理解不同Java平台版本间性能和伸缩性差异的架构师和资深开发者而言，这张表提供了极具价值的速查参考。</p><table><thead><tr><th>特性</th><th>JDK 1.7 实现</th><th>JDK 1.8+ 实现</th></tr></thead><tbody><tr><td><strong>锁策略</strong></td><td>分段锁 (Segmented Locking)</td><td><code>CAS</code> + <code>synchronized</code></td></tr><tr><td><strong>锁原语</strong></td><td><code>ReentrantLock</code> (每个<code>Segment</code>一个)</td><td><code>synchronized</code> (作用于桶的头节点)</td></tr><tr><td><strong>锁粒度</strong></td><td><code>Segment</code>级别 (粗粒度)</td><td>哈希桶级别 (细粒度)</td></tr><tr><td><strong>数据结构</strong></td><td><code>Segment</code> 数组，每个<code>Segment</code>内含带链表的<code>HashEntry</code></td><td>单一的<code>Node</code>数组，桶内为链表或红黑树</td></tr><tr><td><strong><code>put</code>操作</strong></td><td>锁定<code>Segment</code> -&gt; 在<code>Segment</code>内部表中插入</td><td>乐观<code>CAS</code>尝试空桶插入；发生冲突时，<code>synchronized</code>锁定桶头节点</td></tr><tr><td><strong><code>get</code>操作</strong></td><td>绝大部分无锁，依赖<code>volatile</code>读</td><td>完全无锁，依赖<code>volatile</code>读</td></tr><tr><td><strong><code>size()</code>计算</strong></td><td>代价高昂：尝试无锁求和，若有并发修改则退化为全局加锁</td><td>高度可伸缩：使用<code>LongAdder</code>进行低冲突计数，结果为估算值</td></tr><tr><td><strong>扩容</strong></td><td>在<code>Segment</code>内部进行，持有该<code>Segment</code>的锁，<code>Segment</code>数组大小固定</td><td>并发协同进行，整个表扩容，其他线程可帮助迁移数据</td></tr><tr><td><strong>并发上限</strong></td><td>由<code>concurrencyLevel</code>参数固定 (如16)</td><td>动态，随桶数量/CPU核心数伸缩</td></tr></tbody></table><p>这张表格清晰地揭示了从JDK 1.7到1.8的演进是一次从宏观到微观、从悲观到乐观的范式转移。JDK 1.8+的设计在锁粒度、操作效率、可伸缩性等几乎所有方面都展现出压倒性的优势。</p><h3 id="_3-2-性能剖析与用例推荐" tabindex="-1"><a class="header-anchor" href="#_3-2-性能剖析与用例推荐"><span>3.2 性能剖析与用例推荐</span></a></h3><p>在选择使用哪种Map实现时，开发者必须根据具体的并发需求做出决策。这并非一个简单的“哪个更快”的问题，而是一个关乎程序正确性与性能表现的权衡。</p><ul><li><p><strong><code>HashMap</code></strong></p><ul><li><strong>优势：</strong> 在单线程环境中，其性能是无与伦比的。由于完全没有同步开销，它的<code>put</code>和<code>get</code>操作极为迅速 。</li><li><strong>劣势：</strong> <strong>非线程安全</strong>。在任何多线程共享的场景下，若无外部同步措施（如<code>synchronized</code>块或<code>Lock</code>），直接使用<code>HashMap</code>将导致不可预测的行为，包括数据丢失、数据不一致，以及在扩容时可能出现的无限循环 。</li><li><strong>推荐场景：</strong> <strong>所有非并发场景下的首选</strong>。它适用于方法内的局部变量、线程私有的成员变量，以及任何可以确保只被单个线程访问的数据结构。</li></ul></li><li><p><strong><code>Collections.synchronizedMap(new HashMap(...))</code></strong></p><ul><li><strong>机制：</strong> 这是一个装饰器模式的应用，它接收一个<code>HashMap</code>实例，并返回一个包装后的<code>Map</code>。这个包装类的每一个方法（包括读和写）都被一个全局的<code>synchronized</code>锁保护。</li><li><strong>性能：</strong> 在高并发场景下性能极差。全局锁意味着任何时刻只允许一个线程访问该Map，所有并发操作都被强制串行化，形成严重的性能瓶颈 。</li><li><strong>推荐场景：</strong> <strong>基本已被淘汰</strong>。在几乎所有的并发用例中，<code>ConcurrentHashMap</code>都提供了远胜于它的性能 。只有在极少数需要强制所有访问（包括读和读，读和写，写和写）都完全互斥的特殊业务逻辑下，才可能考虑使用它。</li></ul></li><li><p><strong><code>ConcurrentHashMap</code></strong></p><ul><li><p><strong>优势：</strong> 专为高并发环境设计。它允许多个线程同时进行读操作和高并发的写操作。读操作是非阻塞的，迭代器是“弱一致性”且“故障安全”的，不会抛出<code>ConcurrentModificationException</code> 。</p></li><li><p><strong>性能：</strong> 在单线程环境下，由于<code>volatile</code>读写和内部并发机制的开销，其性能会略低于<code>HashMap</code> 。然而，随着线程数量和锁竞争的增加，它的性能能够出色地伸缩，远超</p><p><code>synchronizedMap</code> 。</p></li><li><p><strong>推荐场景：</strong> <strong>所有需要在多线程间共享的Map场景下的标准选择</strong>。例如，用作全局缓存、共享注册表、静态成员Map等。其卓越的性能和可靠的线程安全保证，使其成为Java并发编程的基石之一 。</p></li></ul></li></ul><p>最终的选择流程应遵循一个清晰的决策树：首先判断“该Map实例是否会被多个线程访问？”。如果答案为“否”，则毫无疑问地选择<code>HashMap</code>。如果答案为“是”，则应默认选择<code>ConcurrentHashMap</code>。这是一个以程序<strong>正确性</strong>为首要考量的决策，而非单纯的性能比较。试图用<code>HashMap</code>在并发环境中换取微不足道的单线程性能优势，是以牺牲程序的稳定性和数据的完整性为代价的，这在任何严肃的软件工程实践中都是不可接受的。</p>',86)]))}const h=o(n,[["render",t]]),g=JSON.parse('{"path":"/8gu/Hashmap_ConcurrentHashmap%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E5%90%84%E4%B8%AAJDK%E4%B8%8B%E7%9A%84%E5%B7%AE%E5%BC%82.html","title":"HashMap与ConcurrentHashMap深度解析：架构、演进与性能的跨JDK版本剖析","lang":"zh-CN","frontmatter":{"description":"HashMap与ConcurrentHashMap深度解析：架构、演进与性能的跨JDK版本剖析 第一部分 HashMap的剖析 本部分将专注于剖析非并发环境下的HashMap，它不仅是Java中使用最广泛的Map实现，其核心的数据结构与算法也是理解ConcurrentHashMap演进的基石。我们将深入探讨其从简单的链表结构到引入复杂平衡树的转变，以及...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HashMap与ConcurrentHashMap深度解析：架构、演进与性能的跨JDK版本剖析\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-15T01:09:46.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/Hashmap_ConcurrentHashmap%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E5%90%84%E4%B8%AAJDK%E4%B8%8B%E7%9A%84%E5%B7%AE%E5%BC%82.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"HashMap与ConcurrentHashMap深度解析：架构、演进与性能的跨JDK版本剖析"}],["meta",{"property":"og:description","content":"HashMap与ConcurrentHashMap深度解析：架构、演进与性能的跨JDK版本剖析 第一部分 HashMap的剖析 本部分将专注于剖析非并发环境下的HashMap，它不仅是Java中使用最广泛的Map实现，其核心的数据结构与算法也是理解ConcurrentHashMap演进的基石。我们将深入探讨其从简单的链表结构到引入复杂平衡树的转变，以及..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-15T01:09:46.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-15T01:09:46.000Z"}]]},"git":{"createdTime":1755143302000,"updatedTime":1755220186000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":2,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":25,"words":7499},"filePathRelative":"8gu/Hashmap,ConcurrentHashmap以及它们各个JDK下的差异.md","autoDesc":true}');export{h as comp,g as data};
