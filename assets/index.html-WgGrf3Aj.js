import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,e as s,b as a,a as o,r as e,o as r}from"./app-BAQ326uN.js";const p={};function g(d,i){const l=e("PDF");return r(),t("div",null,[i[0]||(i[0]=s("h1",{id:"个人面经分享",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#个人面经分享"},[s("span",null,"个人面经分享")])],-1)),i[1]||(i[1]=s("p",null,"我将在这里分享我的面试经历并附加Gemini AI的相关回答,这是我的简历",-1)),a(l,{url:"龙昊.pdf"}),i[2]||(i[2]=o(`<h2 id="欧斯特智能-上海" tabindex="-1"><a class="header-anchor" href="#欧斯特智能-上海"><span>欧斯特智能(上海)</span></a></h2><p><strong>2025.09.01</strong></p><ul><li><p>学校那边可以搞定吗?</p></li><li><p>有使用过三级缓存吗?</p></li><li><p>缓存一致性怎么保证?</p></li><li><p>如果数据库不支持Binlog怎么保证一致性?</p></li><li><p>你提到了延时双删,它有什么问题?</p></li><li><p>JDK21有什么新特性?</p></li><li><p>虚拟线程有了解过吗?</p></li><li><p>IO密集型的线程池怎么设计(虚拟线程)?</p></li><li><p>MQ消息怎么避免重复消费和未消费?</p></li><li><p>在使用Redis和MQ之后怎么保证消息不丢失(分级分用户入库+WAL)?</p></li><li><p>Springboot3相较2有哪些新的注解?</p></li><li><p>了解过grpc吗?</p></li><li><p>了解过DDD吗?</p></li><li><p>了解过向量数据库吗?</p></li></ul><blockquote><h3 id="_1-有使用过三级缓存吗" tabindex="-1"><a class="header-anchor" href="#_1-有使用过三级缓存吗"><span>1. 有使用过三级缓存吗?</span></a></h3><p>在实际的应用开发中，&quot;三级缓存&quot; 通常指的是一个多层次的缓存架构，旨在最大化缓存命中率，降低对后端数据源的压力。虽然没有一个严格的、放之四海而皆准的“三级缓存”定义，但一个经典的实现通常包含以下几个层次：</p><ol><li><strong>一级缓存（本地缓存/堆内存缓存）</strong>: <ul><li><strong>实现</strong>: 通常使用<code>ConcurrentHashMap</code>、<code>Guava Cache</code>或<code>Caffeine</code>等库在应用内部实现。</li><li><strong>优点</strong>: 速度最快，没有网络开销，直接从内存读取。</li><li><strong>缺点</strong>: 容量有限，受限于单机内存；多实例部署时，缓存数据不共享，存在一致性问题。</li><li><strong>应用场景</strong>: 缓存更新不频繁但读取极其频繁的热点数据。</li></ul></li><li><strong>二级缓存（分布式缓存）</strong>: <ul><li><strong>实现</strong>: 使用Redis、Memcached等独立的分布式缓存系统。</li><li><strong>优点</strong>: 独立部署，容量大，所有应用实例共享，解决了本地缓存的数据共享问题。</li><li><strong>缺点</strong>: 存在网络I/O开销，速度慢于本地缓存。</li><li><strong>应用场景</strong>: 系统中的核心热点数据，读多写少的场景。</li></ul></li><li><strong>三级缓存（兜底缓存/近线缓存）</strong>: <ul><li><strong>实现</strong>: 这一层的实现比较多样化，可以是： <ul><li><strong>分布式文件系统/对象存储</strong>: 如NFS、HDFS、S3等，用于存储非结构化或半结构化的数据。</li><li><strong>NoSQL数据库</strong>: 如Elasticsearch、HBase等，用于特定场景的查询加速。</li><li><strong>更持久化的二级缓存</strong>: 例如Redis的AOF或RDB持久化文件，在缓存服务重启时可以快速恢复一部分热数据。</li></ul></li><li><strong>优点</strong>: 持久化，容量更大，作为数据库前的最后一道防线，防止大量请求直接穿透到数据库。</li><li><strong>缺点</strong>: 速度最慢，通常用于对时效性要求不那么高的数据。</li></ul></li></ol><p><strong>总结</strong>: 是的，在构建复杂的高性能系统时，这种分层缓存的思想被广泛应用。例如，一个典型的电商系统在查询商品详情时，会先查Caffeine，未命中则查Redis，再未命中则查询Elasticsearch或最终的数据库，这便构成了一个事实上的多级缓存体系</p><h3 id="_2-缓存一致性怎么保证" tabindex="-1"><a class="header-anchor" href="#_2-缓存一致性怎么保证"><span>2. 缓存一致性怎么保证?</span></a></h3><p>保证缓存与数据库之间的数据一致性是缓存应用中的核心难题。常见的保证方案有以下几种，需要根据业务场景对一致性要求的级别来选择：</p><ol><li><strong>Cache-Aside Pattern (旁路缓存模式)</strong>: 这是最常用的一种模式。 <ul><li><strong>读</strong>: 先读缓存，缓存命中则直接返回；缓存未命中，则读数据库，然后将数据写入缓存，再返回。</li><li><strong>写</strong>: <strong>先更新数据库，再删除缓存</strong>。</li><li><strong>为什么是删除缓存而不是更新缓存？</strong><ul><li><strong>懒加载</strong>: 只有在下次读取时才加载，避免了无效的写操作。如果更新了缓存但该数据后续一直没被访问，就浪费了资源。</li><li><strong>并发问题</strong>: &quot;先更新数据库，再更新缓存&quot; 在并发场景下，可能会导致缓存和数据库数据不一致（脏数据）。例如，线程A更新数据库，线程B更新数据库，线程B先更新了缓存，线程A后更新了缓存，导致缓存中是A的数据（旧数据）。而删除操作是幂等的，多次删除结果一致。</li></ul></li></ul></li><li><strong>Read-Through/Write-Through/Write-Behind (读穿透/写穿透/回写模式)</strong>: 这类模式通常由一些缓存框架或组件提供支持，将缓存和数据库的操作封装起来，对应用层透明。 <ul><li><strong>Read-Through</strong>: 应用读缓存，如果缓存未命中，由缓存服务自己负责从数据库加载数据并返回。</li><li><strong>Write-Through</strong>: 应用写缓存，由缓存服务负责将数据写入数据库，两者都成功后才返回。保证了强一致性，但牺牲了性能。</li><li><strong>Write-Behind (Write-Back)</strong>: 应用只管写缓存，由缓存服务异步地、批量地将数据写入数据库。性能最好，但存在数据丢失的风险（例如缓存服务宕机）。</li></ul></li><li><strong>订阅Binlog，异步更新缓存</strong>: <ul><li><strong>思路</strong>: 通过Canal、Debezium等工具订阅MySQL的Binlog日志，获取数据库的实时变更数据。</li><li><strong>流程</strong>: 当监听到数据库发生变更（INSERT, UPDATE, DELETE）时，由一个专门的服务去解析Binlog，然后去更新或删除对应的缓存。</li><li><strong>优点</strong>: 业务代码与缓存维护逻辑解耦，对业务代码无侵入；可以实现最终一致性，延迟较低。</li><li><strong>缺点</strong>: 架构复杂度高，需要引入额外的中间件和维护成本。</li></ul></li></ol><h3 id="_3-如果数据库不支持binlog怎么保证一致性" tabindex="-1"><a class="header-anchor" href="#_3-如果数据库不支持binlog怎么保证一致性"><span>3. 如果数据库不支持Binlog怎么保证一致性?</span></a></h3><p>如果底层数据库（例如一些NoSQL数据库或老旧的关系型数据库）不提供类似MySQL Binlog的事务日志订阅功能，一致性的保证会变得更加困难，通常可以采用以下策略：</p><ol><li><strong>消息队列 (Message Queue)</strong>: <ul><li><strong>思路</strong>: 在更新数据库的业务逻辑中，同时发送一条消息到MQ。</li><li><strong>流程</strong>: 一个独立的消费者服务订阅该消息，当收到消息后，去执行缓存的删除或更新操作。</li><li><strong>挑战</strong>: 这引入了分布式事务的问题。如何保证“更新数据库”和“发送MQ消息”这两个操作的原子性？ <ul><li><strong>本地消息表/发件箱模式 (Outbox Pattern)</strong>: 将业务操作和要发送的消息放在同一个本地事务中完成。一个后台任务定时轮询这张消息表，将消息发送到MQ，并标记为已发送。这是保证最终一致性的可靠方案。</li><li><strong>事务消息</strong>: 依赖MQ提供的事务消息功能（如RocketMQ），但会增加业务代码的复杂度。</li></ul></li></ul></li><li><strong>定时任务轮询/ETL</strong>: <ul><li><strong>思路</strong>: 通过一个定时任务，周期性地去扫描数据库中的数据变更（例如通过一个<code>last_updated_time</code>时间戳字段）。</li><li><strong>流程</strong>: 定时任务拉取变更的数据，然后更新缓存。</li><li><strong>缺点</strong>: 一致性的延迟较高，取决于轮询的频率；对数据库有一定的查询压力。适用于对一致性要求不高的场景。</li></ul></li><li><strong>应用层双写</strong>: <ul><li>在应用代码中，同时写入数据库和缓存。这种方式问题最多，并发控制复杂，很容易出现不一致，<strong>通常不推荐</strong>。</li></ul></li></ol><h3 id="_4-你提到了延时双删-它有什么问题" tabindex="-1"><a class="header-anchor" href="#_4-你提到了延时双删-它有什么问题"><span>4. 你提到了延时双删,它有什么问题?</span></a></h3><p>&quot;延时双删&quot; 是对Cache-Aside模式中“先更新数据库，再删除缓存”方案的一种优化，旨在解决一个特定的并发问题。</p><p><strong>问题场景</strong>:</p><ol><li>线程A请求更新数据。</li><li>线程A执行<code>UPDATE database</code>。</li><li>线程A执行<code>DELETE cache</code>。<strong>在删除前</strong>，线程B发起了一次读请求。</li><li>线程B <code>SELECT</code> 缓存，发现缓存不存在（或已被一个更早的写操作删除）。</li><li>线程B <code>SELECT database</code>，读取到了<strong>旧数据</strong>（因为此时线程A的事务可能还未提交）。</li><li>线程B将<strong>旧数据</strong>写入了缓存。</li><li>线程A完成了缓存删除操作。</li></ol><p>此时，缓存中的数据是旧的，而数据库中的是新的，导致了不一致，且这个脏数据会一直存在，直到缓存过期或下次被更新。</p><p><strong>延时双删策略</strong>:</p><ol><li>先淘汰缓存。</li><li>再写数据库。</li><li>休眠一段时间（例如几百毫秒）。</li><li>再次淘汰缓存。</li></ol><p><strong>延时双删的问题</strong>:</p><ol><li><strong>休眠时间的确定是难题</strong>: 这个“延时”时间到底设置多久？ <ul><li>太短，可能无法覆盖掉并发读操作将旧数据写入缓存的时间窗口，问题依旧存在。</li><li>太长，会影响系统吞吐量，并且在这段时间内，数据的不一致性是确定存在的。这个时间需要根据业务的读写耗时来估算，但很难精确。</li></ul></li><li><strong>吞吐量下降</strong>: 引入了<code>sleep</code>操作，使得写操作的耗时显著增加，降低了系统的整体吞吐能力。</li><li><strong>无法完全避免问题</strong>: 在极端情况下，例如主从数据库延迟很高时，延时双删依然可能失败。如果休眠时间小于主从同步的延迟，那么在第二次删除缓存后，读请求依然可能从“从库”读取到旧数据并写回缓存。</li></ol><p><strong>结论</strong>: 延时双删是一种“妥协”的方案，实现复杂且效果不完美。在绝大多数场景下，<strong>“先更新数据库，再删除缓存”，并为缓存设置合理的过期时间</strong>，已经能够满足需求。如果对一致性要求非常高，那么应该优先考虑<strong>订阅Binlog的异步更新方案</strong>。</p><h3 id="_5-jdk21有什么新特性" tabindex="-1"><a class="header-anchor" href="#_5-jdk21有什么新特性"><span>5. JDK21有什么新特性?</span></a></h3><p>JDK 21是一个长期支持（LTS）版本，带来了许多重要的新特性，其中最引人注目的是：</p><ol><li><strong>虚拟线程 (Virtual Threads) - 正式版</strong>: 这是Project Loom的核心成果。虚拟线程是由JDK而非操作系统内核管理的轻量级线程。它们极大地简化了编写、维护和观察高吞吐量并发应用的过程。</li><li><strong>结构化并发 (Structured Concurrency) - 预览阶段</strong>: 简化并发编程，将不同线程中运行的相关任务组视为一个工作单元，简化错误处理和取消操作，提高代码的可靠性和可观察性。</li><li><strong>作用域值 (Scoped Values) - 预览阶段</strong>: 提供了一种在线程内以及线程间共享不可变数据的新方式，是<code>ThreadLocal</code>的更优替代方案，尤其是在使用大量虚拟线程时。</li><li><strong>字符串模板 (String Templates) - 预览阶段</strong>: 简化字符串拼接和格式化，通过模板和嵌入式表达式生成字符串，比传统的<code>+</code>拼接或<code>String.format()</code>更易读、更安全。</li><li><strong>未命名类和实例主方法 (Unnamed Classes and Instance Main Methods) - 预览阶段</strong>: 旨在降低Java学习的门槛，让初学者可以编写更简洁的“Hello, World!”程序。</li><li><strong>序列化集合 (Sequenced Collections)</strong>: 引入了新的接口<code>SequencedCollection</code>, <code>SequencedSet</code>, 和 <code>SequencedMap</code>，为集合提供统一的、定义明确的遍历顺序，并提供了获取第一个/最后一个元素、反向遍历等标准API。</li><li><strong>switch模式匹配 (Pattern Matching for switch) - 正式版</strong>: 扩展了<code>switch</code>语句和表达式，使其可以对对象的类型和结构进行匹配，代码更简洁、更安全。</li><li><strong>记录模式 (Record Patterns) - 正式版</strong>: 用于解构记录（Record）实例，可以与模式匹配（如<code>instanceof</code>和<code>switch</code>）结合使用，方便地提取组件数据。</li></ol><h3 id="_6-虚拟线程有了解过吗" tabindex="-1"><a class="header-anchor" href="#_6-虚拟线程有了解过吗"><span>6. 虚拟线程有了解过吗?</span></a></h3><p>是的，有深入了解。</p><p>核心概念:</p><p>虚拟线程（Virtual Thread）是JDK实现的用户态线程，它并不直接映射到操作系统的内核线程（Platform Thread）。相反，大量的虚拟线程可以运行在少数几个内核线程上。</p><p><strong>工作原理</strong>:</p><ul><li>当一个虚拟线程执行I/O操作或其他阻塞操作时，它不会阻塞底层的内核线程。</li><li>JVM会<strong>挂起</strong>这个虚拟线程，并将其从内核线程上卸下（unmount）。</li><li>内核线程（Carrier Thread）可以立即去执行另一个准备就绪的虚拟线程。</li><li>当之前的I/O操作完成后，被挂起的虚拟线程会重新变为可运行状态，并被调度到任意一个可用的内核线程上继续执行（mount）。</li></ul><p><strong>优势</strong>:</p><ol><li><strong>极高的吞吐量</strong>: 可以轻松创建数百万个虚拟线程而不会耗尽系统资源。因为虚拟线程本质上只是一个轻量级的Java对象，占用的内存很小。</li><li><strong>简化并发编程</strong>: 可以用传统的回车符换行，同步阻塞式的编程模型（per-request-per-thread）来编写代码，而无需使用复杂、易错的异步/响应式编程（如<code>CompletableFuture</code>或<code>Reactive Streams</code>），就能达到异步编程的性能和扩展性。代码更易读、易调试、易维护。</li><li><strong>兼容现有API</strong>: 大部分现有的Java同步API（如<code>InputStream</code>, <code>OutputStream</code>, <code>Socket</code>等）在虚拟线程中运行时，会自动触发挂起/恢复的调度，无需修改代码。</li></ol><p>适用场景:</p><p>非常适合I/O密集型或网络密集型的应用，例如：</p><ul><li>微服务网关</li><li>Web服务器</li><li>数据库连接代理</li><li>任何需要处理大量并发连接和请求，且大部分时间花在等待网络或磁盘响应的场景。</li></ul><p>不适用场景:</p><p>不适合CPU密集型的任务。因为虚拟线程的目标是提高并发吞吐量，而不是并行计算能力。CPU密集型任务需要的是与CPU核心数相当的内核线程来并行执行，使用虚拟线程不会带来性能提升，反而可能因为额外的调度开销而略有下降。</p><h3 id="_7-io密集型的线程池怎么设计-虚拟线程" tabindex="-1"><a class="header-anchor" href="#_7-io密集型的线程池怎么设计-虚拟线程"><span>7. IO密集型的线程池怎么设计(虚拟线程)?</span></a></h3><p>使用虚拟线程来处理IO密集型任务，线程池的设计思想发生了根本性的转变。</p><p><strong>传统线程池设计 (使用平台线程)</strong>:</p><ul><li>需要精心计算线程池大小，通常根据<code>核心数 * (1 + 等待时间/计算时间)</code>的公式来估算。</li><li>线程数是一个宝贵的、有限的资源，需要池化来复用。</li><li>任务队列是必须的，用于缓冲无法立即处理的请求。</li></ul><p>使用虚拟线程的设计:</p><p>不需要传统的线程池了！</p><p>正确的做法是：<strong>为每一个任务（例如，每一个进来的HTTP请求）创建一个新的虚拟线程</strong>。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在JDK 21中，可以这样简单地处理请求</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> executor </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Executors</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">newVirtualThreadPerTaskExecutor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1000000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Runnable</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> task </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> () </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 执行IO密集型任务，例如调用一个远程API</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 或者查询数据库</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 这里的代码是同步阻塞式的</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            handleRequest</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        executor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">submit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(task);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// try-with-resources 会自动关闭 executor</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么可以这样做？</strong></p><ul><li><strong>创建成本极低</strong>: 创建一个虚拟线程几乎没有开销，和创建一个普通对象类似。</li><li><strong>无限的并发能力</strong>: 理论上可以创建任意数量的虚拟线程，受限于内存而非操作系统线程数限制。</li><li><strong>自动调度</strong>: JVM的ForkJoinPool会负责将这些虚拟线程调度到后端的少量平台线程（Carrier Threads）上去执行。当虚拟线程遇到IO阻塞时，会自动让出平台线程。</li></ul><p><strong>结论</strong>: 在虚拟线程的世界里，对于IO密集型任务，我们不再需要管理和池化线程。设计模式回归到了最简单的“一个请求一个线程”模型，但却获得了异步编程的性能。你只需要使用 <code>Executors.newVirtualThreadPerTaskExecutor()</code>，然后放心地为每个任务提交一个新的虚拟线程即可。</p><h3 id="_8-mq消息怎么避免重复消费和未消费" tabindex="-1"><a class="header-anchor" href="#_8-mq消息怎么避免重复消费和未消费"><span>8. MQ消息怎么避免重复消费和未消费?</span></a></h3><p>这是保证MQ消息可靠性的两个核心问题。</p><p><strong>1. 避免未消费 (保证消息至少被消费一次 At-Least-Once)</strong></p><ul><li><strong>ACK机制</strong>: 这是最核心的机制。消费者在成功处理完消息后，向MQ发送一个确认（ACK）信号。 <ul><li><strong>自动ACK</strong>: 消费者拉取到消息后，客户端库立即自动发送ACK。这种方式如果消费者在处理消息过程中宕机，消息会丢失。</li><li><strong>手动ACK</strong>: 消费者在业务逻辑<strong>完全成功</strong>执行完毕后，手动调用API发送ACK。如果在处理过程中出现异常，则不发送ACK（或发送NACK，表示消费失败）。</li></ul></li><li><strong>重试机制</strong>: 当MQ没有在规定时间内收到消费者的ACK时（或收到NACK），它会认为消息没有被成功消费，并在一段时间后将该消息<strong>重新投递</strong>给其他（或同一个）消费者。</li></ul><p><strong>2. 避免重复消费 (保证消息最多被消费一次 At-Most-Once 或 精确一次 Exactly-Once)</strong></p><p>由于重试机制的存在（例如，消费者成功处理了消息，但在发送ACK时网络中断或宕机），重复消费是可能发生的。解决方案的核心是：<strong>保证消费逻辑的幂等性 (Idempotence)</strong>。</p><p>幂等性意味着对同一个操作执行一次和执行多次，结果是完全相同的。实现幂等性的常见方法有：</p><ul><li><strong>数据库唯一键</strong>: 利用数据库的唯一索引或主键约束。例如，订单创建消息，可以用订单ID作为主键，重复的消息在<code>INSERT</code>时会因为主键冲突而失败。</li><li><strong>状态机控制</strong>: 在数据库中为业务数据设计一个状态字段。例如，订单状态有“待支付”、“已支付”、“已取消”。如果一个“支付成功”的消息来了，只有当订单状态是“待支付”时才执行更新操作，如果已经是“已支付”，则直接忽略。 <ul><li><code>UPDATE orders SET status = &#39;PAID&#39; WHERE order_id = ? AND status = &#39;PENDING&#39;;</code></li><li>通过返回值判断影响的行数，如果为0，说明是重复消费。</li></ul></li><li><strong>全局唯一ID + 记录表</strong>: <ul><li>为每条消息生成一个全局唯一的ID（可以使用业务ID，如订单号；或消息自身的Message ID）。</li><li>消费者端准备一个“消费记录表”。</li><li>在处理消息前，先查询这个ID是否在记录表中存在。</li><li>如果存在，说明是重复消息，直接忽略并ACK。</li><li>如果不存在，则将该ID插入记录表，然后处理业务逻辑。<strong>这两个操作需要放在同一个本地事务中</strong>，保证原子性。</li></ul></li></ul><p><strong>总结</strong>: 通过 <strong>手动ACK + 重试机制</strong> 保证了消息“至少被消费一次”，再通过 <strong>消费端实现幂等性</strong> 来解决重试带来的重复消费问题，最终可以实现“精确一次消费”的业务效果。</p><h3 id="_9-在使用redis和mq之后怎么保证消息不丢失-分级分用户入库-wal" tabindex="-1"><a class="header-anchor" href="#_9-在使用redis和mq之后怎么保证消息不丢失-分级分用户入库-wal"><span>9. 在使用Redis和MQ之后怎么保证消息不丢失(分级分用户入库+WAL)?</span></a></h3><p>这个问题场景比较复杂，结合了缓存、消息队列和数据库持久化，旨在构建一个高可靠的数据处理链路。这里的“分级分用户入库+WAL”是一种具体的、高级的可靠性保证方案。我们来分解一下。</p><p><strong>消息不丢失需要保证三个环节的可靠性</strong>:</p><ol><li><strong>生产者 -&gt; MQ</strong>: 消息不能在发送过程中丢失。</li><li><strong>MQ自身</strong>: 消息在MQ中存储时不能丢失。</li><li><strong>MQ -&gt; 消费者</strong>: 消息在消费过程中不能丢失。</li></ol><p><strong>综合解决方案</strong>:</p><ol><li><strong>生产者端可靠性</strong>: <ul><li>使用MQ提供的<strong>事务消息</strong>或<strong>生产者确认机制 (Publisher Confirms)</strong>。</li><li><strong>Publisher Confirms</strong>: 发送消息后，生产者阻塞或异步等待MQ的确认回执。如果未收到确认（或收到失败确认），则进行重试。</li><li><strong>结合本地消息表 (Outbox Pattern)</strong>: 这是最可靠的方式。将业务操作和写“本地消息表”放在一个数据库事务里。一个独立的任务轮询这张表，将消息发送到MQ，成功后再更新表状态。</li></ul></li><li><strong>MQ自身可靠性</strong>: <ul><li><strong>持久化</strong>: 将消息配置为持久化模式。队列和消息都设置为durable。这样即使MQ服务重启，消息也不会丢失。</li><li><strong>集群/镜像</strong>: 部署MQ集群，使用镜像队列等机制，将消息副本存储在多个节点上，防止单点故障。</li></ul></li><li><strong>消费者端可靠性</strong>: <ul><li><strong>手动ACK</strong>: 如上一问所述，业务处理成功后才发送确认。</li><li><strong>幂等性处理</strong>: 防止重试导致数据错乱。</li></ul></li></ol><p><strong>融入 Redis 和 “分级分用户入库+WAL” 策略</strong>:</p><p>这是一个典型的<strong>高性能异步入库场景</strong>。例如，处理海量的用户行为日志或计费请求。直接写入数据库会很慢，所以引入了Redis和MQ来削峰填谷和异步处理。</p><ul><li><strong>分级</strong>: 可能指对不同优先级的消息进行分级处理。例如，VIP用户的请求走高优先级队列，普通用户走普通队列。</li><li><strong>分用户</strong>: 为了避免单个用户的异常数据影响整体，以及为了后续追踪和数据隔离，可能会按用户ID进行分片或路由到不同的队列/消费者。</li><li><strong>入库</strong>: 最终的目标是将数据持久化到数据库。</li></ul><p><strong>WAL (Write-Ahead Logging, 预写日志)</strong> 在这里的应用，是一种提升消费者端性能和可靠性的关键技术。</p><p><strong>流程可以是这样的</strong>:</p><ol><li><strong>接收与缓冲</strong>: 消费者从MQ获取批量消息。</li><li><strong>写入Redis</strong>: 将消息数据快速写入Redis，可以做一些初步的聚合或格式转换。Redis在这里起到了一个高速缓冲层的作用。</li><li><strong>写入WAL</strong>: 在将数据写入数据库<strong>之前</strong>，消费者先把这个“写数据库”的操作（例如，SQL语句或数据变更记录）以日志的形式，<strong>顺序写入</strong>一个本地的持久化文件（WAL文件）。这个写文件操作非常快。</li><li><strong>ACK消息</strong>: 一旦WAL写入成功，消费者就可以<strong>立即向MQ发送ACK</strong>，表示这批消息已经“安全”了。即使此时消费者进程崩溃，由于操作记录在WAL中，重启后可以读取WAL来恢复，不会丢失数据。</li><li><strong>异步批量入库</strong>: 一个独立的后台线程，负责读取WAL文件中的操作记录，然后以<strong>较高的批处理效率</strong>将数据批量写入最终的数据库（如MySQL, HBase等）。</li><li><strong>Checkpoint</strong>: 当WAL中的数据成功写入数据库后，会定期或定量地在WAL文件中做一个检查点（Checkpoint），表示这个点之前的数据已经持久化，可以安全删除了。</li></ol><p><strong>这种架构的优势</strong>:</p><ul><li><strong>高吞吐量</strong>: 消费者的核心逻辑只是飞快地写Redis和本地文件（WAL），然后就可以ACK了，消费速度极快。</li><li><strong>高可靠性</strong>: WAL保证了即使在异步入库的过程中发生故障，数据也不会丢失。这是借鉴了数据库本身的设计思想。</li><li><strong>数据库压力小</strong>: 最终对数据库的写入是异步的、批量的，大大降低了数据库的写压力。</li></ul><h3 id="_10-springboot3相较2有哪些新的注解" tabindex="-1"><a class="header-anchor" href="#_10-springboot3相较2有哪些新的注解"><span>10. Springboot3相较2有哪些新的注解?</span></a></h3><p>Spring Boot 3.0 是一个重要的主版本升级，它基于 Spring Framework 6，要求 Java 17 作为最低版本，并迁移到了 Jakarta EE 9/10。注解方面的变化虽然不是铺天盖地，但有一些值得关注的新增和变化：</p><ol><li><strong><code>@GraphQlController</code> 和相关注解</strong>: <ul><li>随着Spring for GraphQL的正式集成，引入了一系列注解来简化GraphQL应用的开发，如 <code>@QueryMapping</code>, <code>@MutationMapping</code>, <code>@SubscriptionMapping</code>, <code>@SchemaMapping</code> 等。这取代了之前需要手动配置<code>RuntimeWiring.Builder</code>的方式。</li></ul></li><li><strong><code>@HttpExchange</code></strong>: <ul><li>用于创建声明式的HTTP客户端接口，类似于Feign。你可以定义一个Java接口，并使用<code>@HttpExchange</code>（或更具体的<code>@GetExchange</code>, <code>@PostExchange</code>等）来注解方法，Spring会自动为你生成实现类来发起HTTP请求。</li></ul></li><li><strong>Observability (可观测性) 相关的注解和改进</strong>: <ul><li>Spring Boot 3全面拥抱了Micrometer Tracing，整合了Brave和OpenTelemetry等分布式追踪方案。虽然不全是“新注解”，但像<code>@Observed</code> (来自Micrometer)这样的注解变得更加核心和易用，可以方便地为方法添加metrics、logging和tracing。</li></ul></li><li><strong>AOT (Ahead-Of-Time) 相关的提示注解</strong>: <ul><li>为了支持GraalVM原生镜像（Native Image）编译，引入了<code>@RegisterReflectionForBinding</code>, <code>@Reflective</code> 等<code>RuntimeHints</code>相关的注解。开发者可以通过这些注解，向AOT编译器提供关于反射、序列化、动态代理等运行时行为的提示，确保原生镜像能够正确运行。</li></ul></li></ol><p><strong>更重要的是一些底层和依赖的变化，而非仅仅是注解</strong>:</p><ul><li><strong>Jakarta EE迁移</strong>: 所有之前使用<code>javax.*</code>包名的API都变成了<code>jakarta.*</code>。例如 <code>javax.servlet.http.HttpServletRequest</code> 变为 <code>jakarta.servlet.http.HttpServletRequest</code>。这导致了大量依赖库需要升级。</li><li><strong>配置文件处理变化</strong>: <code>spring.factories</code> 的服务加载机制被新的 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 文件所取代，虽然对普通用户影响不大，但对库开发者影响很大。</li></ul><h3 id="_11-了解过grpc吗" tabindex="-1"><a class="header-anchor" href="#_11-了解过grpc吗"><span>11. 了解过grpc吗?</span></a></h3><p>是的，非常了解。</p><p><strong>gRPC (gRPC Remote Procedure Calls)</strong> 是一个由Google开发的高性能、开源、通用的RPC（远程过程调用）框架。</p><p><strong>核心特点</strong>:</p><ol><li><strong>基于HTTP/2</strong>: <ul><li>HTTP/2提供了多路复用、头部压缩、服务端推送、二进制分帧等特性，使得gRPC在单个TCP连接上可以处理多个并发请求，大大降低了延迟，提升了网络利用率。</li></ul></li><li><strong>使用Protocol Buffers (Protobuf)</strong>: <ul><li>gRPC默认使用Protobuf作为其接口定义语言（IDL）和消息交换格式。</li><li><strong>IDL</strong>: 你在一个<code>.proto</code>文件中定义服务（Service）、方法（RPC）以及消息（Message）的结构。</li><li><strong>序列化</strong>: Protobuf是一种高效的二进制序列化协议，序列化后的数据体积小、解析速度快，相比JSON/XML有明显的性能优势。</li><li><strong>强类型与代码生成</strong>: 通过<code>.proto</code>文件，可以使用<code>protoc</code>编译器生成指定语言（Java, Go, Python, C++等）的客户端存根（stub）和服务端骨架代码，实现了强类型的接口约束，避免了联调时的很多低级错误。</li></ul></li><li><strong>支持多种通信模式</strong>: <ul><li><strong>Unary RPC</strong>: 传统的请求-响应模式，客户端发送一个请求，服务端返回一个响应。</li><li><strong>Server Streaming RPC</strong>: 客户端发送一个请求，服务端返回一个数据流，可以持续发送多个消息。</li><li><strong>Client Streaming RPC</strong>: 客户端发送一个数据流，服务端在接收完所有消息后返回一个响应。</li><li><strong>Bidirectional Streaming RPC</strong>: 客户端和服务端都可以独立地、异步地向对方发送数据流，可以实现全双工通信。</li></ul></li></ol><p><strong>优势</strong>:</p><ul><li><strong>高性能</strong>: HTTP/2 + Protobuf的组合带来了极低的延迟和高吞吐量。</li><li><strong>跨语言</strong>: 支持主流的编程语言，非常适合构建多语言环境下的微服务系统。</li><li><strong>服务定义清晰</strong>: <code>.proto</code>文件即是服务契约，是唯一的、权威的接口文档。</li><li><strong>功能强大</strong>: 支持流式通信、认证、负载均衡、超时、取消等高级功能。</li></ul><p><strong>适用场景</strong>:</p><ul><li><strong>微服务间的内部通信</strong>: 这是gRPC最主要的应用场景，尤其是在对性能要求高的系统中。</li><li><strong>移动客户端与后端通信</strong>: Protobuf的轻量和HTTP/2的高效非常适合移动网络环境。</li><li><strong>需要流式数据传输的场景</strong>: 如物联网数据上报、实时消息推送等。</li></ul><p>与RESTful API的对比:</p><table><thead><tr><th>特性</th><th>gRPC</th><th>RESTful API</th></tr></thead><tbody><tr><td>协议</td><td>HTTP/2</td><td>通常是 HTTP/1.1 (也可用 HTTP/2)</td></tr><tr><td>数据格式</td><td>Protobuf (二进制)</td><td>JSON (文本)</td></tr><tr><td>契约定义</td><td>.proto 文件 (强类型)</td><td>OpenAPI/Swagger (可选, 弱约束)</td></tr><tr><td>性能</td><td>高</td><td>相对较低</td></tr><tr><td>浏览器支持</td><td>需要代理 (gRPC-Web)</td><td>原生支持</td></tr><tr><td>易用性</td><td>学习曲线稍陡</td><td>简单直观</td></tr></tbody></table><h3 id="_12-了解过ddd吗" tabindex="-1"><a class="header-anchor" href="#_12-了解过ddd吗"><span>12. 了解过DDD吗?</span></a></h3><p>是的，DDD（Domain-Driven Design，领域驱动设计）是一种软件开发方法论，旨在通过将实现连接到不断发展的模型来应对复杂的需求。</p><p>核心思想:</p><p>DDD的核心思想是，在软件开发过程中，我们应该将主要的焦点放在业务领域（Domain）本身，而不是技术实现。我们应该与领域专家（Domain Expert）紧密合作，建立一个能够准确反映业务领域知识和流程的通用语言（Ubiquitous Language）和领域模型（Domain Model），并用这个模型来指导整个软件的设计和实现。</p><p><strong>关键概念</strong>:</p><p><strong>战略设计 (Strategic Design)</strong>: 关注于宏观层面，如何划分和组织复杂的业务领域。</p><ul><li><strong>领域 (Domain)</strong>: 业务问题发生的范围。</li><li><strong>子域 (Subdomain)</strong>: 将复杂的领域划分为更小的、可管理的部分。</li><li><strong>核心域 (Core Domain)</strong>: 业务最核心、最具竞争力的部分，需要投入最好的资源。</li><li><strong>支撑子域 (Supporting Subdomain)</strong>: 非核心，但为核心域提供支撑的业务部分。</li><li><strong>通用子域 (Generic Subdomain)</strong>: 非核心，且业界有成熟解决方案的部分（如权限、认证），通常可以直接使用或购买。</li><li><strong>通用语言 (Ubiquitous Language)</strong>: 在项目团队（开发、产品、测试、领域专家）中形成的一套共享的、无歧义的术语、概念和词汇表，用于描述领域模型。代码中的类名、方法名、变量名都应该直接使用通用语言。</li><li><strong>限界上下文 (Bounded Context)</strong>: 一个逻辑边界，通用语言和领域模型在这个边界内具有明确的、唯一的含义。每个限界上下文都对应一个微服务或一个独立的模块。</li><li><strong>上下文映射图 (Context Map)</strong>: 描述不同限界上下文之间的关系，如合作（Partnership）、共享内核（Shared Kernel）、客户-供应商（Customer-Supplier）、防腐层（Anti-Corruption Layer）等。</li></ul><p><strong>战术设计 (Tactical Design)</strong>: 关注于微观层面，如何在限界上下文内部设计出高质量的领域模型。</p><ul><li><strong>实体 (Entity)</strong>: 具有唯一标识（ID）并且其生命周期和状态是连续变化的领域对象。例如，一个“用户”或一张“订单”。</li><li><strong>值对象 (Value Object)</strong>: 没有唯一标识，通过其属性值来描述事物，通常是不可变的（Immutable）。例如，“地址”（由省、市、区组成）或“金额”（由数值和币种组成）。</li><li><strong>聚合 (Aggregate)</strong>: 一组相关领域对象的集群，作为数据修改和持久化的基本单元。 <ul><li><strong>聚合根 (Aggregate Root)</strong>: 是聚合的入口，是聚合中唯一一个可以被外部直接引用的实体。所有对聚合内部的修改都必须通过聚合根来完成，以保证业务规则的一致性。</li></ul></li><li><strong>工厂 (Factory)</strong>: 负责封装创建复杂对象（特别是聚合）的逻辑。</li><li><strong>仓库 (Repository)</strong>: 负责封装对象的持久化和查询逻辑，提供一个类似集合的接口来访问聚合根，隔离领域层和基础设施层。</li><li><strong>领域服务 (Domain Service)</strong>: 当某个操作不适合放在任何一个实体或值对象中时（例如，它需要协调多个聚合），可以将其封装在领域服务中。</li><li><strong>领域事件 (Domain Event)</strong>: 用于表示在领域中发生过的重要事情。例如，“订单已支付”、“用户已注册”。领域事件是实现最终一致性和系统解耦的关键。</li></ul><p><strong>DDD的价值</strong>:</p><ul><li>帮助团队应对复杂的业务场景。</li><li>建立清晰、一致的业务模型和代码实现。</li><li>促进开发人员与业务专家的有效沟通。</li><li>构建出灵活、可维护、易于演进的软件系统，特别适合微服务架构。</li></ul><h3 id="_13-了解过向量数据库吗" tabindex="-1"><a class="header-anchor" href="#_13-了解过向量数据库吗"><span>13. 了解过向量数据库吗?</span></a></h3><p>是的，向量数据库（Vector Database）是近年来随着AI和机器学习的兴起而变得非常流行的一种新型数据库。</p><p>核心功能:</p><p>专门用于存储、管理和查询高维向量数据的数据库。</p><p>背景:</p><p>在AI领域，文本、图片、音频、视频等非结构化数据，通常可以通过嵌入（Embedding）模型（如Word2Vec, BERT, CLIP等）转换成高维的数学向量（Vector）。这些向量能够捕捉到原始数据的语义信息。</p><ul><li><strong>语义相似性</strong>: 在向量空间中，两个向量的<strong>距离</strong>（如欧氏距离、余弦相似度）越近，代表它们对应的原始数据在语义上就越相似。</li></ul><p>传统数据库的困境:</p><p>传统的关系型数据库或NoSQL数据库不擅长处理这种高维向量的相似性搜索。如果要在上百万甚至上亿的向量中找到与给定向量最相似的Top-K个向量，使用传统数据库进行暴力计算，其复杂度和耗时是无法接受的。</p><p>向量数据库的解决方案:</p><p>向量数据库的核心技术是 <strong>近似最近邻搜索（Approximate Nearest Neighbor, ANN）</strong> 算法。</p><ul><li><strong>ANN算法</strong>: 它不追求100%精确地找到最近邻，而是在可接受的精度损失下，以极高的效率和速度找到与查询向量高度相似的结果。</li><li><strong>索引结构</strong>: ANN算法通过构建特殊的索引结构（如HNSW, IVF, LSH, Faiss等）来实现快速检索。这些索引将高维向量组织在特定的数据结构中，使得搜索时可以快速剪枝，避免全局扫描。</li></ul><p><strong>主要功能和特点</strong>:</p><ol><li><strong>高效的相似性搜索 (ANN Search)</strong>: 这是最核心的功能。</li><li><strong>海量向量存储</strong>: 能够管理数十亿甚至更多的向量数据。</li><li><strong>支持元数据 (Metadata) 存储和过滤</strong>: 可以在存储向量的同时，为其附加一些标量字段（如ID、类别、时间戳等）。查询时可以先通过元数据进行过滤（例如，只在“类别A”的商品中搜索），然后再进行向量相似性搜索。</li><li><strong>易用的API</strong>: 提供友好的SDK和API，方便开发者进行数据插入和查询。</li><li><strong>高可用和可扩展</strong>: 通常被设计为分布式系统，支持水平扩展和高可用。</li></ol><p><strong>应用场景</strong>:</p><ul><li><strong>以图搜图/视频搜索</strong>: 输入一张图片，找到相似的图片。</li><li><strong>语义文本搜索/智能问答</strong>: 输入一个问题，在海量文档中找到语义最相关的答案。这是大型语言模型（LLM）应用中RAG（Retrieval-Augmented Generation）架构的核心组件。</li><li><strong>推荐系统</strong>: 根据用户的行为向量，推荐相似的商品或内容。</li><li><strong>异常检测</strong>: 在向量空间中，离群的向量点可能代表异常数据。</li><li><strong>药物发现/分子匹配</strong>: 在化学领域，分子结构可以被表示为向量，用于寻找相似的分子。</li></ul><p><strong>主流的向量数据库产品</strong>:</p><ul><li><strong>开源</strong>: Milvus, Weaviate, Qdrant, Chroma</li><li><strong>云服务/商业版</strong>: Pinecone, Zilliz Cloud (Milvus的商业版), Redis (通过RediSearch模块), Elasticsearch (通过k-NN插件) 等也提供了向量搜索能力。</li></ul></blockquote><h2 id="欧斯特智能-二面" tabindex="-1"><a class="header-anchor" href="#欧斯特智能-二面"><span>欧斯特智能(二面)</span></a></h2><p><strong>2025.09.03</strong></p><ul><li>介绍一下你的网关项目</li><li>你的网关项目相比SpringCloud Gateway有什么优势?</li><li>介绍一下grpc</li><li>介绍一下你定义的后置处理器是怎么工作的</li><li>写一个批量插入的代码示例</li><li>Stream和for循环有什么区别?</li><li>Springboot2和3分别怎么实现自动装配的?</li><li>说一下ConditionOn注解</li><li>怎么实现一个bean在另一个bean之后加载呢?</li><li>yaml配置文件的两种读取方法</li><li>循环依赖怎么解决?</li><li>说一下AOP和它的几个概念</li><li>说一下Rocketmq的四种通知方式(广播路由什么的)</li><li>一些前端问题</li></ul><blockquote><h3 id="_1-介绍一下你的网关项目" tabindex="-1"><a class="header-anchor" href="#_1-介绍一下你的网关项目"><span>1. 介绍一下你的网关项目</span></a></h3><p>我的网关项目是一个基于 Netty 和 Spring Boot 构建的微服务网关，其核心设计思想是 <strong>责任链模式</strong> 和 <strong>分布式服务治理</strong> 。</p><p><strong>核心功能模块包括：</strong></p><ul><li><strong>网关核心模块 (<code>api-gateway-core</code>)</strong>: 作为请求处理的核心入口，基于 Netty 实现，通过责任链模式 对请求进行处理。处理链包括： <ul><li><strong>鉴权处理器 (<code>AuthorizationHandler</code>)</strong>: 基于 JWT 对请求进行鉴权。</li><li><strong>自定义处理器 (<code>PreExecutorHandler</code>, <code>PostExecutorHandler</code>)</strong>: 支持灵活的自定义熔断、限流、日志等操作。</li><li><strong>请求调用处理器 (<code>ExecutorHandler</code>)</strong>: 解析请求类型并发送请求（支持 HTTP 和 Dubbo RPC）。</li><li><strong>结果包装处理器 (<code>ResultHandler</code>)</strong>: 对返回结果进行统一的包装。</li></ul></li><li><strong>网关中心模块 (<code>api-gateway-center</code>)</strong>: <ul><li><strong>配置管理</strong>: 动态加载并刷新 Redis 和 Nginx 配置，支持负载均衡策略更新。</li><li><strong>服务注册与发现</strong>: 服务提供者通过 SDK 注册服务信息，Redis 存储服务元数据，并定时同步数据库信息到 Redis。</li><li><strong>心跳与续约</strong>: 服务启动时主动注册，后续定期发送心跳续约。</li></ul></li><li><strong>SDK 模块</strong>: <ul><li><strong>服务注册 SDK (<code>server-find-sdk</code>)</strong>: 自动加载配置，扫描自定义注解并上传接口信息。</li><li><strong>请求调用 SDK (<code>server-send-sdk</code>)</strong>: 提供便捷的请求调用方式，支持失败重试。</li></ul></li></ul><h3 id="_2-你的网关项目相比-springcloud-gateway-有什么优势" tabindex="-1"><a class="header-anchor" href="#_2-你的网关项目相比-springcloud-gateway-有什么优势"><span><strong>2. 你的网关项目相比 SpringCloud Gateway 有什么优势?</strong></span></a></h3><p>我的网关项目在设计上借鉴了 Spring Cloud Gateway 的思想，但在某些方面提供了更轻量级和更具定制化的解决方案：</p><ul><li><strong>高性能网络核心</strong>：直接使用 Netty 作为网络框架，提供了更底层的控制能力和更高的性能潜力。</li><li><strong>高度可扩展的责任链模式</strong>：通过自定义的前置和后置处理器，可以非常灵活地实现鉴权、限流、熔断、日志等功能，并且可以自由排序。</li><li><strong>双协议支持</strong>：原生支持 HTTP 和 Dubbo 两种协议的泛化调用，可以更好地适应异构系统。</li><li><strong>动态配置和服务发现</strong>：通过网关中心和 Redis 实现动态配置和服务发现，可以实时更新路由规则和负载均衡策略。</li><li><strong>轻量级</strong>：相比于 Spring Cloud Gateway，我的项目更加轻量级，核心模块的依赖更少，更易于理解和维护。</li></ul><h3 id="_3-介绍一下-grpc" tabindex="-1"><a class="header-anchor" href="#_3-介绍一下-grpc"><span><strong>3. 介绍一下 gRPC</strong></span></a></h3><p>gRPC (Google Remote Procedure Call) 是一个由 Google 开发的高性能、开源的通用 RPC (Remote Procedure Call) 框架。它可以在任何环境下运行，并且可以用任何语言编写。</p><p><strong>主要特点:</strong></p><ul><li><strong>基于 HTTP/2</strong>: gRPC 使用 HTTP/2 作为其传输协议，这带来了多路复用、头部压缩、服务器推送等特性，从而实现了更低的延迟和更高的吞吐量。</li><li><strong>协议缓冲区 (Protocol Buffers)</strong>: gRPC 默认使用 Protocol Buffers 作为其接口定义语言 (IDL) 和消息交换格式。Protocol Buffers 是一种轻量级、高效的二进制序列化格式，比 JSON 或 XML 更快、更小。</li><li><strong>多语言支持</strong>: gRPC 支持多种编程语言，包括 Java, C++, Python, Go, Ruby, C#, Node.js, Android Java, Objective-C 和 PHP。</li><li><strong>流式处理</strong>: gRPC 支持四种类型的流式处理： <ul><li>一元 RPC: 客户端发送一个请求，服务器返回一个响应。</li><li>服务器流式 RPC: 客户端发送一个请求，服务器返回一个流式的响应。</li><li>客户端流式 RPC: 客户端发送一个流式的请求，服务器返回一个响应。</li><li>双向流式 RPC: 客户端和服务器都可以发送一个流式的请求和响应。</li></ul></li></ul><h3 id="_4-介绍一下你定义的后置处理器是怎么工作的" tabindex="-1"><a class="header-anchor" href="#_4-介绍一下你定义的后置处理器是怎么工作的"><span><strong>4. 介绍一下你定义的后置处理器是怎么工作的</strong></span></a></h3><p>我定义的后置处理器是通过 <code>CustomPostHandler</code> 接口和 <code>PostExecutorHandler</code> 类实现的。</p><ul><li><strong><code>CustomPostHandler</code> 接口</strong>: 这是一个自定义的后置处理器接口，所有自定义的后置处理器都需要实现这个接口，并实现 <code>handle</code> 方法和 <code>getOrder</code> 方法。</li><li><strong><code>PostExecutorHandler</code> 类</strong>: 这个类是后置处理器的执行器，它会收集所有实现了 <code>CustomPostHandler</code> 接口的 Bean，并根据 <code>getOrder</code> 方法返回的顺序进行排序。然后，它会依次执行这些后置处理器的 <code>handle</code> 方法。如果某个处理器返回了一个非 <code>null</code> 的 <code>Result</code> 对象，那么处理链就会被终止，并且该 <code>Result</code> 对象会被直接返回给客户端。</li></ul><h3 id="_5-写一个批量插入的代码示例" tabindex="-1"><a class="header-anchor" href="#_5-写一个批量插入的代码示例"><span><strong>5. 写一个批量插入的代码示例</strong></span></a></h3><p>这是一个使用 MyBatis-Plus 进行批量插入的示例，在你的项目中已经引入了 MyBatis-Plus 依赖。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Service</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BatchInsertService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Resource</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> YourMapper</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> yourMapper</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Transactional</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> batchInsert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">YourEntity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">entityList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 每次批量插入的数量</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> batchSize</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> entityList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> batchSize) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> toIndex</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> batchSize, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">entityList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            yourMapper</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">insertBatchSomeColumn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">entityList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">subList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i, toIndex));</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在 YourMapper.java (或者相应的 XML 文件) 中定义 insertBatchSomeColumn 方法</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> YourMapper</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BaseMapper</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">YourEntity</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Integer</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> insertBatchSomeColumn</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">YourEntity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">entityList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 在 YourMapper.xml 文件中</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">insert id</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;insertBatchSomeColumn&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    INSERT</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> INTO</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> your_table</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (column1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> column2) </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">VALUES</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">    &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">foreach collection</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;list&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> item</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;item&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> separator</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;,&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        (#{</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">item</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">field1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> #{</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">item</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">field2</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">})</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">    &lt;/</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">foreach</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;/</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">insert</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-stream-和-for-循环有什么区别" tabindex="-1"><a class="header-anchor" href="#_6-stream-和-for-循环有什么区别"><span><strong>6. Stream 和 for 循环有什么区别?</strong></span></a></h3><p>Stream 和 for 循环都是用来遍历集合的，但它们之间存在一些重要的区别：</p><ul><li><strong>声明性 vs. 命令性</strong>: Stream 是声明性的，你只需要描述你想要做什么，而不需要关心如何做。而 for 循环是命令性的，你需要明确地指定每一步的操作。</li><li><strong>内部迭代 vs. 外部迭代</strong>: Stream 使用内部迭代，它会自动地为你处理迭代的过程。而 for 循环使用外部迭代，你需要手动地控制迭代的过程。</li><li><strong>链式操作</strong>: Stream 支持链式操作，你可以将多个操作连接在一起，形成一个流水线。这使得代码更加简洁、易读。</li><li><strong>并行处理</strong>: Stream 可以很容易地进行并行处理，只需要调用 <code>parallel()</code> 方法即可。这可以充分利用多核处理器的优势，提高处理效率。</li><li><strong>无状态</strong>: Stream 的操作通常是无状态的，它们不会修改原始的集合。这使得代码更加安全、易于调试。</li></ul><h3 id="_7-springboot-2-和-3-分别怎么实现自动装配的" tabindex="-1"><a class="header-anchor" href="#_7-springboot-2-和-3-分别怎么实现自动装配的"><span><strong>7. Springboot 2 和 3 分别怎么实现自动装配的?</strong></span></a></h3><ul><li><strong>Spring Boot 2</strong>: <ul><li>主要通过 <code>META-INF/spring.factories</code> 文件来实现自动装配。</li><li>在这个文件中，通过 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> key 来指定需要自动装配的配置类。</li><li>Spring Boot 在启动时会扫描所有 <code>spring.factories</code> 文件，并加载其中指定的配置类。</li></ul></li><li><strong>Spring Boot 3</strong>: <ul><li>从 Spring Boot 2.7 开始，推荐使用新的自动装配方式，并在 Spring Boot 3.0 中成为默认方式。</li><li>新的方式是，在 <code>META-INF/spring/</code> 目录下创建一个名为 <code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 的文件。</li><li>在这个文件中，每一行列出一个自动配置类的全限定名。</li><li>这种方式比 <code>spring.factories</code> 更高效，因为 Spring Boot 可以直接读取这个文件，而不需要解析 <code>spring.factories</code> 的格式。</li></ul></li></ul><h3 id="_8-说一下-conditionon-注解" tabindex="-1"><a class="header-anchor" href="#_8-说一下-conditionon-注解"><span><strong>8. 说一下 ConditionOn 注解</strong></span></a></h3><p><code>@ConditionalOn</code> 是 Spring Boot 提供的一系列条件注解，它们可以根据不同的条件来决定是否创建一个 Bean。这使得我们可以更加灵活地配置我们的应用程序。</p><p>一些常用的 <code>@ConditionalOn</code> 注解包括：</p><ul><li><code>@ConditionalOnBean</code>: 当容器中存在指定的 Bean 时，才会创建当前的 Bean。</li><li><code>@ConditionalOnClass</code>: 当类路径下存在指定的类时，才会创建当前的 Bean。</li><li><code>@ConditionalOnExpression</code>: 当指定的 SpEL 表达式返回 <code>true</code> 时，才会创建当前的 Bean。</li><li><code>@ConditionalOnMissingBean</code>: 当容器中不存在指定的 Bean 时，才会创建当前的 Bean。</li><li><code>@ConditionalOnProperty</code>: 当指定的属性存在并且具有指定的值时，才会创建当前的 Bean。</li><li><code>@ConditionalOnResource</code>: 当类路径下存在指定的资源时，才会创建当前的 Bean。</li></ul><h3 id="_9-怎么实现一个-bean-在另一个-bean-之后加载呢" tabindex="-1"><a class="header-anchor" href="#_9-怎么实现一个-bean-在另一个-bean-之后加载呢"><span><strong>9. 怎么实现一个 bean 在另一个 bean 之后加载呢?</strong></span></a></h3><p>在 Spring 中，我们可以使用 <code>@DependsOn</code> 注解来指定一个 Bean 的加载顺序。</p><p>Java</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>@Component</span></span>
<span class="line"><span>public class BeanA {</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@Component</span></span>
<span class="line"><span>@DependsOn(&quot;beanA&quot;)</span></span>
<span class="line"><span>public class BeanB {</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>BeanB</code> 会在 <code>BeanA</code> 加载之后再加载。</p><h3 id="_10-yaml-配置文件的两种读取方法" tabindex="-1"><a class="header-anchor" href="#_10-yaml-配置文件的两种读取方法"><span><strong>10. yaml 配置文件的两种读取方法</strong></span></a></h3><p>在 Spring Boot 中，我们可以使用 <code>@ConfigurationProperties</code> 和 <code>@Value</code> 注解来读取 <code>application.yml</code> 配置文件中的属性。</p><ul><li><strong><code>@ConfigurationProperties</code></strong>: <ul><li>这个注解可以将配置文件中的一组属性映射到一个 Java 对象中。</li><li>它支持类型安全的配置，并且可以很好地与 JSR-303 验证注解配合使用。</li><li>在你的项目中，<code>GlobalConfiguration.java</code> 就是一个很好的例子。</li></ul></li><li><strong><code>@Value</code></strong>: <ul><li>这个注解可以用来读取单个的配置属性。</li><li>它支持 SpEL 表达式，可以进行更加灵活的配置。</li></ul></li></ul><h3 id="_11-循环依赖怎么解决" tabindex="-1"><a class="header-anchor" href="#_11-循环依赖怎么解决"><span><strong>11. 循环依赖怎么解决?</strong></span></a></h3><p>在 Spring 中，循环依赖是指两个或多个 Bean 相互依赖，形成一个闭环。Spring 默认可以解决 singleton-scoped bean 之间的循环依赖，但是对于 prototype-scoped bean 和构造函数注入的循环依赖，Spring 是无法解决的。</p><p><strong>解决方法:</strong></p><ul><li><strong>使用 <code>@Lazy</code> 注解</strong>: <code>@Lazy</code> 注解可以延迟一个 Bean 的初始化，直到它第一次被使用。这可以打破循环依赖。</li><li><strong>使用 <code>setter</code> 注入</strong>: 将构造函数注入改为 <code>setter</code> 注入。</li><li><strong>使用 <code>@PostConstruct</code> 注解</strong>: 可以在一个 Bean 的构造函数执行完毕之后，再进行一些初始化操作。</li><li><strong>重构代码</strong>: 重新设计你的代码，避免循环依赖的出现。</li></ul><h3 id="_12-说一下-aop-和它的几个概念" tabindex="-1"><a class="header-anchor" href="#_12-说一下-aop-和它的几个概念"><span><strong>12. 说一下 AOP 和它的几个概念</strong></span></a></h3><p>AOP (Aspect-Oriented Programming) 即面向切面编程，是一种编程范式，它允许我们通过分离横切关注点来增加程序的模块化。</p><p><strong>核心概念:</strong></p><ul><li><strong>切面 (Aspect)</strong>: 一个关注点的模块化，这个关注点可能会横切多个对象。</li><li><strong>连接点 (Join Point)</strong>: 程序执行过程中的一个点，例如一个方法的执行或者一个异常的处理。</li><li><strong>通知 (Advice)</strong>: 在切面的某个特定的连接点上执行的动作。</li><li><strong>切点 (Pointcut)</strong>: 匹配连接点的断言。</li><li><strong>引入 (Introduction)</strong>: 在不修改类代码的前提下，为类添加新的方法和属性。</li><li><strong>目标对象 (Target Object)</strong>: 被一个或者多个切面所通知的对象。</li><li><strong>AOP 代理 (AOP Proxy)</strong>: AOP 框架创建的对象，用来实现切面契约。</li><li><strong>织入 (Weaving)</strong>: 把切面连接到其他的应用程序类型或者对象上，来创建一个被通知的对象。</li></ul><h3 id="_13-说一下-rocketmq-的四种通知方式" tabindex="-1"><a class="header-anchor" href="#_13-说一下-rocketmq-的四种通知方式"><span><strong>13. 说一下 RocketMQ 的四种通知方式</strong></span></a></h3><p>RocketMQ 提供了四种发送消息的方式：</p><ul><li><strong>同步发送 (Sync)</strong>: 客户端发送一条消息，然后等待服务器的响应。</li><li><strong>异步发送 (Async)</strong>: 客户端发送一条消息，然后立即返回，不等待服务器的响应。当服务器处理完消息之后，会通过回调函数来通知客户端。</li><li><strong>单向发送 (Oneway)</strong>: 客户端发送一条消息，然后立即返回，不等待服务器的响应，也没有回调函数。</li><li><strong>顺序消息 (Ordered Message)</strong>: RocketMQ 可以保证消息按照发送的顺序被消费。</li></ul></blockquote><h2 id="智农天地-北京" tabindex="-1"><a class="header-anchor" href="#智农天地-北京"><span>智农天地(北京)</span></a></h2><p><strong>2025.09.04</strong></p><ul><li>做一个自我介绍</li><li>线程和进程有什么区别</li><li>说一下你编写代码中异步的体现</li><li>前端你有什么了解?</li><li>介绍一下你简历中这个票务平台的ai这一块内容</li><li>你对大模型还有什么其他应用吗?</li><li>说一下git的常用命令</li><li>linux的常用命令有什么</li><li>介绍一下向量数据库</li><li>如果实习的话学校这边OK吗?</li></ul><h2 id="智农天地-二面" tabindex="-1"><a class="header-anchor" href="#智农天地-二面"><span>智农天地(二面)</span></a></h2><p><strong>2025.09.04</strong></p><ul><li>做一个自我介绍</li><li>说一下你项目中ai是怎么用的</li><li>可以实习多久?</li><li>有没有什么实习要求?(你问我干嘛?)</li><li>工资给你开多少吧?(黑人问号)</li><li>多久可以有明确的答复?</li></ul><h2 id="美团-北京" tabindex="-1"><a class="header-anchor" href="#美团-北京"><span>美团(北京)</span></a></h2><p><strong>2025.09.05</strong></p><ul><li>介绍一下你的网关项目和核心组件</li><li>你说这个项目是根据美团的sherperd网关改写的,说一下你做了哪些改动</li><li>你在做这个项目过程中遇到了哪些困难?</li><li>你第二个购票系统有哪些项目亮点?</li><li>介绍一下AOP是什么</li><li>你是怎么保证热点数据的一致性的?(缓存一致性问题)</li><li>你是怎么做到分库分表?为什么要分库分表?</li><li>介绍一下你的AI项目和它的核心功能</li><li>说一说什么是MCP,你是怎么用的?</li><li>对于AI你还了解了其他的一些概念吗?(我说的向量数据库)</li><li>你是哪个高中的?(当时问的我一脸懵,后来才知道面试官也是长治人,太巧了哈哈哈哈)</li></ul><blockquote><p>手撕: 反转链表(写代码+说思路+另一种解法)</p><p>反问: 我们平常的工作是大概是什么？</p><p>​ 我们平常的工作中可以接触到核心业务代码吗？</p><p>​ 您介意把这个面试过程放到我的博客上吗?</p></blockquote><h2 id="腾讯-深圳" tabindex="-1"><a class="header-anchor" href="#腾讯-深圳"><span>腾讯(深圳)</span></a></h2><p><strong>2025.09.05</strong></p><ul><li>先做个自我介绍吧</li><li>选一个你认为最能体现你的技术的一个项目</li><li>介绍一下你的这个网关项目(打开屏幕共享进行讲解)</li><li>说一下这些组件是怎么互相作用的,它们的职责是怎么样的?</li><li>深挖项目.....</li><li>你认为你的项目有哪些不足?</li><li>JVM虚拟机和服务是什么样的关系(进程和线程 包含和不包含)</li></ul><blockquote><p>手撕: 在排序数组中查找元素的第一个和最后一个位置</p><p>反问: 如果我加入贵公司,我需要提前学习一下什么呢?</p><p>​ 刚刚你问我的JVM虚拟机那个问题您认为是怎么样的?</p><p>​ 我可以把面试过程放到我的博客上吗?</p></blockquote><h2 id="美团-二面" tabindex="-1"><a class="header-anchor" href="#美团-二面"><span>美团(二面)</span></a></h2><p><strong>2025.09.09</strong></p><ul><li>因为面试官要求对问题保密鼠鼠我就不放问题了</li><li>今天的心情也是很不错 本来以为腾讯的面试挂了 但没想到挺到二面了 鼠鼠的腾讯梦还可以继续下去 这个面试也比较准备的不错</li><li>说些题外话 我也为面试付出了相当多的精力 可能没有大家想的那么轻松 一百多万字的八股反反复复背了好几遍 算法题前前后后也刷了好多遍了 项目实习也准备的比较充分了 打铁还是得自身硬啊 🐉🐉一百面到现在成功率还是百分百 希望可以撑到拿腾讯offer的那一天</li><li>最后说一句🐉人🐉言：人有些时候还是得自己成全自己啊~</li></ul><h2 id="腾讯-二面" tabindex="-1"><a class="header-anchor" href="#腾讯-二面"><span>腾讯(二面)</span></a></h2><p><strong>2025.09.11</strong></p><ul><li><p>做个自我介绍吧。</p></li><li><p>请详细介绍一下你简历上的项目，可以先从第一个网关项目开始。</p></li><li><p>你为什么会想要做这样一个网关项目？</p></li><li><p>介绍一下这个网关的整体架构和核心组件吗？</p></li><li><p>你在设计中提到了“前置处理器”和“后置处理器”，能具体讲讲它的作用和好处吗？</p></li><li><p>服务实例是如何将自己的信息注册到网关中心的？需要接入的服务做很多代码改造吗？</p></li><li><p>你提到了“接口上报”和“心跳续约”，这两者怎么做的？</p></li><li><p>当一个服务有多个实例时，网关是如何进行负载均衡的？你实现了哪些策略？</p></li><li><p>了解过一致性哈希吗?</p></li><li><p>如果某个服务实例或网关核心节点宕机了，系统会如何处理以保证高可用性？</p></li><li><p>你提到服务组和网关核心组是一对一绑定的，这种设计出于什么考虑？如何实现服务间的资源隔离？</p></li><li><p>网关的限流功能是如何实现的？</p></li><li><p>在网关集群部署的情况下，如何实现一个全局统一的分布式限流，而不是各个节点单机限流？</p></li><li><p>每次请求都访问Redis判断限流会有效率问题，有什么优化思路吗？</p></li><li><p>限流的阈值是固定的还是可以动态调整的？如果要动态调整，你会如何设计实现？</p></li><li><p>了解令牌桶、漏桶等常见的限流算法吗？它们是如何工作的？</p></li><li><p>你对这个网关项目做过性能测试吗？结果如何，比如QPS和延迟？</p></li><li><p>你提到网关带来了额外的3毫秒延迟，你分析过这部分延迟主要耗时在哪里吗？这个结果符合你的预期吗？</p></li><li><p>你的网关和服务之间有远程调用，能谈谈你对RPC的理解吗？它是如何工作的？</p></li><li><p>你项目中用到了Redis，能讲讲为什么Redis的性能这么高吗？</p></li><li><p>你提到了I/O多路复用，可以具体解释一下它的原理吗？你知道select、poll和epoll的区别吗？</p></li><li><p>HTTP和TCP协议有什么区别和联系？</p></li><li><p>能否详细描述一下TCP的三次握手和四次挥手过程？</p></li><li><p>为什么TCP挥手需要四次，而不是三次？</p></li><li><p>了解TCP的滑动窗口机制吗？</p></li><li><p>接下来聊聊你的第二个项目，那个结合了Spring AI的购票系统，介绍一下你主要做了什么？</p></li><li><p>在这个项目中，AI主要应用在哪些方面？</p></li><li><p>你提到了Function Calling，能解释一下它是什么，以及它是如何工作的吗？</p></li></ul><blockquote><p>手撕忘了</p><p>反问: 要提前学什么?</p><p>​ 组内业务</p></blockquote><h2 id="字节-北京" tabindex="-1"><a class="header-anchor" href="#字节-北京"><span>字节(北京)</span></a></h2><p><strong>2025.09.12</strong></p><ul><li>请介绍一下你的网关项目是做什么的。</li><li>这个网关项目主要解决了什么问题？</li><li>服务之间使用的是什么通信协议 (HTTP, RPC)？</li><li>HTTP 和 Dubbo 这两种协议有什么区别？</li><li>你提到 Dubbo 的二进制传输效率高，但 HTTP 底层也是 TCP，也是二进制，为什么效率有差异？</li><li>Dubbo 默认使用什么序列化方式？</li></ul><ul><li><p>如果下游服务有多个实例，请求如何路由？</p></li><li><p>你知道哪些常见的负载均衡算法？</p></li><li><p>如何在代码中实现轮询（Round Robin）算法？</p></li><li><p>如何实现加权轮询（Weighted Round Robin）算法？</p></li><li><p>你是如何实现请求限流的？</p></li><li><p>限流逻辑是放在哪里实现的 (例如 Nginx, 服务实例)？</p></li><li><p>如果实例是动态扩缩容的，如何实现一个全局的总限流 (例如，所有实例加起来总共 100 QPS)？</p></li><li><p>可以用什么中间件来实现全局限流？</p></li><li><p>如果用 Redis，应该如何实现？具体的数据结构、Key 和 Value 是什么？</p></li><li><p>多实例并发访问 Redis 进行限流，如何处理并发问题？</p></li><li><p>网关的元数据信息（如服务地址）是存储在哪里的？</p></li><li><p>了解 Redis 的高可用实现方案吗？</p></li><li><p>在主从模式下，如果 Master 节点挂了，会发生什么？</p></li><li><p>Sentinel (哨兵) 是如何从多个 Slave 节点中选举出新的 Master 的？选举的逻辑是怎样的？</p></li><li><p>了解 Raft 协议吗？</p></li><li><p>进程和线程有什么区别？</p></li><li><p>进程分配的“资源”具体指什么？</p></li><li><p>在单核 CPU 的情况下，使用多线程能提高效率吗？为什么？</p></li><li><p>为什么 Tomcat 默认会开 200 个线程，它不怕线程切换的开销吗？</p></li><li><p>为什么 Redis 是单线程的，但性能却非常高？</p></li><li><p>为什么处理 I/O 任务时，使用多线程更合适？</p></li><li><p>你认为一个服务的线程数应该设置成多少比较合适？</p></li><li><p>为什么要使用线程池？</p></li><li><p>当一个新任务提交给线程池后，它的内部执行流程是怎样的 (核心线程、队列、最大线程、拒绝策略)？</p></li><li><p>如果服务器只有 2G 物理内存，一个程序需要申请超过 2G 的内存，它还能运行吗？为什么我们平时在电脑上开很多软件，把内存占满了，软件也不会立刻全部崩溃？</p></li><li><p>TCP 协议的“可靠”体现在哪些方面？</p></li><li><p>发送方 A 如何知道接收方 B 没有收到某个数据包？</p></li><li><p>A 和 B 通信时，B 所在的服务器整个宕机了，A 这边会有什么现象？</p></li><li><p>B 服务器没宕机，只是 B 的应用程序进程崩溃了，这时 A 持续发数据给 B，会发生什么？</p></li><li><p>InnoDB 存储引擎使用什么数据结构做索引？</p></li><li><p>请描述一下 B+ 树的结构。</p></li><li><p>B+ 树和 B 树有什么区别？</p></li><li><p>为什么 MySQL 选择 B+ 树而不是 B 树？</p></li><li><p>为什么 B+ 树的叶子节点用链表串联起来，就能提升 I/O 性能？</p></li><li><p>为什么不使用平衡二叉树（如 AVL 树）这类结构做索引？<code>O(log n)</code> 的复杂度不是已经很快了吗？</p></li><li><p>一张有 200 万条数据的表，它的 B+ 树索引大概有多高？这个层数是怎么计算出来的？</p></li></ul><blockquote><p>手撕: 给定一个整数数组 <code>nums</code> 和一个整数 <code>k</code>，找到该数组中和为 <code>k</code> 的连续子数组的个数。</p><p>反问:</p><p>​ 团队主要的技术栈是什么？</p><p>​ 工作地点在哪里？</p><p>​ 团队负责的业务是什么？</p></blockquote><blockquote><h3 id="一、项目经验-网关" tabindex="-1"><a class="header-anchor" href="#一、项目经验-网关"><span>一、项目经验 (网关)</span></a></h3><ol><li><strong>核心问题</strong>: 网关主要解决<strong>服务治理</strong>的问题，它作为所有后端服务的统一入口，提供以下核心能力： <ul><li><strong>统一鉴权</strong>: 对所有请求进行统一的身份认证和权限校验。</li><li><strong>动态路由</strong>: 根据请求的路径、参数等信息，动态地转发到下游正确的服务实例。</li><li><strong>流量控制</strong>: 实现限流、熔断、降级，保护后端服务。</li><li><strong>协议转换</strong>: 可以将外部的 HTTP 协议转换成内部的 RPC 协议。</li><li><strong>日志监控</strong>: 集中记录所有请求的日志，便于监控和问题排查。</li></ul></li><li><strong>协议对比</strong>: <ul><li><strong>HTTP</strong>: 应用层协议，基于“请求-响应”模式，通常传输文本（JSON/XML），通用性好，常用于对外暴露的 API。</li><li><strong>Dubbo (RPC)</strong>: 远程过程调用框架，通常工作在传输层之上。它允许像调用本地方法一样调用远程服务。默认使用二进制协议（Hessian2）进行序列化，传输效率更高，更适合内部服务之间的高性能通信。</li></ul></li><li><strong>负载均衡</strong>: <ul><li><strong>常见算法</strong>: 随机、轮询、加权轮询、最少活跃连接数、一致性哈希等。</li><li><strong>轮询实现</strong>: 可以使用一个原子类 <code>AtomicInteger</code> 作为计数器，每次请求对总服务数取模 <code>counter.getAndIncrement() % serverCount</code> 来获取下一个服务的索引。</li><li><strong>加权轮询实现</strong>: 可以创建一个包含所有服务实例的列表，其中权重越高的服务在列表中出现的次数越多，然后对这个列表进行简单的轮询。或者，可以计算权重的最大公约数，按权重比例进行调度。</li></ul></li><li><strong>服务限流</strong>: <ul><li><strong>全局限流</strong>: 必须依赖一个<strong>中心化的存储</strong>来实现，比如 Redis 或专门的限流中间件。</li><li><strong>Redis 实现</strong>: <ul><li><strong>计数器</strong>: 使用 <code>INCR</code> 命令。当一个请求到来时，对一个全局的 Key (如 <code>global_rate_limit</code>) 执行 <code>INCR</code>。如果是第一次 <code>INCR</code>，则使用 <code>EXPIRE</code> 设置一个 1 秒的过期时间。每次请求都检查这个 Key 的值是否超过阈值。这种方式在时间窗口的边界处有精度问题。</li><li><strong>滑动窗口</strong>: 使用 Redis 的 <code>ZSET</code> (有序集合)。将每次请求的时间戳作为 score，请求的唯一标识 (如 UUID) 作为 member 存入 <code>ZSET</code>。每次请求时，先移除窗口之前（<code>currentTime - windowSize</code>）的所有记录，然后统计 <code>ZSET</code> 中的元素数量，判断是否超过阈值。</li></ul></li><li><strong>并发问题</strong>: Redis 的命令是<strong>原子性</strong>的，例如 <code>INCR</code>、<code>ZADD</code> 都是原子操作，天然解决了并发问题。对于组合逻辑（如先 <code>INCR</code> 再 <code>EXPIRE</code>），可以使用 <strong>Lua 脚本</strong>来保证多个命令的原子性执行。</li></ul></li></ol><h3 id="二、技术基础" tabindex="-1"><a class="header-anchor" href="#二、技术基础"><span>二、技术基础</span></a></h3><h4 id="_1-redis" tabindex="-1"><a class="header-anchor" href="#_1-redis"><span>1. Redis</span></a></h4><ol><li><strong>高可用</strong>: 主要有三种方案： <ul><li><strong>主从复制 (Master-Slave)</strong>: 数据备份和读写分离。</li><li><strong>哨兵模式 (Sentinel)</strong>: 在主从基础上增加了<strong>自动故障转移</strong>能力。Sentinel 负责监控主节点，当主节点宕机时，会自动从从节点中选举一个新主节点。</li><li><strong>集群模式 (Cluster)</strong>: 通过数据分片 (Sharding) 实现横向扩展，每个分片内部可以再做主从，实现高可用。</li></ul></li><li><strong>哨兵选举</strong>: 当一个 Sentinel 认为主节点下线（主观下线），它会询问其他 Sentinel。当足够多的 Sentinel (超过半数) 都认为主节点下线时，就形成了<strong>客观下线</strong>。然后，活着的 Sentinel 之间会进行一次选举，选出一个领导者。领导者会从从节点中，按照<strong>优先级 &gt; 复制偏移量 &gt; 运行 ID</strong> 的顺序，选出一个最合适的节点作为新主节点。</li></ol><h4 id="_2-操作系统与并发" tabindex="-1"><a class="header-anchor" href="#_2-操作系统与并发"><span>2. 操作系统与并发</span></a></h4><ol><li><strong>进程与线程</strong>: <ul><li><strong>进程</strong>: 操作系统<strong>资源分配</strong>的最小单位。它有自己独立的内存空间。</li><li><strong>线程</strong>: <strong>CPU 调度</strong>的最小单位。它共享所属进程的资源，是实际执行代码的单位。</li></ul></li><li><strong>单核多线程</strong>: 对于 <strong>CPU 密集型</strong>任务，不能提高效率，反而会因为线程上下文切换带来额外开销。对于 <strong>I/O 密集型</strong>任务，可以<strong>显著提高效率</strong>，因为当一个线程在等待 I/O (如读写数据库、文件) 时，CPU 可以切换去执行其他线程，避免了 CPU 空闲。</li><li><strong>Tomcat 线程模型</strong>: Web 应用绝大多数都是 <strong>I/O 密集型</strong>的。一个请求的处理过程中，大部分时间可能都在等待数据库返回结果或调用其他服务。Tomcat 采用多线程模型，是为了在一个线程等待 I/O 时，其他线程能继续处理别的请求，从而提高服务器的<strong>吞吐量</strong>和<strong>并发处理能力</strong>。</li><li><strong>虚拟内存</strong>: 操作系统通过<strong>虚拟内存</strong>技术，将一部分硬盘空间映射为内存来使用（称为交换空间或页面文件）。当物理内存不足时，操作系统会将内存中不常用的数据（页）换出到硬盘上，为新任务腾出空间。这使得程序感觉自己拥有比物理内存更大的连续内存空间。虽然这会导致性能下降（硬盘读写远慢于内存），但能保证系统在内存紧张时依然可以运行，而不是直接崩溃。</li></ol><h4 id="_3-计算机网络-tcp" tabindex="-1"><a class="header-anchor" href="#_3-计算机网络-tcp"><span>3. 计算机网络 (TCP)</span></a></h4><ol><li><strong>可靠性</strong>: 通过以下机制保证： <ul><li><strong>序列号和确认应答 (ACK)</strong>: 对数据包进行编号，接收方收到后发送 ACK 确认，确保数据包有序、不丢失。</li><li><strong>超时重传</strong>: 发送方如果在一定时间内没收到 ACK，会重新发送数据包。</li><li><strong>流量控制</strong>: 使用滑动窗口，控制发送方的发送速率，防止撑爆接收方。</li><li><strong>拥塞控制</strong>: 根据网络状况动态调整发送速率，防止网络拥堵。</li></ul></li><li><strong>网络异常场景</strong>: <ul><li><strong>场景一 (服务器宕机)</strong>: A 发送数据后，收不到 B 的 ACK。A 会触发<strong>超时重传</strong>机制，在多次重试失败后，A 会放弃连接，并通知上层应用“连接超时”。</li><li><strong>场景二 (进程崩溃)</strong>: A 发送数据给 B 的端口。B 的操作系统收到数据包后，发现没有进程在该端口监听。操作系统会立即回复一个 <strong>RST (Reset) 包</strong>。A 收到 RST 包后，会立即中断连接，并通知上层应用“连接被重置”。</li></ul></li></ol><h4 id="_4-数据库-mysql" tabindex="-1"><a class="header-anchor" href="#_4-数据库-mysql"><span>4. 数据库 (MySQL)</span></a></h4><ol><li><strong>索引结构</strong>: InnoDB 使用 <strong>B+ 树</strong>作为索引结构。</li><li><strong>B+ 树 vs B 树</strong>: <ul><li><strong>数据存储</strong>: B+ 树只有<strong>叶子节点</strong>才存储数据（或数据地址），非叶子节点只存储键值和指针。B 树的所有节点都会存储数据。</li><li><strong>查询效率</strong>: B+ 树的非叶子节点不存数据，使得单个节点可以容纳更多的键值，树的<strong>高度更低</strong>，I/O 次数更少。</li><li><strong>范围查询</strong>: B+ 树的叶子节点之间通过<strong>双向链表</strong>连接，非常适合进行范围查询，而 B 树需要进行复杂的中序遍历。</li></ul></li><li><strong>为什么不用二叉树</strong>: 数据库索引存储在磁盘上。磁盘 I/O 是非常耗时的操作。索引查询的性能瓶颈在于 <strong>I/O 次数</strong>。B+ 树的高度非常低（通常 3-4 层就能支撑千万级数据），一次查询只需要 3-4 次 I/O。而二叉树的高度会深得多，导致 I/O 次数急剧增加，性能会非常差。</li></ol><h3 id="三、算法题" tabindex="-1"><a class="header-anchor" href="#三、算法题"><span>三、算法题</span></a></h3><ol><li><strong>题目</strong>: 和为 k 的子数组。</li><li><strong>思路</strong>: 使用<strong>前缀和 + 哈希表</strong>。 <ul><li>定义一个哈希表 <code>map</code>，<code>key</code> 存储前缀和，<code>value</code> 存储该前缀和出现的次数。</li><li>初始化 <code>map.put(0, 1)</code>，表示和为 0 的前缀和出现过 1 次。</li><li>遍历数组，计算当前位置的前缀和 <code>preSum</code>。</li><li>在 <code>map</code> 中查找是否存在 <code>preSum - k</code> 这个键。如果存在，说明找到了一个或多个和为 <code>k</code> 的子数组，将 <code>map.get(preSum - k)</code> 的值累加到结果 <code>count</code> 中。</li><li>将当前的 <code>preSum</code> 存入 <code>map</code> 中，更新其出现次数。</li></ul></li><li><strong>复杂度</strong>: <ul><li><strong>时间复杂度</strong>: O(n)，因为我们只遍历数组一次。</li><li><strong>空间复杂度</strong>: O(n)，在最坏情况下，哈希表需要存储 n 个不同的前缀和。</li></ul></li></ol></blockquote>`,35))])}const k=n(p,[["render",g]]),u=JSON.parse('{"path":"/interviews/","title":"个人面经分享","lang":"zh-CN","frontmatter":{"description":"个人面经分享 我将在这里分享我的面试经历并附加Gemini AI的相关回答,这是我的简历","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"个人面经分享\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-24T13:37:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/interviews/"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"个人面经分享"}],["meta",{"property":"og:description","content":"个人面经分享 我将在这里分享我的面试经历并附加Gemini AI的相关回答,这是我的简历"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-24T13:37:14.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-24T13:37:14.000Z"}]]},"git":{"createdTime":1757250751000,"updatedTime":1758721034000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":12,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":54.82,"words":16446},"filePathRelative":"interviews/index.md","autoDesc":true}');export{k as comp,u as data};
