import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as r,o as i}from"./app-4GTAhYQ5.js";const n={};function l(c,t){return i(),e("div",null,t[0]||(t[0]=[r('<h1 id="juc并发工具类详解" tabindex="-1"><a class="header-anchor" href="#juc并发工具类详解"><span>JUC并发工具类详解</span></a></h1><p>在 Java 的 <code>java.util.concurrent</code> 包中，提供了几个强大的并发工具类，用于协调和控制多线程的执行。其中，<code>CountDownLatch</code>、<code>CyclicBarrier</code> 和 <code>Semaphore</code> 是最常用也最经典的三种。</p><h2 id="_1-countdownlatch-倒计时门闩" tabindex="-1"><a class="header-anchor" href="#_1-countdownlatch-倒计时门闩"><span>1. CountDownLatch (倒计时门闩)</span></a></h2><p><code>CountDownLatch</code> 允许一个或多个线程等待其他一组线程完成操作。它就像一个倒计时器，当计时器减到零时，所有等待的线程都会被唤醒。</p><ul><li><strong>生活比喻：火箭发射</strong><ul><li>想象一下火箭发射的场景。发射控制中心（主线程）必须等待所有系统自检（多个子线程，如燃料检查、导航系统检查等）全部完成，才能下达“点火”指令。</li><li><code>CountDownLatch</code> 的初始计数就是检查项的总数。每个检查项完成，就调用 <code>countDown()</code> 方法，计数减一。</li><li>发射控制中心则调用 <code>await()</code> 方法，一直阻塞等待，直到计数变为零，才继续执行点火。</li></ul></li><li><strong>核心方法:</strong><ul><li><code>CountDownLatch(int count)</code>: 构造函数，设置初始计数值。</li><li><code>await()</code>: 调用该方法的线程会被阻塞，直到计数器变为 0。</li><li><code>countDown()</code>: 将计数器减 1。</li></ul></li><li><strong>关键特性:</strong><ul><li><strong>一次性:</strong> 计数器减到 0 后，<code>CountDownLatch</code> 就完成了它的使命，不能被重置或重复使用。</li><li><strong>一对多/多对多:</strong> 可以是一个线程等待多个线程，也可以是多个线程等待另外多个线程。</li></ul></li><li><strong>适用场景:</strong><ul><li>当一个主任务需要等待多个子任务执行完毕后才能继续执行时。例如，并行计算后汇总结果，或者在应用程序启动时，主线程需要等待所有必要的服务都加载完毕。</li></ul></li></ul><h2 id="_2-cyclicbarrier-循环栅栏" tabindex="-1"><a class="header-anchor" href="#_2-cyclicbarrier-循环栅栏"><span>2. CyclicBarrier (循环栅栏)</span></a></h2><p><code>CyclicBarrier</code> 的目标是让一组线程相互等待，直到所有线程都到达一个公共的屏障点（barrier point），然后这些线程才能继续执行。</p><ul><li><strong>生活比喻：组团旅游</strong><ul><li>想象一个旅行团约定早上 8 点在酒店门口集合，然后一起出发去景点。每个人（线程）准备好后，就到门口等待。</li><li><code>CyclicBarrier</code> 就是这个“酒店门口”。当最后一个人到达后，“栅栏”被打破，所有人（所有线程）才一起出发。</li><li>更重要的是，这个栅栏是<strong>可循环使用</strong>的。他们到达第一个景点后，可以再次使用同一个栅栏等待所有人到齐，然后再去下一个景点。</li></ul></li><li><strong>核心方法:</strong><ul><li><code>CyclicBarrier(int parties)</code>: 构造函数，<code>parties</code> 指的是需要在此栅栏处等待的线程数量。</li><li><code>CyclicBarrier(int parties, Runnable barrierAction)</code>: 一个高级构造函数，当所有线程都到达栅栏时，会优先执行 <code>barrierAction</code> 这个任务，然后再释放所有等待的线程。</li><li><code>await()</code>: 线程调用此方法表示自己已到达栅栏，并开始等待其他线程。</li></ul></li><li><strong>关键特性:</strong><ul><li><strong>可重用性:</strong> 当所有等待的线程被释放后，栅栏可以被重用。</li><li><strong>集体行动:</strong> 强调的是“所有线程都到达”这个集体条件，而不是像 <code>CountDownLatch</code> 那样关心“任务是否完成”。</li></ul></li><li><strong>适用场景:</strong><ul><li>多线程计算中，需要将一个大任务拆分成多个阶段，确保所有线程都完成了当前阶段，才能进入下一阶段。</li></ul></li></ul><h2 id="_3-semaphore-信号量" tabindex="-1"><a class="header-anchor" href="#_3-semaphore-信号量"><span>3. Semaphore (信号量)</span></a></h2><p><code>Semaphore</code> 用于控制同一时间能够访问特定资源的线程数量。它内部维护了一组“许可证”（permits）。</p><ul><li><strong>生活比喻：停车场</strong><ul><li>一个停车场只有 10 个车位。<code>Semaphore</code> 就相当于停车场的入口管理员，他手上有 10 张停车许可证。</li><li>每当有车（线程）想进入停车场，就必须从管理员那里获取一张许可证 (<code>acquire()</code>)。如果许可证发完了，后来的车就必须在入口外排队等待。</li><li>每当有车离开停车场，它会交还许可证 (<code>release()</code>)，这样等待的车辆中就有一辆可以进入了。</li></ul></li><li><strong>核心方法:</strong><ul><li><code>Semaphore(int permits)</code>: 构造函数，设置许可证的总数量。</li><li><code>acquire()</code>: 获取一个许可证。如果许可证已耗尽，线程将阻塞等待。</li><li><code>release()</code>: 释放一个许可证，将其归还给信号量。</li></ul></li><li><strong>关键特性:</strong><ul><li><strong>流量控制:</strong> 核心功能是限制并发访问资源的线程数，而不是线程间的同步等待。</li><li><strong>公平性:</strong> 可以配置为公平模式，即按照线程请求的先后顺序来分配许可证。</li></ul></li><li><strong>适用场景:</strong><ul><li>任何需要限制并发访问数量的场景。例如，数据库连接池、实现一个有界的对象池，或者对某个计算密集型API的调用进行限流。</li></ul></li></ul><h2 id="总结对比" tabindex="-1"><a class="header-anchor" href="#总结对比"><span>总结对比</span></a></h2><table><thead><tr><th>特性</th><th>CountDownLatch (倒计时门闩)</th><th>CyclicBarrier (循环栅栏)</th><th>Semaphore (信号量)</th></tr></thead><tbody><tr><td><strong>核心功能</strong></td><td>一个或多个线程等待其他线程完成操作</td><td>一组线程相互等待到达某个公共点</td><td>控制同时访问特定资源的线程数量</td></tr><tr><td><strong>可重用性</strong></td><td>否，一次性使用</td><td>是，可以循环使用</td><td>是，许可证可以获取和释放</td></tr><tr><td><strong>关注点</strong></td><td>任务的完成（计数）</td><td>线程的到达（栅栏）</td><td>资源的访问（许可证）</td></tr><tr><td><strong>线程关系</strong></td><td>等待方和被等待方</td><td>所有线程地位平等，相互等待</td><td>竞争资源方</td></tr></tbody></table>',13)]))}const s=o(n,[["render",l]]),u=JSON.parse('{"path":"/8gu/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB.html","title":"JUC并发工具类详解","lang":"zh-CN","frontmatter":{"description":"JUC并发工具类详解 在 Java 的 java.util.concurrent 包中，提供了几个强大的并发工具类，用于协调和控制多线程的执行。其中，CountDownLatch、CyclicBarrier 和 Semaphore 是最常用也最经典的三种。 1. CountDownLatch (倒计时门闩) CountDownLatch 允许一个或多个...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC并发工具类详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-14T03:48:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"JUC并发工具类详解"}],["meta",{"property":"og:description","content":"JUC并发工具类详解 在 Java 的 java.util.concurrent 包中，提供了几个强大的并发工具类，用于协调和控制多线程的执行。其中，CountDownLatch、CyclicBarrier 和 Semaphore 是最常用也最经典的三种。 1. CountDownLatch (倒计时门闩) CountDownLatch 允许一个或多个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-14T03:48:22.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-14T03:48:22.000Z"}]]},"git":{"createdTime":1755143302000,"updatedTime":1755143302000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":1,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":4.45,"words":1335},"filePathRelative":"8gu/JUC工具类.md","autoDesc":true}');export{s as comp,u as data};
