import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o}from"./app-DNVEq80g.js";const p={};function i(r,e){return o(),a("div",null,e[0]||(e[0]=[n('<h1 id="springcloud" tabindex="-1"><a class="header-anchor" href="#springcloud"><span>SpringCloud</span></a></h1><h2 id="springcloud-5大组件有哪些" tabindex="-1"><a class="header-anchor" href="#springcloud-5大组件有哪些"><span>SpringCloud 5大组件有哪些？</span></a></h2><ul><li>注册中心/配置中心 Nacos</li><li>负载均衡 Ribbon</li><li>服务调用 Feign</li><li>服务保护 sentinel</li><li>服务网关 Gateway</li></ul><h2 id="分布式事务" tabindex="-1"><a class="header-anchor" href="#分布式事务"><span>分布式事务</span></a></h2><p>seata的AT模型分为两个阶段：</p><p>1、阶段一RM的工作：① 注册分支事务 ② 记录undo-log（数据快照）③ 执行业务sql并提交 ④报告事务状态</p><p>2、阶段二提交时RM的工作：删除undo-log即可</p><p>3、阶段二回滚时RM的工作：根据undo-log恢复数据到更新前</p><p>at模式牺牲了一致性，保证了可用性，不过，它保证的是最终一致性</p><h2 id="接口幂等性如何设计" tabindex="-1"><a class="header-anchor" href="#接口幂等性如何设计"><span>接口幂等性如何设计？</span></a></h2><p>第一次请求，会发起一个请求，在后台生成一个唯一token存入redis，key就是用户的id，value就是这个token，同时把这个token返回前端</p><p>第二次请求，会携带之前的token，后台先到redis进行验证，如果存在token，可以执行业务，同时删除token；如果不存在，则直接返回，不处理业务，就保证了同一个token只处理一次业务，就保证了幂等性</p><h2 id="rabbitmq-如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#rabbitmq-如何保证消息不丢失"><span>RabbitMQ 如何保证消息不丢失</span></a></h2><p>第一个是开启生产者确认机制，确保生产者的消息能到达队列，如果报错可以先记录到日志中，再去修复数据</p><p>第二个是开启持久化功能，确保消息未消费前在队列中不会丢失，其中的交换机、队列、和消息都要做持久化</p><p>第三个是开启消费者确认机制为auto，由spring确认消息处理成功后完成ack，当然也需要设置一定的重试次数，我们当时设置了3次，如果重试3次还没有收到消息，就将失败后的消息投递到异常交换机，交由人工处理</p><h2 id="rabbitmq中死信交换机" tabindex="-1"><a class="header-anchor" href="#rabbitmq中死信交换机"><span>RabbitMQ中死信交换机 ?</span></a></h2><p>延迟队列就是用到了死信交换机和TTL（消息存活时间）实现的。</p><p>如果消息超时未消费就会变成死信，在RabbitMQ中如果消息成为死信，队列可以绑定一个死信交换机，在死信交换机上可以绑定其他队列，在我们发消息的时候可以按照需求指定TTL的时间，这样就实现了延迟队列的功能了。</p><h2 id="如果有100万消息堆积在mq-如何解决" tabindex="-1"><a class="header-anchor" href="#如果有100万消息堆积在mq-如何解决"><span>如果有100万消息堆积在MQ , 如何解决 ?</span></a></h2><p>第一:提高消费者的消费能力 ,可以使用多线程消费任务</p><p>第二：增加更多消费者，提高消费速度</p><p>​ 使用工作队列模式, 设置多个消费者消费消费同一个队列中的消息</p><p>第三：扩大队列容积，提高堆积上限</p><p>可以使用RabbitMQ惰性队列，惰性队列的好处主要是</p><p>①接收到消息后直接存入磁盘而非内存</p><p>②消费者要消费消息时才会从磁盘中读取并加载到内存</p><p>③支持数百万条的消息存储</p>',28)]))}const d=t(p,[["render",i]]),c=JSON.parse('{"path":"/8gu/SpringCloud.html","title":"SpringCloud","lang":"zh-CN","frontmatter":{"description":"SpringCloud SpringCloud 5大组件有哪些？ 注册中心/配置中心 Nacos 负载均衡 Ribbon 服务调用 Feign 服务保护 sentinel 服务网关 Gateway 分布式事务 seata的AT模型分为两个阶段： 1、阶段一RM的工作：① 注册分支事务 ② 记录undo-log（数据快照）③ 执行业务sql并提交 ④报告...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SpringCloud\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-18T12:12:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/SpringCloud.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"SpringCloud"}],["meta",{"property":"og:description","content":"SpringCloud SpringCloud 5大组件有哪些？ 注册中心/配置中心 Nacos 负载均衡 Ribbon 服务调用 Feign 服务保护 sentinel 服务网关 Gateway 分布式事务 seata的AT模型分为两个阶段： 1、阶段一RM的工作：① 注册分支事务 ② 记录undo-log（数据快照）③ 执行业务sql并提交 ④报告..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-18T12:12:25.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-18T12:12:25.000Z"}]]},"git":{"createdTime":1750248745000,"updatedTime":1750248745000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":1,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":2.53,"words":760},"filePathRelative":"8gu/SpringCloud.md","autoDesc":true}');export{d as comp,c as data};
