import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,a as e,o as n}from"./app-BjIt_qog.js";const r={};function s(i,t){return n(),l("div",null,t[0]||(t[0]=[e('<h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql"><span>MySQL</span></a></h1><h2 id="bufferpool的缓存清除策略" tabindex="-1"><a class="header-anchor" href="#bufferpool的缓存清除策略"><span>BufferPool的缓存清除策略</span></a></h2><p>MySQL InnoDB 缓冲池淘汰机制采用改进的 <strong>LRU（最近最少使用）算法</strong>，核心是<strong>将缓存页分为“新生代”（热数据）和“老生代”（冷数据）两个区域</strong>，并设置一个 <strong>时间阈值</strong>。</p><p><strong>它解决了标准 LRU 的问题：</strong> 全表扫描或预读加载的大量可能只访问一次的“冷”页会被直接加入老生代尾部；即使这些页在短时间内被再次访问，只要间隔小于设定的时间阈值，就不会被提升到新生代。<strong>这样能有效防止一次性访问的“冷”数据冲刷掉真正频繁访问的“热”数据。</strong></p><p>淘汰时优先从老生代尾部移除冷数据，尤其是干净页。</p><h2 id="什么是doublewrite" tabindex="-1"><a class="header-anchor" href="#什么是doublewrite"><span>什么是DoubleWrite</span></a></h2><ol><li><strong>​解决什么问题？​</strong>​ <ul><li>InnoDB的数据操作单元是“页”（默认为16KB）。</li><li>操作系统（OS）和磁盘硬件（如HDD/SSD）的写操作通常以更小的“块”（如4KB）为单位进行。</li><li>当InnoDB将修改后的脏页<strong>刷回</strong>磁盘（如<code>.ibd</code>数据文件）时，如果<strong>系统崩溃或断电发生在写这16KB页的中间过程</strong>（例如只写了前4KB或前8KB），就会导致该页<strong>部分数据更新成功，部分未更新</strong>，造成<strong>页撕裂/部分写</strong>。这种页在逻辑上是损坏的，无法通过redo log（重做日志）恢复，因为redo log的前提是磁盘上的原始页是完整的。</li></ul></li><li><strong>如何工作？</strong><ul><li><strong>两步写入：</strong> 在将脏页写入其最终数据文件位置之前，InnoDB会<strong>先将脏页的副本</strong>写入一个专门的、连续分配的磁盘区域，叫做<strong>doublewrite buffer（双写缓冲区）</strong>。这个缓冲区通常位于系统表空间 (<code>ibdata1</code>) 中。</li><li><strong>顺序写入：</strong> 多个脏页的副本会被连续地、顺序地写入到doublewrite buffer区域。</li><li><strong>刷回实际位置：</strong> 只有在doublewrite buffer成功写完后，InnoDB才会将这些脏页实际写入（可能是随机写入）到它们各自在表空间数据文件 (<code>*.ibd</code>) 中的最终位置。</li></ul></li><li><strong>如何保障数据？</strong><ul><li>如果在第二步（写入实际位置）<strong>之前</strong>发生崩溃：doublewrite buffer里的副本是完整的（因为是原子写入较小的块或由存储保证），最终位置的数据页未更新或仍是旧的完整页。重启恢复时，InnoDB用doublewrite buffer里的完整副本来覆盖最终位置的数据页。</li><li>如果在第二步（写入实际位置）<strong>期间</strong>发生崩溃（部分写）：最终位置的数据页是损坏的，但doublewrite buffer里的副本是完整的。重启恢复时，InnoDB发现最终位置数据页损坏，于是用doublewrite buffer里的完整副本来修复它。</li></ul></li></ol><p><strong>简单说：doublewrite是先写一份完整的“备份”到一个安全区域，再写正式位置。如果写正式位置时出错了，就用安全区的“备份”来修复。它牺牲了一点写性能（两次写），换取了数据页物理完整性的关键保障，使得数据库在崩溃后能安全恢复。</strong> 对于使用保证原子写入（如大多数现代SSD的16K原子写入）的系统，可以关闭doublewrite以提升性能，但通常默认启用以保证最大可靠性。</p><h2 id="什么是索引下推" tabindex="-1"><a class="header-anchor" href="#什么是索引下推"><span>什么是索引下推</span></a></h2><ol><li>核心原理（一句话概括）：</li></ol><blockquote><p><strong>将 <code>WHERE</code> 子句中与索引列相关的部分过滤条件下推给存储引擎（如InnoDB），在扫描索引过程中提前过滤无效数据，避免将所有索引记录都返回给MySQL服务器层再过滤。</strong></p></blockquote><ol start="2"><li>具体工作流程对比：</li></ol><ul><li><strong>未使用索引下推（传统方式）：</strong></li></ul><ol><li><strong>存储引擎</strong>：根据索引定位到满足<strong>最左匹配原则的条件</strong>的记录。</li><li><strong>存储引擎→服务器层</strong>：将所有满足最左条件的记录对应的<strong>主键（或行ID）返回</strong>。</li><li><strong>服务器层</strong>：根据主键回表查询完整行数据 → 再应用 <code>WHERE</code> 子句<strong>剩余的过滤条件</strong>进行二次过滤。</li><li><strong>问题</strong>：如果索引初步筛选的结果集很大，但实际匹配的记录很少，会产生大量无效回表操作。</li></ol><ul><li><strong>使用索引下推（ICP）：</strong></li></ul><ol><li><p><strong>存储引擎</strong>：根据索引定位到满足<strong>最左匹配条件</strong>的记录。</p></li><li><p><strong>存储引擎内部过滤</strong>：直接在索引结构中检查 <strong><code>WHERE</code> 子句剩余的其他索引列条件</strong>（即使不满足最左匹配）。</p></li><li><p><strong>存储引擎→服务器层</strong>：只返回<strong>同时满足所有索引列条件</strong>的记录的主键。</p></li><li><p><strong>服务器层</strong>：仅对少量主键回表查询完整数据 → 执行最终过滤（如非索引列条件）。</p></li></ol><h2 id="sql语句的执行过程" tabindex="-1"><a class="header-anchor" href="#sql语句的执行过程"><span>SQL语句的执行过程</span></a></h2><figure><img src="https://pub-8f51c562924b4b9f89b40704dbb3bc16.r2.dev/PicGo/1676276921091-c44ad9b7-f173-4099-9bed-39486d5dbd07-357586.png" alt="1676276921091-c44ad9b7-f173-4099-9bed-39486d5dbd07.png" tabindex="0" loading="lazy"><figcaption>1676276921091-c44ad9b7-f173-4099-9bed-39486d5dbd07.png</figcaption></figure><p>①使用<strong>连接器</strong>，通过客户端/服务器通信协议与 MySQL 建立连接。并查询是否有权限</p><p>②Mysql8.0之前<strong>检查是否开启缓存</strong>，开启了 Query Cache 且命中完全相同的 SQL 语句，则将查询结果直接返回给客户端；</p><p>③由<strong>解析器(分析器)</strong> 进行语法分析和语义分析，并生成解析树。如查询是select、表名users、条件是age=&#39;18&#39; and name=&#39;Hollis&#39;，<strong>预处理器</strong>则会根据 MySQL 规则进一步检查解析树是否合法。比如检查要查询的数据表或数据列是否存在等。</p><p>④由<strong>优化器</strong>生成执行计划。根据索引看看是否可以优化</p><p>⑤<strong>执行器</strong>来执行SQL语句，这里具体的执行会操作MySQL的存储引擎来执行 SQL 语句，根据存储引擎类型，得到查询结果。若开启了 Query Cache，则缓存，否则直接返回。</p><h2 id="不可重复读怎么解决幻读问题-它解决不了哪些幻读" tabindex="-1"><a class="header-anchor" href="#不可重复读怎么解决幻读问题-它解决不了哪些幻读"><span>不可重复读怎么解决幻读问题?它解决不了哪些幻读？</span></a></h2><p><strong>MySQL的InnoDB引擎利用间隙锁和临键锁，在其可重复读隔离级别下有效地阻止了其他事务向当前事务查询范围插入新行，从而防止了幻读的发生。</strong></p><p>MySQL的可重复读隔离级别通过MVCC和Next-Key Lock<strong>解决了大部分幻读场景</strong>，但两类操作仍可能突破防线：</p><ol><li>事务内混用快照读和当前读时，因数据可见性不一致导致逻辑幻读。</li><li>在表末尾插入数据时，因间隙锁无法覆盖无限区间而产生物理幻读。</li></ol><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁"><span>锁</span></a></h2><h3 id="全局锁" tabindex="-1"><a class="header-anchor" href="#全局锁"><span>全局锁</span></a></h3><ul><li><strong>锁的粒度</strong>：整个数据库实例。</li><li><strong>特点</strong>： <ul><li>加锁后，<strong>整个数据库处于只读状态</strong>，所有表的写操作（如 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）和表结构修改（如 <code>ALTER TABLE</code>）都会被阻塞。</li><li><strong>典型使用场景</strong>：全库逻辑备份（如 <code>mysqldump</code>）。</li></ul></li><li><strong>实现方式</strong>： <ul><li>使用 <code>FLUSH TABLES WITH READ LOCK (FTWRL)</code> 命令加锁。</li><li>使用 <code>UNLOCK TABLES</code> 命令释放锁。</li></ul></li></ul><h3 id="表级锁" tabindex="-1"><a class="header-anchor" href="#表级锁"><span>表级锁</span></a></h3><ul><li><strong>锁的粒度</strong>：整张表。</li><li><strong>特点</strong>： <ul><li><strong>并发性能较低</strong>，但开销较小，适用于读多写少的场景。</li><li><strong>支持存储引擎</strong>：MyISAM、InnoDB。</li></ul></li><li><strong>子类锁</strong>： <ul><li><strong>表锁</strong>： <ul><li><strong>共享读锁</strong>（<code>READ LOCK</code>）： <ul><li>允许其他事务读取表，但<strong>阻塞写操作</strong>。</li><li>示例：<code>LOCK TABLES tb_user READ;</code></li></ul></li><li><strong>排他写锁</strong>（<code>WRITE LOCK</code>）： <ul><li>阻塞其他事务的读和写。</li><li>示例：<code>LOCK TABLES tb_user WRITE;</code></li></ul></li></ul></li><li><strong>元数据锁（MDL）</strong>： <ul><li><strong>自动控制</strong>，无需显式加锁。</li><li><strong>作用</strong>：防止 DML（增删改查）与 DDL（表结构修改）冲突。</li><li><strong>锁类型</strong>： <ul><li><strong>共享锁</strong>（<code>SHARED_READ</code>/<code>SHARED_WRITE</code>）：用于读/写操作。</li><li><strong>排他锁</strong>（<code>EXCLUSIVE</code>）：用于表结构修改（如 <code>ALTER TABLE</code>）。</li></ul></li></ul></li><li><strong>意向锁</strong>（Intent Lock）： <ul><li><strong>协调行锁与表锁</strong>，减少冲突检查。</li><li><strong>类型</strong>： <ul><li><strong>意向共享锁</strong>（<code>IS</code>）：事务计划对某些行加共享锁。</li><li><strong>意向排他锁</strong>（<code>IX</code>）：事务计划对某些行加排他锁。</li></ul></li></ul></li></ul></li></ul><h3 id="行级锁" tabindex="-1"><a class="header-anchor" href="#行级锁"><span>行级锁</span></a></h3><ul><li><strong>锁的粒度</strong>：单个行。</li><li><strong>特点</strong>： <ul><li><strong>并发性能高</strong>，但开销较大，适用于高并发写操作的场景。</li><li><strong>依赖索引</strong>：只有通过索引条件检索数据时，InnoDB 才使用行级锁；否则退化为表级锁。</li><li><strong>支持存储引擎</strong>：InnoDB。</li></ul></li><li><strong>锁类型</strong>： <ul><li><strong>记录锁</strong>（Record Lock）： <ul><li>锁定索引记录。</li><li>示例：<code>SELECT * FROM table WHERE id = 1 FOR UPDATE;</code></li></ul></li><li><strong>间隙锁</strong>（Gap Lock）： <ul><li>锁定索引之间的间隙，防止幻读。</li><li>示例：<code>SELECT * FROM table WHERE id BETWEEN 10 AND 20 FOR UPDATE;</code></li></ul></li><li><strong>临键锁</strong>（Next-Key Lock）： <ul><li>记录锁 + 间隙锁，防止幻读。</li><li>是 InnoDB 默认的行锁模式。</li></ul></li></ul></li></ul><h2 id="修改一条记录什么情况下会锁表-什么情况下会锁行" tabindex="-1"><a class="header-anchor" href="#修改一条记录什么情况下会锁表-什么情况下会锁行"><span>修改一条记录什么情况下会锁表？什么情况下会锁行？</span></a></h2><table><thead><tr><th style="text-align:left;"><strong>情况</strong></th><th style="text-align:left;"><strong>锁表还是锁行？</strong></th><th style="text-align:left;"><strong>关键决定因素</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>WHERE 无法利用索引</strong></td><td style="text-align:left;">几乎总是锁表</td><td style="text-align:left;">数据库无法精确定位目标行，只能进行全表扫描</td></tr><tr><td style="text-align:left;"><strong>显式表锁操作</strong></td><td style="text-align:left;">锁表</td><td style="text-align:left;">显式执行了 <code>LOCK TABLES</code> 等命令</td></tr><tr><td style="text-align:left;"><strong>DDL 操作（ALTER等）</strong></td><td style="text-align:left;">锁表</td><td style="text-align:left;">修改表结构需要独占整个表</td></tr><tr><td style="text-align:left;"><strong>大量修改导致锁升级</strong></td><td style="text-align:left;">锁表</td><td style="text-align:left;">修改行数过多，超出阈值</td></tr><tr><td style="text-align:left;"><strong>没有 WHERE 条件</strong></td><td style="text-align:left;">锁表</td><td style="text-align:left;">操作涉及表中所有行</td></tr><tr><td style="text-align:left;"><strong>WHERE 能利用索引</strong></td><td style="text-align:left;"><strong>锁行</strong> (包括索引记录和可能的间隙)</td><td style="text-align:left;">数据库能通过索引精确定位一个或多个目标行</td></tr><tr><td style="text-align:left;"><strong>主键/唯一键冲突的插入</strong></td><td style="text-align:left;"><strong>锁行</strong> (锁冲突的具体索引记录)</td><td style="text-align:left;">能精确定位到已存在的键值</td></tr><tr><td style="text-align:left;"><strong>意向锁 (IS, IX)</strong></td><td style="text-align:left;"><strong>不是锁表操作！</strong> (协调锁的辅助机制，通常与其他行锁或表锁共存)</td><td style="text-align:left;">表明事务的意图（稍后要在某些行加锁）。虽然作用在表级别，但本身非常轻量且兼容，不影响大部分并发操作</td></tr></tbody></table>',36)]))}const a=o(r,[["render",s]]),c=JSON.parse('{"path":"/8gu/Mysql.html","title":"MySQL","lang":"zh-CN","frontmatter":{"description":"MySQL BufferPool的缓存清除策略 MySQL InnoDB 缓冲池淘汰机制采用改进的 LRU（最近最少使用）算法，核心是将缓存页分为“新生代”（热数据）和“老生代”（冷数据）两个区域，并设置一个 时间阈值。 它解决了标准 LRU 的问题： 全表扫描或预读加载的大量可能只访问一次的“冷”页会被直接加入老生代尾部；即使这些页在短时间内被再次访...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL\\",\\"image\\":[\\"https://pub-8f51c562924b4b9f89b40704dbb3bc16.r2.dev/PicGo/1676276921091-c44ad9b7-f173-4099-9bed-39486d5dbd07-357586.png\\"],\\"dateModified\\":\\"2025-07-07T00:58:01.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/Mysql.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"MySQL"}],["meta",{"property":"og:description","content":"MySQL BufferPool的缓存清除策略 MySQL InnoDB 缓冲池淘汰机制采用改进的 LRU（最近最少使用）算法，核心是将缓存页分为“新生代”（热数据）和“老生代”（冷数据）两个区域，并设置一个 时间阈值。 它解决了标准 LRU 的问题： 全表扫描或预读加载的大量可能只访问一次的“冷”页会被直接加入老生代尾部；即使这些页在短时间内被再次访..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pub-8f51c562924b4b9f89b40704dbb3bc16.r2.dev/PicGo/1676276921091-c44ad9b7-f173-4099-9bed-39486d5dbd07-357586.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-07T00:58:01.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-07T00:58:01.000Z"}]]},"git":{"createdTime":1750248745000,"updatedTime":1751849881000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":4,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":8.02,"words":2405},"filePathRelative":"8gu/Mysql.md","autoDesc":true}');export{a as comp,c as data};
