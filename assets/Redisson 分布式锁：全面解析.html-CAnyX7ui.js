import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as n,o as t}from"./app-D1r3k4w5.js";const l={};function e(h,s){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="redisson-分布式锁-全面解析" tabindex="-1"><a class="header-anchor" href="#redisson-分布式锁-全面解析"><span>Redisson 分布式锁：全面解析</span></a></h1><p>在分布式系统中，多个服务实例需要协调对共享资源的访问，以避免数据不一致和竞争条件。分布式锁是解决这个问题的关键技术之一。Redisson 是一个基于 Redis 的 Java 驻内存数据网格（In-Memory Data Grid），它提供了一系列分布式的 Java 对象和服务，其中<strong>分布式锁（<code>RLock</code>）</strong> 是其最核心和最受欢迎的功能。</p><h2 id="核心实现原理" tabindex="-1"><a class="header-anchor" href="#核心实现原理"><span>核心实现原理</span></a></h2><p>Redisson 分布式锁的强大之处在于它解决了原生 <code>SETNX</code> 命令在实际应用中的诸多缺陷，例如锁无法自动续期、非可重入等问题。其底层实现主要依赖以下几个关键机制：</p><h3 id="_1-原子性操作-lua-脚本" tabindex="-1"><a class="header-anchor" href="#_1-原子性操作-lua-脚本"><span>1. 原子性操作 (Lua 脚本)</span></a></h3><p>Redisson 的加锁和解锁操作是<strong>原子性</strong>的。它不是简单地使用 <code>SETNX</code>，而是通过执行一段精心设计的 <strong>Lua 脚本</strong>来完成。Redis 服务端能保证 Lua 脚本在执行过程中的原子性，即脚本要么全部成功，要么全部失败，执行期间不会被其他命令打断。</p><p>一个简化的加锁逻辑 Lua 脚本大致如下：</p><ul><li><strong>检查锁是否存在</strong>：如果锁不存在，则通过 <code>HSET</code> 命令创建一个 Redis Hash 结构来存储锁，并记录下当前线程 ID 和一个计数器（初始为 1），同时设置过期时间。</li><li><strong>检查是否为重入</strong>：如果锁已存在，检查 Hash 中存储的线程 ID 是否和当前线程 ID 相同。如果相同，则说明是同一线程的<strong>重入</strong>请求，此时将计数器加 1，并重新设置过期时间。</li><li><strong>获取锁失败</strong>：如果锁已存在且线程 ID 不同，则返回失败（或剩余的过期时间）。</li></ul><h3 id="_2-看门狗-watchdog-机制" tabindex="-1"><a class="header-anchor" href="#_2-看门狗-watchdog-机制"><span>2. 看门狗 (Watchdog) 机制</span></a></h3><p>这是 Redisson 分布式锁的<strong>标志性特性</strong>。如果在获取锁时没有指定租约时间（Lease Time），Redisson 会启用“看门狗”机制。</p><ul><li><strong>问题场景</strong>：假设你给一个锁设置了 30 秒的过期时间，但业务逻辑执行了 35 秒。在第 30 秒时，锁会自动释放，其他线程会立即获取到该锁，导致并发问题。</li><li><strong>解决方案</strong>： <ul><li>当一个线程成功获取锁后，Redisson 会启动一个后台线程（即“看门狗”）。</li><li>看门狗会<strong>定期检查</strong>（默认每 10 秒）该锁是否仍然被持有。</li><li>如果锁仍然被持有，看门狗会<strong>自动延长</strong>该锁的过期时间（重新设置为默认的 30 秒）。</li><li>这个过程会一直持续，直到持有锁的线程释放了锁，或者该客户端实例宕机。</li></ul></li></ul><blockquote><p><strong>注意</strong>：只有在未显式指定 <code>leaseTime</code> 时，看门狗才会生效。如果手动设置了 <code>lock.lock(60, TimeUnit.SECONDS)</code>，则锁会在 60 秒后自动释放，看门狗不会续期。</p></blockquote><h3 id="_3-可重入性-reentrancy" tabindex="-1"><a class="header-anchor" href="#_3-可重入性-reentrancy"><span>3. 可重入性 (Reentrancy)</span></a></h3><p>Redisson 的锁是<strong>可重入</strong>的。这意味着一个已经持有锁的线程可以再次成功获取该锁，而不会造成死锁。</p><ul><li><strong>实现方式</strong>：如上文 Lua 脚本所述，Redisson 使用 Redis 的 <strong>Hash</strong> 数据结构 (<code>HSET</code>) 来存储锁。Hash 中不仅记录了锁的状态，还存储了持有锁的线程 ID (<code>&lt;threadId&gt;:&lt;count&gt;</code>) 和一个重入计数器。</li><li><strong>流程</strong>： <ul><li>线程第一次加锁时，计数器为 1。</li><li>该线程再次加锁，Redisson 发现线程 ID 相同，就将计数器加 1。</li><li>解锁时，每次将计数器减 1。只有当计数器减到 0 时，锁才会被真正释放，其他线程才能获取。</li></ul></li></ul><h3 id="_4-等待与唤醒-pub-sub" tabindex="-1"><a class="header-anchor" href="#_4-等待与唤醒-pub-sub"><span>4. 等待与唤醒 (Pub/Sub)</span></a></h3><p>当一个线程尝试获取锁失败时，它如何等待？低效的方式是 <code>while(true)</code> 循环尝试。Redisson 采用了更高效的 <strong>发布/订阅 (Pub/Sub)</strong> 机制。</p><ul><li><strong>订阅</strong>：尝试获取锁失败的线程会订阅一个与锁相关的特定 Redis Channel。</li><li><strong>等待</strong>：之后，该线程会进入等待状态。</li><li><strong>发布</strong>：当持有锁的线程释放锁时，它会向该 Channel 发布一条消息。</li><li><strong>唤醒</strong>：所有订阅了该 Channel 的等待线程都会收到消息，并被唤醒，然后开始新一轮的锁竞争。</li></ul><h2 id="基础使用示例" tabindex="-1"><a class="header-anchor" href="#基础使用示例"><span>基础使用示例</span></a></h2><p>使用 Redisson 分布式锁非常简单，其接口设计与 Java 的 <code>java.util.concurrent.locks.Lock</code> 完全兼容。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.redisson.api.RLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.redisson.api.RedissonClient</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ... 其他 import</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> DistributedLockExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RedissonClient</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redissonClient</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DistributedLockExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RedissonClient</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> redissonClient</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redissonClient</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> redissonClient;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> accessSharedResource</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 1. 获取锁实例，&quot;myLock&quot; 是锁在 Redis 中的 key</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        RLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redissonClient</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;myLock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 2. 尝试加锁</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // lock.lock() 会一直等待直到获取锁，并启用看门狗机制</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 也可以使用 lock.tryLock(long waitTime, long leaseTime, TimeUnit unit)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;线程 &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; 获取了锁，开始执行业务逻辑...&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 模拟业务逻辑执行</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;线程 &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; 业务逻辑执行完毕。&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">interrupt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 3. 确保在 finally 块中释放锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isLocked</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isHeldByCurrentThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;线程 &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; 释放了锁。&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>最佳实践</strong>：始终将 <code>lock.unlock()</code> 放在 <code>finally</code> 块中，以确保即使业务逻辑发生异常，锁也能被正确释放。</p><h2 id="优缺点总结" tabindex="-1"><a class="header-anchor" href="#优缺点总结"><span>优缺点总结</span></a></h2><table><thead><tr><th>特性</th><th>Redisson 分布式锁 (<code>RLock</code>)</th></tr></thead><tbody><tr><td><strong>优点</strong></td><td>✅ <strong>功能强大</strong>：内置看门狗自动续期，解决了锁超时问题。</td></tr><tr><td></td><td>✅ <strong>可重入</strong>：与 Java Lock 行为一致，避免同一线程死锁。</td></tr><tr><td></td><td>✅ <strong>高效率等待</strong>：使用 Pub/Sub 机制，避免了无效的 CPU 轮询。</td></tr><tr><td></td><td>✅ <strong>封装完善</strong>：API 友好，隐藏了底层复杂的 Lua 脚本和实现细节。</td></tr><tr><td></td><td>✅ <strong>提供多种锁</strong>：支持公平锁、读写锁、信号量等多种同步工具。</td></tr><tr><td><strong>缺点</strong></td><td>❌ <strong>引入额外依赖</strong>：需要引入 Redisson 的客户端库，比原生实现更重。</td></tr><tr><td></td><td>❌ <strong>依赖 Redis</strong>：系统的健壮性依赖于 Redis 集群的健壮性。</td></tr><tr><td></td><td>❌ <strong>配置复杂性</strong>：相对于简单脚本，Redisson 客户端的配置选项更多。</td></tr></tbody></table><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论"><span>结论</span></a></h2><p>Redisson 分布式锁通过巧妙地结合 <strong>Lua 脚本</strong>、<strong>看门狗机制</strong>、<strong>Hash 结构</strong>和 <strong>Pub/Sub</strong>，提供了一个功能完备、健壮且易于使用的分布式锁解决方案。它极大地简化了开发人员在分布式环境中处理并发问题的复杂性，是构建可靠分布式系统的首选工具之一。</p>`,26)]))}const r=i(l,[["render",e]]),d=JSON.parse('{"path":"/8gu/Redisson%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9A%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90.html","title":"Redisson 分布式锁：全面解析","lang":"zh-CN","frontmatter":{"description":"Redisson 分布式锁：全面解析 在分布式系统中，多个服务实例需要协调对共享资源的访问，以避免数据不一致和竞争条件。分布式锁是解决这个问题的关键技术之一。Redisson 是一个基于 Redis 的 Java 驻内存数据网格（In-Memory Data Grid），它提供了一系列分布式的 Java 对象和服务，其中分布式锁（RLock） 是其最核...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redisson 分布式锁：全面解析\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-14T03:48:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CodeLong\\",\\"url\\":\\"codelong.top\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/8gu/Redisson%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9A%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"CodeLong"}],["meta",{"property":"og:title","content":"Redisson 分布式锁：全面解析"}],["meta",{"property":"og:description","content":"Redisson 分布式锁：全面解析 在分布式系统中，多个服务实例需要协调对共享资源的访问，以避免数据不一致和竞争条件。分布式锁是解决这个问题的关键技术之一。Redisson 是一个基于 Redis 的 Java 驻内存数据网格（In-Memory Data Grid），它提供了一系列分布式的 Java 对象和服务，其中分布式锁（RLock） 是其最核..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-14T03:48:22.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-14T03:48:22.000Z"}]]},"git":{"createdTime":1755143302000,"updatedTime":1755143302000,"contributors":[{"name":"1973034392","username":"1973034392","email":"1973034392@qq.com","commits":1,"url":"https://github.com/1973034392"}]},"readingTime":{"minutes":5.22,"words":1566},"filePathRelative":"8gu/Redisson 分布式锁：全面解析.md","autoDesc":true}');export{r as comp,d as data};
